---
typora-root-url: ..\..
---

# 输入事件与页面渲染

## 概述



我们在屏幕上所看到的浏览器的画面其实是一幅位图，当输入事件所引发的事件监听器或默认动作修改了页面的样式后，浏览器就会迅速的更新这幅位图来响应这些修改，这样用户便产生了“浏览器响应了我的操作”这种错觉。比如，当用户滚动了滚轮之后，浏览器就会根据滚轮的滚动情况来决定该如何滚动页面，并尽可能的以屏幕的刷新频率来更新页面的位图，这样就可以制造出流畅的滚动动画了，不过如果更新的频率不够高或时间间隔不够均匀，用户就会感觉到滚动动画很卡顿（jank），所以卡顿的本质是更新发生了延迟。

> 我不确定浏览器的画面到底是一幅完整的位图，还是由多幅位图拼接而成的拼图，因为 Chrome Blog 提到过浏览器 UI 的位图和选项卡页面的位图是分开生成的，不过哪怕不知道这个问题的答案，也不会影响我们理解这篇文章，所以暂勿纠结。

本文将会介绍的是浏览器处理输入事件与更新页面的过程。

## 重排和重绘

在正式开始之前，我们需要先介绍重排、重绘这 2 个概念。

首先，回顾《页面的渲染》一文，Chrome 渲染页面的流程有 8 个步骤，分别是：1.构建 DOM、2.计算样式、3.计算布局、4.创建绘图指令、5.分层、6.分块、7.光栅化、8.合成。

如果页面重新排版了自己的布局，那么我们就认为页面发生了重排（reflow）。当页面发生了重排之后，浏览器就会按需的执行渲染流程中的某些步骤来更新页面，而浏览器到底需要执行哪些步骤则取决于引发重排的具体行为，比如：

- 如果浏览器窗口收窄了，页面就需要进行收缩，此时，浏览器只需要从第 2 步开始来执行渲染流程就可以渲染出收缩后的页面了，因为此时没有修改 DOM，所以不必再重新构建 DOM（第 1 步），不过样式计算（第 2 步）及其后续步骤显然都是必须的，因为遵循响应式布局的页面的元素都必不可少的会依赖 viewport 的尺寸。
- 如果增加、删除、移动了 DOM 中的节点，那么就需要重新执行完整的渲染流程，因为这改变了 DOM 的结构，而后续的所有步骤都是直接或间接的依赖 DOM 的。
- 如果修改了元素的尺寸，那么就需要从第 2 步开始来执行渲染流程，因为这个元素的样式发生了变化，并且其他元素的样式也可能会受其影响而发生变化。

如果元素只是更新了自己的背景颜色、背景样式等东西时，我们就认为页面发生了重绘（repaint），重绘所需执行的渲染流程的步骤更少一些，只需要重新计算样式、计算布局、创建绘图指令、光栅化、合成就够了。

## 合成

另外，我们还需要介绍合成这个概念。

合成是指浏览器只通过合成（第 8 步）来渲染页面的行为，具体来说，合成器线程可以通过改变图块位图的状态（比如位置、旋转等）来让 GPU 直接合成出新的页面位图，由于这种渲染策略可以跳过大部分的渲染流程，并且合成线程还可以和主线程并行工作，因此这种渲染策略可以很快的渲染出新的页面位图，而 Chrome 也采用了这种渲染策略来渲染某些 CSS3 动画和页面的滚动。

善用由合成来实现的动画有利于增加流畅的体验，不过还有很多动画是不能光靠合成来实现的。

## 输入事件

对浏览器而言，诸如点击鼠标、键入文本、触摸屏幕、滚动滚轮等行为都属于输入事件，输入事件的真正定义是用户与浏览器的交互行为，而不是通俗理解的“输入”。

## 事件监听器与默认动作

当浏览器接收到输入事件后，它就会调用相应的事件监听器。另外，有些输入事件还会触发某些默认动作。

比如复选框的默认动作是勾选或取消勾选、超链接标签的默认动作是更改字体颜色和跳转。无论是复选框还是超链接标签，它们的默认动作都会触发页面的重绘，甚至超链接标签的默认动作还会触发跳转，而重绘和页面跳转



滚轮的默认动作是滚动页面等等。

在大多数情况下，默认动作是由渲染进程的主线程来执行的，并且主线程只有在执行完其余的任务后才会执行默认动作，因此默认动作的触发时机是在所有事件监听器之后。

如果输入事件既绑定了事件监听器，又会触发默认动作的话，那么浏览器就会在执行完事件监听器之后再执行默认动作。

事件监听器和默认动作都具有修改页面样式的能力，如果事件监听器修改了页面的样式，那么新的页面只有在事件监听器执行结束之后才会被渲染出来，如果事件监听器执行了一个非常耗时的任务，那么在新旧页面之间就会出现一个明显的页面假死，在页面假死期间，用户无法与页面进行任何交互。

```js
globalThis.
```



## 处理输入事件

当用户与浏览器发生了交互之后，浏览器会捕捉到这个交互的输入事件，然后将该事件的类型（如 `click`）和坐标（如 `(x,y)`）发送给渲染进程。

渲染进程的合成器线程会首先接收到这则信息，然后合成器线程会根据输入事件的发生地点来判断这个输入事件是否会触发事件监听器。

如果合成器线程判断出这个输入事件不会触发任何事件监听器，那么合成器就会直接生产新的帧画面（具体是指新的页面的位图，下同）。

如果合成器判断出这个输入事件会触发事件监听器，那么合成器线程就会将这则消息发送给主线程，由主线程来找到并调用相应的事件监听器。有时候，合成器线程会等待主线程处理完所有的事件监听器之后再工作。有时候，合成器线程不会等待主线程，而是在将输入事件的消息发送给主线程之后，就立即开始自己的工作。

![输入事件的信息](/static/image/markdown/browser/deal-with-input-event/input-event-information.png)

## Non-Fast Scrollable Region

为什么合成器线程可以根据输入事件的发生地来判断输入事件是否会触发事件监听器呢？本节将会解答这个问题。

合成器线程会将绑定了事件监听器的区域标记为 non-fast scrollable region，如果输入事件发生在标记区域的范围内，合成器线程就会将输入事件的信息发送给主线程，否则就不会。

![non-fast-scrollable-region](/static/image/markdown/browser/deal-with-input-event/non-fast-scrollable-region.png)

我们经常会使用事件代理来为元素绑定事件监听器，它的具体原理是：将事件监听器绑定在祖先节点的身上，然后通过判断输入事件究竟发生在哪个子孙节点的身上来决定应该执行哪些任务。

不过，事件代理会扩大 non-fast scrollable region 的范围，比如，如果将事件监听器绑定在了 `globalThis` 节点上，那么整个页面都将会被标记为 non-fast scrollable region。这样一来，如果无论输入事件发生在页面的哪个位置，合成器线程都必须与主线程通信，哪怕输入事件根本没有触发任何事件监听器。而且，如果主线程还会阻塞合成器线程的话，那么一旦事件监听器的执行时间较长，原本流畅的页面动画就会变得卡顿。

![使用事件代理将可能扩大non-fast scrollable region的区域](/static/image/markdown/browser/deal-with-input-event/event-delegation.png)

## 主线程阻塞合成器线程

如果合成器线程发现输入事件发生在 non-fast scrollable region，那么合成器线程就会将输入事件的信息发送给主线程，由主线程来找到并调用相应的事件监听器。有时候，合成器线程会等待主线程处理完所有的事件监听器之后再工作。有时候，合成器线程不会等待主线程，而是在将输入事件的消息发送给主线程之后，就立即开始自己的工作。

合成器线程之所以会被主线程阻塞，是因为事件监听器有影响页面渲染的能力

# TODO

记录参考文献

给主页使用 wheel 和 touch start 的禁止滚动事件。
