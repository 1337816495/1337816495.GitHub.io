---
typora-root-url: ..\..
---

# 输入事件与页面渲染

## 概述

我们在屏幕上所看到的浏览器的画面其实是一幅位图，当输入事件所引发的事件监听器或默认动作修改了页面的样式后，浏览器就会迅速的更新这幅位图来响应这些修改，这样用户便产生了“浏览器响应了我的操作”这种错觉。比如，当用户滚动了滚轮之后，浏览器就会根据滚轮的滚动情况来决定该如何滚动页面，并尽可能的以屏幕的刷新频率来更新页面的位图，这样就可以制造出流畅的滚动动画了，不过如果更新的频率不够高或时间间隔不够均匀，用户就会感觉到滚动动画很卡顿（jank），所以卡顿的本质是更新发生了延迟。

> 我不确定浏览器的画面到底是一幅完整的位图，还是由多幅位图拼接而成的拼图，因为 Chrome Blog 提到过浏览器 UI 的位图和选项卡页面的位图是分开生成的，不过哪怕不知道这个问题的答案，也不会影响我们理解这篇文章，所以暂勿纠结。

本文将会介绍的是浏览器处理输入事件与更新页面的过程。

## 重排和重绘

在正式开始之前，我们需要先介绍重排、重绘这 2 个概念。

回顾《页面的渲染》一文，Chrome 渲染页面的流程有 8 个步骤，分别是：1.构建 DOM、2.计算样式、3.计算布局、4.创建绘图指令、5.分层、6.分块、7.光栅化、8.合成。

如果页面重新排版了自己的布局，那么我们就认为页面发生了重排（reflow）。当页面发生了重排之后，浏览器就会按需的执行渲染流程中的某些步骤来更新页面，而浏览器到底需要执行哪些步骤则取决于引发重排的具体行为，比如：

- 如果浏览器窗口收窄了，页面就需要进行收缩，此时，浏览器只需要从第 2 步开始来执行渲染流程就可以渲染出收缩后的页面了，因为此时没有修改 DOM，所以不必再重新构建 DOM（第 1 步），不过样式计算（第 2 步）及其后续步骤显然都是必须的，因为遵循响应式布局的页面的元素都必不可少的会依赖 viewport 的尺寸。
- 如果增加、删除、移动了 DOM 中的节点，那么就需要重新执行完整的渲染流程，因为这改变了 DOM 的结构，而后续的所有步骤都是直接或间接的依赖 DOM 的。
- 如果修改了元素的尺寸，那么就需要从第 2 步开始来执行渲染流程，因为这个元素的样式发生了变化，并且其他元素的样式也可能会受其影响而发生变化。

如果元素只是更新了自己的背景颜色、背景样式等东西时，我们就认为页面发生了重绘（repaint），重绘所需执行的渲染流程的步骤更少一些，只需要重新计算样式、计算布局、创建绘图指令、光栅化、合成就够了。

根据浏览器的事件循环，如果主线程上的任务修改了页面，那么浏览器就会等待主线程执行完所有任务之后在渲染新的页面位图。由于重排和重绘的部分步骤是由主线程的执行的，比如第 1 步至第 5 步，所以重排和重绘会受到主线程的阻塞。具体来说，假设我们为页面绑定一个点击事件的监听器，该监听器会将页面的背景色改为粉色（重绘），同时该监听器会执行一个非常耗时的任务，那么当用户点击了页面之后，页面并不会立即变成粉色，而是会过一阵子才会变成粉色。

```js
globalThis.addEventListener( "click", _ => {
    
    document.body.style.backgroundColor = "pink";
    
    for ( let i = 0; i < 100000000; i++ ) new Date();
    
} );
```

如果页面没有立即响应用户的操作，用户就会感觉到卡顿。因为所有的重排和重绘都会受到主线程的阻塞，所以如果主线程上的任务非常耗时，那么在主线程努力处理任务的期间，页面上所有依赖重排和重绘的交互设计都将变得无响应，整个页面看起来就像陷入了假死状态。

不过，哪怕整个页面都陷入了假死状态，页面仍然可以流畅的滚动，这是因为页面滚动是使用合成来实现的。

## 合成

合成是指浏览器只通过合成（第 8 步）来生成新的页面位图的行为，具体来说，合成器线程可以通过改变图块位图的状态（比如位置、旋转等）来让 GPU 直接合成出新的页面位图，由于这种渲染策略可以跳过大部分的渲染流程，并且合成器线程还可以和主线程并行工作，因此这种渲染策略可以很快的渲染出新的页面位图。

许多 CSS3 动画和页面滚动都是使用合成来实现的，由于合成可以不受主线程的阻塞，所以在页面假死期间，页面仍然可以流畅的滚动。

不过在最开始的时候，使用合成来实现的页面滚动也还是会被主线程阻塞，直至 Chrome 51 开始，Chrome 才利用 [Passive event listeners](https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md) 特性解决了这个问题。

## 合成阻塞

许多输入事件都具有默认动作，比如

1. 复选框的点击事件的默认动作是勾选和取消勾选。
2. 超链接标签的点击事件的默认动作是修改字体颜色和跳转。
3. 鼠标滚轮的滚动事件的默认动作是滚动页面或元素。
4. 触控板的垂直滑动事件的默认动作是滚动页面或元素。
5. ......

> 诸如点击鼠标、键入文本、触摸屏幕、滚动滚轮等行为都属于输入事件，对浏览器而言，输入事件的含义是用户与浏览器的交互行为，而不是通俗理解的“输入某些内容”。

上述的默认动作都会修改元素或页面的样式，其中 1 和 2 是通过重绘来实现的，3 和 4 是通过合成来实现的。重绘是会被主线程阻塞的，而合成是可以不被主线程阻塞的，因为合成是由独立于主线程之外的另一条合成器线程来完成的。不过由于 `event.preventDefault()`，导致这类合成仍会被主线程阻塞。

具体来说，对于使用鼠标和触控板的设备，页面滚动和元素滚动是 `wheel` 事件的默认动作，对于使用触摸屏的设备，则是触摸事件的默认动作，触摸事件是指 `touchstart`、`touchmove`、`touchend` 事件。如果这些输入事件的事件监听器执行了 `event.preventDefault()`，那么页面滚动和元素滚动的默认动作就会被取消，由于页面和元素不会发生滚动，所以合成器线程就无需合成滚动后的页面位图，否则合成器线程就需要合成滚动后的页面位图来响应用户的操作。

因为事件监听器可以通过调用 `event.preventDefault()` 来取消默认动作，且合成器线程又无法提前得知默认动作是否会被取消，因此这时候合成器线程才会等待主线程处理完事件监听器之后再工作。不过，在实践中，合成器线程不仅仅只是被事件监听器阻塞，而是会被主线程阻塞，主线程上可能还会运行其他任务。

> 注意，上文所说的“合成器线程不仅仅只是被事件监听器阻塞，而是会被主线程阻塞”不代表所有情况下的合成器线程的行为，只代表由默认动作所引发的合成行为这一种情况。

```css
body {
    height: 300vh;
    background-image: linear-gradient( red, blue );
}
```

```js
globalThis.addEventListener( "wheel", _ => {}, { passive: false } );
globalThis.addEventListener( "click", _ => {
    
    document.body.style.backgroundImage = "none";
    
    for ( let i = 0; i < 100000000; i++ ) new Date(); // 非常耗时的任务
    
} );
```

新建一个空白的页面，试试使用上述的代码，点击页面后立即使用触控板或滚轮来滚动页面，你会发现你根本就无法滚动页面，直至页面突变成白色之后，你才能重新滚动页面，再次点击页面就循环这个过程。之所以会出现这种情况，是因为页面滚动被主线程阻塞了，具体来说就是滑动滚轮或上下滑动触控板会触发一个默认动作，这个默认动作的影响就是滚动页面，滚动后的新页面位图是由合成器线程来合成的，而合成器线程会被主线程阻塞，刚好主线程要执行一个非常耗时的任务，在这期间合成器线程都无法合成出滚动后的页面位图来及时响应你的操作，于是你就体验到了页面的假死。

如果你对 JS 代码中的 `{ passive: false }` 感到困惑，请不用担心，因为文章的下一节（Passive event listeners）会阐述它的作用。不过可以提前告诉你，正是它引发了这个页面假死。

## Passive event listeners

[Passive event listeners](https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md) 是一项用于消除

该特性允许开发者自定义触摸事件和 `wheel` 事件的默认动作是否会被主线程阻塞，该特性从 Chrome 51 和 Firefox 49 开始生效。

该特性的作用是保障页面滚动的流畅性，因为页面滚动是触摸事件和 `wheel` 事件的默认动作，如果这些默认动作会被主线程阻塞，且主线程上的任务非常耗时，那么页面的滚动将会非常卡顿。你可以通过 [这个视频](https://www.youtube.com/watch?v=NPM6172J22g) 来了解这项特性对页面滚动的影响，很显然禁用了这项特性的页面的滚动非常卡顿，而启动了这项特性的页面的滚动则非常流畅。

这项特性的使用方法非常简单，我们在使用 `addEventListener` 来绑定事件监听器的时候，如果传入了 `{ passive: false }` 参数就可以禁用这项特性，如果传入了 `{ passive: true }` 就可以激活这项特性。

在了解 passive event listeners 的原理之前，我们需要先介绍一点前置知识。对于使用鼠标和触控板的设备，用户通过操纵滚轮和触控板来滚动页面，这时对应的是 `wheel` 事件。对于使用触控屏的设备，用户通过触摸屏幕来滚动页面，这时对应的是触摸事件，具体来说是 `touchstart`、`touchmove`、`touchend` 事件。如果我们在这些事件的监听器内部调用了 `event.preventDefault()`，那么页面将不会发生滚动，这是因为页面滚动是这些事件的默认动作，而该语句取消了页面的默认动作。

因为事件监听器可以通过 `event.preventDefault()` 来取消默认动作，而浏览器在执行完某个事件监听器之前，永远都不可能知道对应的默认动作是否被取消了，因此浏览器只能在执行完事件监听器之后再来处理默认动作，这就是默认动作会被事件监听器阻塞的原因。

如果开发者在绑定某个事件监听器的时候附带了 `{ prassive: true }` 参数，那么浏览器就会认为这个事件监听器不会调用 `event.preventDefault()`，哪怕事件监听器还是调用了 `event.preventDefault()`，浏览器也会忽略这条语句，并抛出一个警告以提醒开发者做了错误的操作。这样，默认动作就不会被它的事件监听器所阻塞了。

对于复选框和超链接标签，它们的默认动作都会改变它们的样式，而为了显示出新的样式，页面需要进行重绘。重绘的部分工作是由主线程来执行的，根据浏览器的事件循环，新页面只能在主线程清空完所有任务之后才能被渲染出来。因此，虽然复选框元素可以通过使用 `passive event listeners` 特性，来让它的默认动作不会被事件监听器阻塞，但是复选框的新样式还是只能在整个主线程清空掉所有任务之后才能渲染出来，这样看起来复选框就好像没有使用 `passive event listeners` 一样。

比如，假设页面中有一个复选框元素，为它绑定 `click` 类型的事件监听器并传入 `{ passive: true }` 参数，尝试点击复选框，我们会发现复选框的样式总是在控制台输出 `"done"` 之后才发生改变。在点击复选框之后和复选框样式发生改变之前，页面都会进入假死状态，这是因为主线程要执行复选框的事件监听器，而这个事件监听器执行了一个非常耗时的任务，导致了阻塞主线程。

```js
document.querySelector( "input" ).addEventListener( "click", _ => {
    
    for ( let i = 0; i < 10000000; i++ ) new Date();
    
    console.log( "done" );
    
}, { passive: true } );
```

滚动页面后，页面的新位图是由合成器线程来合成的，因为

## 输入事件

对浏览器而言，诸如点击鼠标、键入文本、触摸屏幕、滚动滚轮等行为都属于输入事件，输入事件的真正定义是用户与浏览器的交互行为，而不是通俗理解的“输入”。

## 事件监听器与默认动作

当浏览器接收到输入事件后，它就会调用相应的事件监听器。另外，有些输入事件还会触发某些默认动作，比如复选框的默认动作是勾选和取消勾选、超链接标签的默认动作是更改字体颜色和跳转、滚轮的默认动作是滚动页面等等。

通常，如果事件监听器或默认动作修改了页面的样式，那么浏览器就会在渲染进程的主线程处理完所有任务之后再渲染出新的画面。如果主线程上的任务非常耗时，

根据浏览器的事件循环，如果运行在主线程上的任务修改了页面的样式，浏览器并不会立即渲染出新的页面位图，而是必须在主线程执行完所有任务之后才会渲染出新的页面位图。如果主线程上的任务非常耗时，

因为事件监听器是由主线程来执行的，因此如果事件监听器修改了页面的样式，那么只有在主线程执行完所有任务之后才会渲染出新的页面位图。

事件监听器和默认动作都可以修改页面的样式，

滚轮的默认动作是滚动页面等等。

在大多数情况下，默认动作是由渲染进程的主线程来执行的，并且主线程只有在执行完其余的任务后才会执行默认动作，因此默认动作的触发时机是在所有事件监听器之后。

如果输入事件既绑定了事件监听器，又会触发默认动作的话，那么浏览器就会在执行完事件监听器之后再执行默认动作。

事件监听器和默认动作都具有修改页面样式的能力，如果事件监听器修改了页面的样式，那么新的页面只有在事件监听器执行结束之后才会被渲染出来，如果事件监听器执行了一个非常耗时的任务，那么在新旧页面之间就会出现一个明显的页面假死，在页面假死期间，用户无法与页面进行任何交互。

```js
globalThis.
```



## 处理输入事件

当用户与浏览器发生了交互之后，浏览器会捕捉到这个交互的输入事件，然后将该事件的类型（如 `click`）和坐标（如 `(x,y)`）发送给渲染进程。

渲染进程的合成器线程会首先接收到这则信息，然后合成器线程会根据输入事件的发生地点来判断这个输入事件是否会触发事件监听器。

如果合成器线程判断出这个输入事件不会触发任何事件监听器，那么合成器就会直接生产新的帧画面（具体是指新的页面的位图，下同）。

如果合成器判断出这个输入事件会触发事件监听器，那么合成器线程就会将这则消息发送给主线程，由主线程来找到并调用相应的事件监听器。有时候，合成器线程会等待主线程处理完所有的事件监听器之后再工作。有时候，合成器线程不会等待主线程，而是在将输入事件的消息发送给主线程之后，就立即开始自己的工作。

![输入事件的信息](/static/image/markdown/browser/deal-with-input-event/input-event-information.png)

## Non-Fast Scrollable Region

为什么合成器线程可以根据输入事件的发生地来判断输入事件是否会触发事件监听器呢？本节将会解答这个问题。

合成器线程会将绑定了事件监听器的区域标记为 non-fast scrollable region，如果输入事件发生在标记区域的范围内，合成器线程就会将输入事件的信息发送给主线程，否则就不会。

![non-fast-scrollable-region](/static/image/markdown/browser/deal-with-input-event/non-fast-scrollable-region.png)

我们经常会使用事件代理来为元素绑定事件监听器，它的具体原理是：将事件监听器绑定在祖先节点的身上，然后通过判断输入事件究竟发生在哪个子孙节点的身上来决定应该执行哪些任务。

不过，事件代理会扩大 non-fast scrollable region 的范围，比如，如果将事件监听器绑定在了 `globalThis` 节点上，那么整个页面都将会被标记为 non-fast scrollable region。这样一来，如果无论输入事件发生在页面的哪个位置，合成器线程都必须与主线程通信，哪怕输入事件根本没有触发任何事件监听器。而且，如果主线程还会阻塞合成器线程的话，那么一旦事件监听器的执行时间较长，原本流畅的页面动画就会变得卡顿。

![使用事件代理将可能扩大non-fast scrollable region的区域](/static/image/markdown/browser/deal-with-input-event/event-delegation.png)

## 主线程阻塞合成器线程

如果合成器线程发现输入事件发生在 non-fast scrollable region，那么合成器线程就会将输入事件的信息发送给主线程，由主线程来找到并调用相应的事件监听器。有时候，合成器线程会等待主线程处理完所有的事件监听器之后再工作。有时候，合成器线程不会等待主线程，而是在将输入事件的消息发送给主线程之后，就立即开始自己的工作。

合成器线程之所以会被主线程阻塞，是因为事件监听器有影响页面渲染的能力

# TODO

记录参考文献

给主页使用 wheel 和 touch start 的禁止滚动事件。
