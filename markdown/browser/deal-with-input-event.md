---
typora-root-url: ..\..
---

# 如何处理输入事件

## 概述

对浏览器而言，诸如点击鼠标、键入文本、触摸屏幕、滚动滚轮等行为都属于输入事件，输入事件的真正定义是用户与浏览器的交互行为，而不是通俗理解的“输入”。

我们在屏幕上所看到的浏览器的画面其实是一幅位图，当浏览器接收到来自用户的输入事件后，它就会迅速的更新这幅位图，于是用户便产生了“浏览器响应了我的操作”这种错觉。比如，当用户滚动页面时，浏览器就会频繁的根据页面滚动后的新位置来生成新的页面位图，并替换掉旧的页面位图。当这个更新的频率足够高且时间间隔均匀时，用户就会感觉到画面的动画很流畅，反之则会感觉到画面的动画很卡顿，所以卡顿（jank）的本质是延迟，即更新不够及时。

> 我不确定浏览器的画面到底是一幅完整的位图，还是由多幅位图拼接而成的拼图，因为 Chrome Blog 提到过浏览器 UI 的位图和选项卡页面的位图是分开生成的，不过哪怕不知道这个问题的答案，也不会影响我们理解这篇文章，所以暂勿纠结。

本文将会介绍浏览器在接收到输入事件后，是如何处理这些输入事件并快速的生成新的页面位图的。

## 页面的渲染

Chrome 渲染页面的流程有 8 个步骤：

1. 构建 DOM
2. 计算样式
3. 计算布局
4. 创建绘图指令
5. 分层
6. 分块
7. 光栅化
8. 合成

## 重排和重绘

重排是 reflow 的汉译，重绘是 repaint 的汉译，重排也被称为回流。当页面发生了重排或重绘后，浏览器就会再次执行上述的渲染流程来更新页面，不过浏览器不一定会重新执行整个渲染流程，因为浏览器有时候只需要执行其中的部分步骤，就足以更新页面了。

如果页面重新排版了自己的布局，那么我们就认为页面发生了重排。当页面发生了重排之后，浏览器就会按需的执行渲染流程中的某些步骤来更新页面，而浏览器到底需要执行哪些步骤则取决于引发重排的具体行为，比如：

- 如果浏览器窗口收窄了，页面就需要进行收缩，此时，浏览器只需要从第 2 步开始来执行渲染流程就可以渲染出收缩后的页面了，因为此时没有修改 DOM，所以不必再重新构建 DOM（第 1 步），不过样式计算（第 2 步）及其后续步骤显然都是必须的，因为遵循响应式布局的页面的元素都必不可少的会依赖 viewport 的尺寸。
- 如果增加、删除、移动了 DOM 中的节点，那么就需要重新执行完整的渲染流程，因为这改变了 DOM 的结构，而后续的所有步骤都是直接或间接的依赖 DOM 的。
- 如果修改了元素的尺寸，那么就需要从第 2 步开始来执行渲染流程，因为这个元素的样式发生了变化，并且其他元素的样式也可能会受其影响而发生变化。

如果元素只是更新了自己的背景颜色、背景样式等东西时，我们就认为页面发生了重绘，重绘所需执行的渲染流程的步骤更少一些，只需要重新计算样式、计算布局、创建绘图指令、光栅化、合成就够了。

## 合成器线程

合成器线程可以通过改变图块位图的状态（比如位置、旋转等）来让 GPU 直接合成出新的页面位图，浏览器会采用这种渲染策略来渲染某些页面动画，比如 `translate` 和页面滚动等，这样做的好处是可以更快的渲染出帧画面的位图，因为这种渲染策略跳过了绝大部分的渲染流程的步骤，可以节省很多的工作量，并且合成器线程还可以和主线程并行工作，这又进一步提升了页面渲染的速度。

善用这类只需要调用合成器线程的动画有利于制作出更流畅的页面。

不过，合成器线程并不总是可以和主线程并行工作，有的时候，合成器线程必须等待主线程完成任务之后才能开始工作，这其中的原理就需要涉及到浏览器是如何处理输入事件的。

## 处理输入事件

当用户与浏览器发生了交互之后，浏览器会捕捉到这个交互的输入事件，然后将该事件的类型（如 `click`）和坐标（如 `(x,y)`）发送给渲染进程。

渲染进程的合成器线程会首先接收到这则信息，然后合成器线程会根据输入事件的发生地来判断这个输入事件是否会触发事件监听器。

如果合成器线程判断出这个输入事件不会触发任何事件监听器，那么合成器就会直接生产新的帧画面（具体是指新的页面的位图，下同）。

如果合成器判断出这个输入事件会触发事件监听器，那么合成器线程就会将这则消息发送给主线程，由主线程来找到并调用相应的事件监听器。有时候，合成器线程会等待主线程完成任务之后再生成新的帧画面，有时候，合成器线程在将消息发送给主线程之后，就会立即开始生成新的帧画面，而不会等待主线程。

![输入事件的信息](/static/image/markdown/browser/deal-with-input-event/input-event-information.png)

## Non-Fast Scrollable Region

为什么合成器线程可以根据输入事件的发生地来判断输入事件是否会触发事件监听器呢？本节将会解答这个问题。

合成器线程会将绑定了事件监听器的区域标记为 non-fast scrollable region，如果输入事件发生在标记区域的范围内，合成器线程就会将输入事件的信息发送给主线程，否则就不会。

![non-fast-scrollable-region](/static/image/markdown/browser/deal-with-input-event/non-fast-scrollable-region.png)

我们经常会使用事件代理来为元素绑定事件监听器，它的具体原理是：将事件监听器绑定在祖先节点的身上，然后通过判断输入事件究竟发生在哪个子孙节点的身上来决定应该执行哪些任务。

不过，事件代理会扩大 non-fast scrollable region 的范围，比如，如果将事件监听器绑定在了 `globalThis` 节点上，那么整个页面都将会被标记为 non-fast scrollable region。这样一来，如果无论输入事件发生在页面的哪个位置，合成器线程都必须与主线程通信，哪怕输入事件根本没有触发任何事件监听器。而且，如果主线程还会阻塞合成器线程的话，那么一旦事件监听器的执行时间较长，原本流畅的页面动画就会变得卡顿。

![使用事件代理将可能扩大non-fast scrollable region的区域](/static/image/markdown/browser/deal-with-input-event/event-delegation.png)
