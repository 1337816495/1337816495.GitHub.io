---
typora-root-url: ..\..
---

# 重排、重绘、合成

## 渲染流程

首先，渲染流程是：

1. DOM：创建 DOM 树
2. Style：计算元素的样式
3. Layout：计算可见元素的样式与位置
4. Layer：创建页面的图层
5. Paint：创建图层的绘制指令列表
6. Tiles：将图层分割为图块
7. Raster：创建图层的位图
8. Display：合并图层位图并渲染页面

## 重排

如果你改变了元素的几何属性或位置属性（比如宽度、高度等），元素在页面中的位置就会发生变化，并且其它元素的位置也可能会受其影响而改变，因此渲染进程就需要重新执行 `Layout` 步骤来更新页面的布局信息，并且渲染流程中之后的步骤也都需要重新执行。

可见，重排几乎需要更新完整的渲染流水线（除了 `DOM` 步骤），故而重排的开销是最大的。

## 重绘

如果你改变了元素的绘制属性（比如背景颜色），那么渲染进程就需要重新执行 `Paint` 及其之后的步骤。因为这种改变不会修改页面的布局和分层，因此渲染进程就跳过了 `Layout` 和 `Layer` 步骤。

可见重绘带来的计算负荷比重排的要小。

## 合成

如果你修改的是诸如 `translate` 之类的 CSS3 动画属性，那么渲染进程就只需要执行 `Tiles` 及其之后的步骤就好了。

比如，对于一个启用了 `translate` 属性的元素而言，它拥有自己的专属图层，改变它的 `translate` 属性不会影响页面的分层状况。并且，`Paint` 阶段输出的绘制指令列表是以图层为单位的，由于该元素的外观根本没有发生改变，因此也不需要更新绘制指令列表，自然也可以跳过 `Paint` 阶段。最后，改变了 `translate` 属性后，由于元素的位置发生了变化，理应是要更新页面的布局信息的，不过渲染进程似乎是通过在 `Display` 阶段偏移该元素图层的位置来实现使其位移的，因此也可以跳过 `Layout` 阶段。

由于“合成”所需的计算负荷更小，并且其还是在非主线程中完成的，因此“合成”的的计算负荷比起前两者的要小得多。

> 另外，许多现代浏览器是使用合成线程来处理内容滚动的，这是因为浏览器将滚动的内容做成了一个单独的图层，在发生滚动时只需要在 `Display` 阶段改变该图层的位置偏移量即可。