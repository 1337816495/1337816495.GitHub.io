# 执行上下文与调用栈

JavaScript 是一门即时编译即时执行的语言，JavaScript 代码需要经由引擎编译成字节码之后才能执行，另外 JIT

之后才能执行。为了尽快的执行代码，引擎不会在编译完所有代码之后才执行代码

# 作用域链与闭包



## 概述

todo

## 变量提升

变量提升是在编译阶段实现的。

var 和 function 的变量提升没有优先级，谁在文本中的位置更前，谁就先被提升。

要区分创建、初始化、赋值这 3 种行为：

- var 的创建和初始化被提升，赋值不会被提升
- let 的创建被提升，初始化和赋值不会被提升
- function 的创建、初始化和赋值均会被提升

事实上，在编译阶段，由 const 和 let 声明的变量就已经存在在内存中了，并且值都是 undefined（你可以通过 scoped 来查看），不过是 V8 引擎主动禁止了在 const 和 let 的语句之前访问他们（即 uninitialized 阶段），因为这是 ECMAScript 的规定，ECMAScript 这么规定的原因是：const 的常量不应该有两个状态。

## 执行上下文和调用栈

JavaScript 是一门先编译再执行的语言，具体来说 JavaScript 引擎会先编译 JavaScript 代码，然后再执行编译后的产物。其中的产物之一就是执行上下文，在下述三种情况下，JavaScript 引擎都会编译代码并生成执行上下文：

- 当执行全局代码的时候，引擎会编译全局代码并生成一个全局执行上下文，该执行上下文只有一份，并且会伴随页面的整个生命周期。
- 当执行一个函数的时候，引擎会编译函数体内的代码并生成一个函数执行上下文，当函数执行结束之后，该上下文就会被销毁。如果存在闭包，则会保留需要保留的部分。
- 当执行 `eval` 函数的时候，引擎会编译 `eval` 函数的并生成一个函数执行上下文。

> 我认为块级作用域的代码也会被编译，因为通过浏览器的开发者工具的 Scoped 可以观察到，在执行步骤进入到 `{}` 之前，Scoped 完全不知道当前函数有哪些 let 或 const 变量，但是一旦执行步骤进入到 {} 之后，Scoped 就知道了这个块内的所有的 let 和 const 的变量，并且初始化为 undefined。

调用栈是一个栈数据结构，它的每个栈帧就是一个执行上下文，所以调用栈也被称为执行上下文栈。调用栈的作用是管理执行上下文，而执行上下文是全局代码或函数编译后的产物，所以调用栈是用来管理 JavaScript 代码的执行的。因为我们会在全局代码中调用其他函数，在函数内继续调用其他函数，所以这就形成了一个深层嵌套的结构，所以引擎选择使用栈这种数据结构来管理这些函数的调用。简单来说，引擎使用调用栈来追踪函数的执行，调用栈可以表示出那个函数正在执行，以及函数之间的嵌套关系。

执行上下文包含 3 件东西：变量环境、词法环境、this，其中 outer 是在变量环境内部的。

箭头函数不会创建自身的执行上下文。WTF？？？？这个要查一下，因为李兵又在评论区说箭头函数会创建变量环境等吧啦吧啦的，我寻思箭头函数在执行之前肯定要编译吧，编译之后的产物如果不是执行上下文那么又是什么呢？

## 作用域、链、闭包

不要纠结闭包的定义，因为众说纷云，你只要知道闭包的原理就好了。

闭包只包含用到的变量，引擎会提前分析函数体内的变量，有引用的就不会被GC回收。

outer 也是在编译阶段确定的。

> 关于在块级作用域中声明函数：
>
> 这个问题我在前面回答过一次了，重新贴下： ES规定函数只不能在块级作用域中声明， function foo(){    if(true){        console.log('hello world');        function g(){ return true; }    } } 也就是说，上面这行代码执行会报错，但是个大浏览器都没有遵守这个标准。 接下来到了ES6了，ES6明确支持块级作用域，ES6规定块级作用域内部声明的函数，和通过let声明变量的行为类似。 规定的是理想的，但是还要照顾实现，要是完全按照let的方式来修订，会影响到以前老的代码，所以为了向下兼容，个大浏览器基本是按照下面的方式来实现的： function foo(){    if(true){        console.log('hello world');        var g = function(){return true;}     } } 这就解释了你的疑问，不过还是不建议在块级作用域中定义函数，很多时候，简单的才是最好的。

## this

如果被 settimeout 推迟执行的毁掉函数是某个对象的方法，那么这个方法中的 this 关键字将会指向全局环境（非严格模式下），这是要小心的一个地方。