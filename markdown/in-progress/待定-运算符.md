# 运算符

## 汇总表

参见 [MDN-运算符优先级-汇总表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#%E6%B1%87%E6%80%BB%E8%A1%A8)。

## 算术运算符

| 名称 | 运算符 | 名称       | 运算符 |
| ---- | ------ | ---------- | ------ |
| 加   | `+`    | 求幂       | `**`   |
| 减   | `-`    | 自增       | `++`   |
| 乘   | `*`    | 自减       | `--`   |
| 除   | `/`    | 一元正值符 | `+`    |
| 取余 | `%`    | 一元负值符 | `-`    |

算数运算符会对左右运算元进行算数运算，然后返回一个数字值，不是数字值的运算元会在运算开始前被隐式的转换为数字值（加法例外），下文是转换规则：

- 对于二元加法运算符，若左、右运算元都不是 `String` ，则非 `Number` 的运算元会被转换为 `Number`
- 对于二元加法运算符，若有至少一个运算元是 `String` ，则非 `String` 的运算元会被转换为  `String` 
- 对于其它算术运算符，所有非 `Number` 的运算元都会被转换为 `Number` 

### 求幂

以左运算元为底数，以右运算元为指数，返回它们的乘方。注意，该运算符的关联性是从右到左，因此 `2 ** 2 ** 3` 等价于 `2 ** (2 ** 3)`，不等价于 `(2 ** 2) ** 3` 。

### 自增 和 自减

对于前置自增，先令运算元自增 `1` ，再返回运算元的值。对于后置自增，先返回运算元的值，再令运算元自增 `1` 。自减运算符同理。

### 加法

对于二元加法运算符，若有至少一个运算元是 `String` ，则非 `String` 的运算元会被隐式转换为 `String` ，然后再进行字符串的连接，最后返回连接的结果。

##  赋值运算符

| 名称       | 运算符 | 描述                            | 返回值             |
| ---------- | ------ | ------------------------------- | ------------------ |
| 普通赋值   | `=`    | 将右运算元的值分配给左运算元    | 右运算元的值       |
| 加赋值     | `+=`   | `a += b`   等价于 `a = a + b`   | `a + b`   的返回值 |
| 减赋值     | `-=`   | `a -= b`   等价于 `a = a - b`   | `a - b`   的返回值 |
| 乘赋值     | `*=*`  | `a *= b`   等价于 `a = a * b`   | `a * b`   的返回值 |
| 除赋值     | `/=`   | `a /= b`   等价于 `a = a / b`   | `a / b`   的返回值 |
| 取余赋值   | `%=`   | `a %= b`   等价于 `a = a % b`   | `a % b`   的返回值 |
| 求幂赋值   | `**=`  | `a **= b` 等价于 `a = a ** b`   | `a ** b` 的返回值  |
| 逻辑与赋值 | `&&=`  | `a &&= b` 等价于 `a && (a = b)` | `a` 最终的值       |
| 逻辑或赋值 | `||=`  | `a ||= b` 等价于 `a || (a = b)` | `a` 最终的值       |
| 逻辑空赋值 | `??=`  | `a ??= b` 等价于 `a ?? (a = b)` | `a` 最终的值       |

[MDN-运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence) 明确表示：“赋值运算符的返回结果就是赋值运算符右边的那个值”。通过下述例子亦可佐证该观点：

```js
let a, b;

( a = b ) = 1; // Error: Uncaught SyntaxError: Invalid left-hand side in assignment
```

因为 `a = b` 的返回值是变量 `b` 的值而不是变量 `b`，所以才会抛出 `Invalid left-hand`。

逻辑与赋值的定义是：若左运算元为 `truthy`，则将右运算元的值赋予左运算元，否则不进行赋值操作。因为逻辑与赋值具有短路计算的特性，因此 `a &&= b` 才会等价于 `a && ( a = b )` ，而不是 `a = a && b`，因为前者才符合短路计算的特性。对于逻辑或赋值、逻辑空赋值也是同理的。

## 逻辑运算符

| 名称   | 运算符 | 语法     | 描述                                                         |
| ------ | ------ | -------- | ------------------------------------------------------------ |
| 逻辑与 | `&&`   | `a && b` | 若 `a` 的布尔值为 `true`   ，则返回 `b` 的初始值；<br />若 `a` 的布尔值为 `false` ，则返回 `a` 的初始值，忽略 `b`； |
| 逻辑或 | `||`   | `a || b` | 若 `a` 的布尔值为 `true`   ，则返回 `a` 的初始值，忽略 `b` ；<br />若 `a` 的布尔值为 `false` ，则返回 `b` 的初始值； |
| 逻辑非 | `!`    | `!a`     | 若 `a` 的布尔值为 `true`   ，则返回 `false` ；<br />否则返回 `true` ； |
| 逻辑空 | `??`   | `a ?? b` | 若 `a` 的初始值为 `null` 或 `undefined` ，则返回 `b` 的初始值；<br />否则返回 `a` 的初始值，忽略 `b` ； |

注意，`a` 和 `b` 是变量或表达式，变量的初始值就是变量的值，表达式的初始值就是表达式的计算结果。

### 逻辑或

从左向右逐个检查运算元，然后返回首个 `truthy` 运算元的初始值，并忽略剩余的运算元。若一直没有找到 `truthy` 运算元，则返回最后那个运算元的初始值。比如对于 `a && b && c` ，JavaScript 引擎会这么做：

1. 从左向右逐个检查运算元；
2. 若当前运算元的初始值的数据类型不是布尔类型，则将其隐式转换为布尔类型；
3. 若当前运算元的布尔值为 `true`   ，则立即返回当前运算元的初始值，并忽略剩余的运算元；
4. 若所有运算元的布尔值为 `false` ，则返回最后那个运算元的初始值；

### 逻辑与

从左向右逐个检查运算元，返回首个 `falsy` 运算元的初始值，并忽略剩余的运算元。若一直没有找到 `falsy` 运算元，则返回最后那个运算元的初始值。

### 短路计算

`&&` 、 `||` 、 `??` 具有能够忽略运算元的特性， “运算元被忽略” 是指该运算元没有被执行，因此被忽略的运算元中的错误、副作用、函数调用等都不会被触发。这种忽略运算元的行为被称为短路计算。短路计算常用于简化判断语句，但它也会降低代码的可读性。

```js
if ( 1 > 0 ) console.log( true );
/* equal to */
1 > 0 && console.log( true );
```

## 一元运算符

| 名称     | 运算符   | 语法                       | 描述 |
| -------- | -------- | -------------------------- | ---- |
| 一元加法 | `+`      | `+a`                       |      |
| 一元减法 | `-`      | `-a`                       |      |
| 逻辑非   | `!`      | `!a`                       |      |
| 按位非   | `~`      |                            |      |
| void     | `void`   | `void a`     或 `void (a)` |      |
| typeof   | `typeof` | `typeof a` 或 `typeof (a)` |      |
| delete   | `delete` | `delete a`                 |      |

### void

执行右运算元，然后返回 `undefined`，它的语法是：

```js
void expression;
void ( expression );
```

使用 `void` 来构造的 IIFE 会稍微安全一些，因为它的返回值总是 `undefined`：

```js
void function iife(){}();
```

`void` 还能用来构造无响应的超链接标签，比如：

```html
<a href="javascript: void 0;"></a>
<a href="javascript: void(0);"></a>
```

### typeof

返回一个表示右运算元的数据类型的字符串，它的语法是：

```js
typeof a;
typeof ( a );
```

| 数据类型                               | 返回值             |
| -------------------------------------- | ------------------ |
| `Undefined`                            | `'undefined'`      |
| `Null`                                 | `'object'`         |
| `Boolean`                              | `'boolean'`        |
| `Number`                               | `'number'`         |
| `Bigint`                               | `'bigint'`         |
| `String`                               | `'string'`         |
| `Symbol`                               | `'symbol'`         |
| `Function`                             | `'function'`       |
| 宿主对象（如 `window` 、 `document` ） | 取决于浏览器的实现 |
| 其它对象                               | `'object'`         |
| 未声明的变量                           | `'undefined'`      |

TODO

TODO

TODO

TODO

TODO

TODO

TODO

TODO

TODO

TODO

TODO

TODO

TODO

TODO

TODO

**历史错误 `typeof null` **：

`typeof null` 的返回值是 `'object'` ，这是一个历史遗留错误。

**侵犯标准的宿主对象：**

```js
typeof document.all; // 'undefined'
```

​		ECMAScript 规范外的对象可以自定义自己的 `typeof` 的返回值，但显然 `document.all` 对自己的 `typeof ` 定义并不合理，这被视为是对 ECMAScript 规范的侵犯，目前该接口已被废弃，但部分浏览器仍支持它。



### delete

​		删除对象自身的指定属性，但不会删除对象原型链上的同名属性。

**语法：**

```js
delete obj.prop;
```

```js
delete obj[expr];
```

**返回值：**

- `false` ：非严格模式下，`delete` 不可配置的属性会返回 `false` ，且操作无效（严格模式下，则会抛出错误）；
- `true` ：其余情况都返回 `true` ；

**陷阱 1 ： `delete` 不存在的属性**

​		`delete` 不存在的属性会返回 `true` ，且被 `delete` 属性的对象没有任何变化。

```js
delete {}.a; // true
```

**陷阱 2 ： `delete` 由 `var` 、 `let` 、 `const` 、 `function` 声明的变量：**

​		任何作用域内，由声明关键字声明的变量是某个对象的不可配置的属性，由赋值来创建的变量是某个对象的可配置的属性。以 `var` 为例，`let` 、 `const` 、 `function` 同理（MDN说的）。

```js
a = 1;
var b = 2;

Object.getOwnPropertyDescriptor(window, "a").configurable; // true
Object.getOwnPropertyDescriptor(window, "b").configurable; // false
```

​		`delete` 不可配置的属性就会返回 `false` ，或抛出错误。

```js
// 全局作用域
var global_a = 1;

let global_b = 2;

const global_c = 3;

function global_f() {};

delete global_a; // false
delete global_b; // false
delete global_c; // false
delete global_f; // false

// 函数作用域
void (function (){
    
    var a = 1;
    
    let b = 2;
    
    const c = 3;
    
    function f() {};
    
    delete a; // false
	delete b; // false
	delete c; // false
	delete f; // false
    
}())
```

**陷阱 3 ： `delete` 数组元素：**

​		`delete` 一个数组的元素，就会清空这个元素的内容，但不会释放掉这个元素所占据的内存空间，所以被 `delete` 掉的元素的值为 `undefined` ，意义为 empty 。数组的长度不会改变，其它元素的下标不会重排。

```js
const array = [1, 2, 3];

delete array[0];

array;    // [empty, 2, 3]
array[0]; // undefined
```



## 三元运算符

​		又被称为条件运算符。

**语法：**

```js
condition ? expr_1 : expr_2;
```

- 若 `condition` 的布尔值是 `true` ，则执行 `expr_1` ，忽略 `expr_2` ，最后返回 `expr_1` 的初始值；
- 否则，忽略 `expr_1` ， 执行 `expr_2` ，最后返回 `expr_2` 的初始值；



## ⏳ 比较运算符

> ⏳：《部分转换规则》和《部分比较规则》不齐全，需要继续补充。

​		严格比较运算符会直接比较左、右运算元的数据类型和值。其它的比较运算符会将左、右运算元隐式转换为同一种数据类型，再比较它们的值。

| 名称     | 运算符 | 名称       | 运算符 | 名称 | 运算符 | 名称       | 运算符 |
| -------- | ------ | ---------- | ------ | ---- | ------ | ---------- | ------ |
| 严格相等 | `===`  | 严格不相等 | `!==`  | 大于 | `>`    | 大于或等于 | `>=`   |
| 宽松相等 | `==`   | 宽松不相等 | `!=`   | 小于 | `<`    | 小于或等于 | `<=`   |

**部分转换规则：**

- 若两个运算元分别是 `Number` 和 `String` ，则 `String` 会被转换为 `Number`；
- 若两个运算元分别是 `Number` 和 `Boolean` ，则 `Boolean` 会被转换为 `Number` ；

**部分比较规则：**

- 若两个运算元都是 `Object` ，则当它们都指向同一个对象时，认为它们宽松相等和严格相等，否则认为它们宽松不相等和严格不相等；
- `NaN` 不与任何值（包括它自己）宽松相等或严格相等；
- `+0` 和 `-0` 严格相等；



## 逗号运算符

**语法：**

​		从左向右的逐个执行运算元，最后返回最后那个运算元的执行结果。

```
expr_1, expr_2, ..., expr_n;
```

**示例：**

```js
const exprA = _ => 1;
const exprB = _ => 2;

(exprA(), exprB()); // 2
```

**陷阱：**

​		声明语句中的逗号不是逗号运算符，表达式中的逗号才是逗号运算符。



## 可选链运算符

​		若左运算元为 `null` 或 `undefined` ，则返回 `undefined` ，并忽略右运算元，否则执行右运算元（通常是属性访问或函数调用）。

**语法：**

```js
obj?.property;
```

```js
obj?.[expression];
```

```js
array?.[index];
```

```
function?.();
```

示例：

```js
const obj = {f: _ => 1};

obj.f?.(); // 1
obj.a?.(); // undefined
```



## in 运算符

​		若该属性存在于该对象或该对象的原型链上，则返回 `true` ，否则返回 `false` 。

**语法：**

```js
prop in obj;
```

-  `prop` ： `String` 或 `Symbol` ，代表属性名或数组索引，其它数据类型的值都会被隐式转换为 `String` 
-  `obj`   ： `Object`

**示例：**

```js
'toString' in {}; // true
```

```js
0 in [1, 2, 3];   // true
```



## instanceof 运算符

​		若对象 A 的 `prototype` 属性存在于对象 B 的原型链上，则返回 `true` ，否则返回 `false` 。

**语法：**

```js
obj_b instanceof obj_a;
```

**示例：**

```js
const A = function() {};
const a = new A();

a instanceof A;      // true
a instanceof Object; // true
```



## 位运算符

> ​		这类运算符在实际开发中很少被用到，因此暂时忽略它们，如果你更感兴趣，可以从这里开始学习 🔗https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators

| 名称     | 运算符 | 名称       | 运算符 |
| -------- | ------ | ---------- | ------ |
| 按位与   | `&`    | 左移       | `<<`   |
| 按位或   | `|`    | 右移       | `>>`   |
| 按位异或 | `^`    | 无符号右移 | `>>>`  |
| 按位非   | `~`    |            |        |

