---
typora-root-url: ..\..
---

# 散列表

## 概述

散列表（Hash table）又称为哈希表，它是指基于散列函数（Hash function）来实现的字典，其实现的大致原理是通过散列函数来将属性键转化为一个唯一的存储地址，然后属性将值存储在这个地址上。

得益于这种实现机制，我们可以直接根据属性键和散列函数来计算出属性值的存储地址，然后一步到位的访问到属性值，所以散列表的访问操作的时间复杂度是 `O(1)`，这正是散列表的优点。

不过有的时候，散列函数也会将多个属性键映射至同一个存储地址，这种现象被称为散列冲突（Collision），后文会详细解释它的成因与解决方案。

## 原理

### 散列表的原理

散列表的原理是通过散列函数来将属性键转化为一个唯一的标识符，然后使用这个标识符来作为属性值存储在另一个数据结构中的地址。当我们需要访问数据时，我们就可以直接根据属性键和散列函数来计算出属性值在存储容器中的地址，然后再从存储容器中获取属性值。

> 散列函数的计算结果被称为散列码（Hash code）。

比如，当我们使用数组来作为散列表的存储容器时，散列函数的作用就是将属性的键转化为一个唯一的数组索引，然后我们就会将这个数组索引作为属性值在数组中的存储地址，并将属性值存储在这个地址上。

如下图所示，这是一个使用 JavaScript 来实现的散列表，它使用了数组来作为存储容器。该散列表拥有 3 个属性，这 3 个属性的键分别是字符串 `a`、`b`、`c`，这 3 个属性的值分别是数字值 `100`、`200`、`300`，散列函数将这 3 个键转化为数字值 `5`、`1`、`9`，然后散列表将这 3 个属性的值分别存储在存储容器的 5 号位置、1 号位置、9 号位置上。

![散列表的原理](/static/image/markdown/data-structure/hash-table/hash-table-principle.png)

> 因为 JavaScript 数组具有自动扩容的特性，所以当我们使用 JavaScript 数组来作为散列表的存储容器时，我们可以轻松的向散列表追加任意数量的属性，而不需要担心存储容器的存储空间不足的问题。而如果我们使用 C++ 数组来作为散列表的存储容器，那么我们就需要在存储容器的容量告急时进行手动扩容，因为 C++ 数组没有实现自动扩容。你可以通过本博客的另一篇文章《V8 Object》来了解 JavaScript 数组的实现原理。

### 散列冲突的原理

散列冲突是指散列函数将多个属性键都映射至了同一个存储地址的现象。散列冲突会导致发生冲突的属性们将它们的属性值都存储在同一个地址上，这会导致散列表丢失数据，因为后定义的属性将会覆盖先定义的属性。如下图所示，因为追加属性的散列码与既有属性的散列码是一样的，所以追加属性的值覆盖了既有属性的值，这导致散列表丢失了既有属性的值。

![散列冲突的原理](/static/image/markdown/data-structure/hash-table/hash-collision.png)

之所以会发生散列冲突，是因为属性键的种类数是无穷的，而存储地址的数量却是有限的，如果散列函数要将无穷个属性键都映射至有限的存储地址上，那么就必然会出现多个属性键对应一个存储地址的现象。具体来说，我们通常会使用字符串来作为属性的键，因为字符串的种类有无数种，所以属性键的种类数也是无穷的，不过由于机器的存储空间是有限的，所以存储地址的数量是有限的。

散列冲突的解决方案有：

- 分离链接
- 线性探查
- 双散列法

本文会介绍与实现前两种方案。

### 分离链接的原理

分离链接的思路是将散列表的存储容器的存储单元都改造成链表，这个链表可以同时存储多个键值对，当有多个属性都要将值存储在同一个存储单元上的时候，存储单元就可以按照先后顺序来将属性的键值对追加到链表的尾部，这样就可以避免既有属性被追加属性所覆盖的问题了。

当我们需要查询属性时，我们需要先根据属性键和散列函数来找到对应的存储单元，然后再通过比对属性键的方式来在这个存储单元上找到目标属性的值。

当我们需要删除属性时，我们就直接把属性从存储它的链表上移除掉。如果移除节点后的链表的节点数为零，那么我们就把这个链表从存储它的数组上移除掉，这一步是可选的。

比如，当我们使用数组来作为散列表的存储容器时，我们可以这样改在这个存储容器，如下图所示。

![分离链接的原理](/static/image/markdown/data-structure/hash-table/separate-chaining.png)

### 线性探查的原理

线性探查的思路是将所有属性的键值对都直接存储在存储容器上，如果追加属性要使用的存储单元已经存储了另一个既有属性的话，那么就把这个追加属性写入到后续第一个空的存储单元上。

当我们需要查询属性时，我们需要先根据属性键和散列函数来找到对应的存储单元，然后通过比对属性键的方式来判断这个存储单元是否存储了目标属性的属性值，如果是，那么就取出这个存储单元上的属性值，如果不是，那么就开始遍历后续的每一个存储单元，直至找到那个存储了目标属性的属性值的存储单元，然后再从这个存储单元上取出属性值。

当我们需要删除属性时，我们需要先找到目标属性的存储单元，然后清空这个存储单元。清空的存储单元越多，存储容器的孔洞就越多，散列表的查询效率和空间利用率就越低，前者是因为散列表会浪费更多的时间在检查孔洞上。对于孔洞问题，我们有两种解决方案：

1. 每次清空存储单元之后，都将后续的有必要前移的存储单元向前移动。
2. 每次清空存储单元之后，都累计孔洞的数量，当孔洞的数量达到一定程度后，就整理一下存储容器。

> 存储容器的孔洞分为两种类型，一种是天生的孔洞，另一种是由于清空存储单元而产生的孔洞，上述第二个方案中提到的“累计孔洞的数量”是指“累计由于清空存储单元而产生的孔洞的数量”。
>
> 另外，你可以通过本文章的第一张图像来理解为什么存储容器会有天生的孔洞。

![线性探查的原理](/static/image/markdown/data-structure/hash-table/linear-probing.png)

## 参考文献

- [关于散列表的一些思考 - 掘金 (13/03/2019)](https://juejin.cn/post/6844903795495796744)
- [面试官：哈希表都不知道，你是怎么看懂HashMap的？ - 掘金 (25/09/2020)](https://juejin.cn/post/6876105622274703368)