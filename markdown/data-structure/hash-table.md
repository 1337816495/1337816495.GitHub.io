---
typora-root-url: ..\..
---

# 散列表

## 概述

散列表（Hash table）又称为哈希表，它是指基于散列函数（Hash function）来实现的字典，其实现的大致原理是通过散列函数来将属性键转化为一个唯一的存储地址，然后属性将值存储在这个地址上。

得益于这种实现机制，我们可以直接根据属性键和散列函数来计算出属性值的存储地址，然后一步到位的访问到属性值，所以散列表的访问操作的时间复杂度是 `O(1)`，这正是散列表的优点。

不过有的时候，散列函数也会将多个属性键映射至同一个存储地址，这种情况被称为散列冲突（Collision），后文会详细解释它的成因与解决方案。

## 原理

### 散列表的原理

散列表的原理是通过散列函数来将属性键转化为一个唯一的标识符，然后使用这个标识符来作为属性值存储在另一个数据结构中的地址。当我们需要访问数据时，我们就可以直接根据属性键和散列函数来计算出属性值在存储容器中的地址，然后再从存储容器中获取属性值。

> 散列函数的计算结果被称为散列码（Hash code）。

比如，当我们使用数组来作为散列表的存储容器时，散列函数的作用就是将属性的键转化为一个唯一的数组索引，然后我们就会将这个数组索引作为属性值在数组中的存储地址，并将属性值存储在这个地址上。

如下图所示，这是一个使用 JavaScript 来实现的散列表，其中它使用了数组来作为存储容器。因为 JavaScript 中的数组是变长的，所以我们可以不断的向散列表中添加属性，而不需要担心存储容器的存储空间不足的问题，因为 JavaScript 数组会在存储空间不足时自动扩容。

这是一个使用 JavaScript 数组来作为存储容器的散列表，因为 JavaScript 数组是变长的，所以数组的长度取决于散列码的极大值，另外，当我们需要向散列表添加更多的属性时，JavaScript 数组会自动扩容。

![散列表的原理](/static/image/markdown/data-structure/hash-table/hash-table-principle.png)

### 散列冲突的原理

散列冲突是指散列函数将多个属性键映射至了同一个存储地址，这会导致发生散列冲突的属性们将它们的属性值都存储在同一个地址上，这便意味散列表会发生数据丢失，因为后定义的属性将会覆盖先定义的属性。



有时候，散列函数会将多个属性键映射至同一个存储地址，这种情况被称为散列冲突。造成散列冲突的根本原因是散列函数无法将无穷的输入集映射至有穷的输出集。

具体来说，

具体来说，因为机器的存储空间是有限的，所以散列函数的输出集是有有穷的。

具体来说，当我们选用字符串来作为属性键时，虽然散列函数实际接收到的输入值的数量是有限的，但是散列函数在理论上可以接收到的输入值的种类数却是无穷的，所以散列函数的输入集是无穷的。然而，因为机器的存储空间是有限的，所以散列函数的输出集是有穷的。当







## 参考文献

- [关于散列表的一些思考 - 掘金 (13/03/2019)](https://juejin.cn/post/6844903795495796744)
- [面试官：哈希表都不知道，你是怎么看懂HashMap的？ - 掘金 (25/09/2020)](https://juejin.cn/post/6876105622274703368)