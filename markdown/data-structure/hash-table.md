---
typora-root-url: ..\..
---

# 散列表

## 概述

散列表（Hash table）又称为哈希表，它是指基于散列函数（Hash function）来实现的字典，其实现的大致原理是通过散列函数来将属性键转化为一个唯一的存储地址，然后属性将值存储在这个地址上。

得益于这种实现机制，我们可以直接根据属性键和散列函数来计算出属性值的存储地址，然后一步到位的访问到属性值，所以散列表的访问操作的时间复杂度是 `O(1)`，这正是散列表的优点。

有时候，散列函数会将多个属性键映射至同一个存储地址，这种情况被称为散列冲突（Collision），后文会解释它的成因与解决方案。

## 原理

散列表的原理是通过散列函数来将属性键转化为一个唯一的标识符，然后使用这个标识符来作为属性值存储在另一个数据结构中的地址。当我们需要访问数据时，我们就可以直接根据属性键和散列函数来计算出属性值在存储容器中的地址，然后再从存储容器中获取属性值。

> 散列函数的计算结果被称为散列码（Hash code）。

比如，当我们使用数组来作为散列表的存储容器时，散列函数的作用就是将属性的键转化为一个唯一的数组索引，然后我们就会将这个数组索引作为属性值在数组中的存储地址，并将属性值存储在这个地址上。

![散列表的原理](/static/image/markdown/data-structure/hash-table/hash-table-principle.png)

有时候，散列函数会将多个属性键映射至同一个存储地址，这种情况被称为散列冲突。散列冲突的成因有二，一是因为散列函数并不是完美的，它无法将

之所以会发生散列冲突，是因为散列函数的输入集是无穷的，而散列函数的输出集是有穷的，将无穷映射至有穷是必然会发生冲突的。

比如，当我们选用字符串来作为属性键时，由于字符串的种类数是无穷的，所以属性键的种类数也是无穷的，所以散列函数的输入集也是无穷的。由于存储空间是有限的，所以存储地址的数量也是有限的，所以









## 参考文献

- [关于散列表的一些思考 - 掘金 (13/03/2019)](https://juejin.cn/post/6844903795495796744)
- [面试官：哈希表都不知道，你是怎么看懂HashMap的？ - 掘金 (25/09/2020)](https://juejin.cn/post/6876105622274703368)