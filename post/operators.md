# 运算符

## 汇总

参见 [MDN-运算符优先级-汇总表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#%E6%B1%87%E6%80%BB%E8%A1%A8)。

## 算术运算符

| 名称 | 运算符 | 名称       | 运算符 |
| ---- | ------ | ---------- | ------ |
| 加   | `+`    | 求幂       | `**`   |
| 减   | `-`    | 自增       | `++`   |
| 乘   | `*`    | 自减       | `--`   |
| 除   | `/`    | 一元正值符 | `+`    |
| 取余 | `%`    | 一元负值符 | `-`    |

算数运算符会对左右运算元进行算数运算，然后返回一个数字值，不是数字值的运算元会在运算开始前被隐式的转换为数字值（加法例外），下文是转换规则：

- 对于二元加法运算符，若左、右运算元都不是 `String` ，则非 `Number` 的运算元会被转换为 `Number`
- 对于二元加法运算符，若有至少一个运算元是 `String` ，则非 `String` 的运算元会被转换为  `String` 
- 对于其它算术运算符，所有非 `Number` 的运算元都会被转换为 `Number` 

### 求幂

以左运算元为底数，以右运算元为指数，返回它们的乘方。注意，该运算符的关联性是从右到左，因此 `2 ** 2 ** 3` 等价于 `2 ** (2 ** 3)`，不等价于 `(2 ** 2) ** 3` 。

### 自增 和 自减

对于前置自增，先令运算元自增 `1` ，再返回运算元的值。对于后置自增，先返回运算元的值，再令运算元自增 `1` 。自减运算符同理。

### 加法

对于二元加法运算符，若有至少一个运算元是 `String` ，则非 `String` 的运算元会被隐式转换为 `String` ，然后再进行字符串的连接，最后返回连接的结果。

##  赋值运算符

| 名称       | 运算符 | 描述                            | 返回值             |
| ---------- | ------ | ------------------------------- | ------------------ |
| 普通赋值   | `=`    | 将右运算元的值分配给左运算元    | 右运算元的值       |
| 加赋值     | `+=`   | `a += b`   等价于 `a = a + b`   | `a + b`   的返回值 |
| 减赋值     | `-=`   | `a -= b`   等价于 `a = a - b`   | `a - b`   的返回值 |
| 乘赋值     | `*=*`  | `a *= b`   等价于 `a = a * b`   | `a * b`   的返回值 |
| 除赋值     | `/=`   | `a /= b`   等价于 `a = a / b`   | `a / b`   的返回值 |
| 取余赋值   | `%=`   | `a %= b`   等价于 `a = a % b`   | `a % b`   的返回值 |
| 求幂赋值   | `**=`  | `a **= b` 等价于 `a = a ** b`   | `a ** b` 的返回值  |
| 逻辑与赋值 | `&&=`  | `a &&= b` 等价于 `a && (a = b)` | `a` 最终的值       |
| 逻辑或赋值 | `||=`  | `a ||= b` 等价于 `a || (a = b)` | `a` 最终的值       |
| 逻辑空赋值 | `??=`  | `a ??= b` 等价于 `a ?? (a = b)` | `a` 最终的值       |

[MDN-运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence) 明确表示：“赋值运算符的返回结果就是赋值运算符右边的那个值”。通过下述例子亦可佐证该观点：

```js
let a, b;

( a = b ) = 1; // Error: Uncaught SyntaxError: Invalid left-hand side in assignment
```

因为 `a = b` 的返回值是变量 `b` 的值而不是变量 `b`，所以才会抛出 `Invalid left-hand`。

逻辑与赋值的定义是：若左运算元为 `truthy`，则将右运算元的值赋予左运算元，否则不进行赋值操作。因为逻辑与赋值具有短路计算的特性，因此 `a &&= b` 才会等价于 `a && ( a = b )` ，而不是 `a = a && b`，因为前者才符合短路计算的特性。对于逻辑或赋值、逻辑空赋值也是同理的。

## 逻辑运算符

| 名称   | 运算符 | 语法     | 描述                                                         |
| ------ | ------ | -------- | ------------------------------------------------------------ |
| 逻辑与 | `&&`   | `a && b` | 若 `a` 的布尔值为 `true`   ，则返回 `b` 的初始值；<br />若 `a` 的布尔值为 `false` ，则返回 `a` 的初始值，忽略 `b`； |
| 逻辑或 | `||`   | `a || b` | 若 `a` 的布尔值为 `true`   ，则返回 `a` 的初始值，忽略 `b` ；<br />若 `a` 的布尔值为 `false` ，则返回 `b` 的初始值； |
| 逻辑非 | `!`    | `!a`     | 若 `a` 的布尔值为 `true`   ，则返回 `false` ；<br />否则返回 `true` ； |
| 逻辑空 | `??`   | `a ?? b` | 若 `a` 的初始值为 `null` 或 `undefined` ，则返回 `b` 的初始值；<br />否则返回 `a` 的初始值，忽略 `b` ； |

注意，`a` 和 `b` 是变量或表达式，变量的初始值就是变量的值，表达式的初始值就是表达式的计算结果。

### 逻辑或

从左向右逐个检查运算元，然后返回首个 `truthy` 运算元的初始值，并忽略剩余的运算元。若一直没有找到 `truthy` 运算元，则返回最后那个运算元的初始值。比如对于 `a && b && c` ，JavaScript 引擎会这么做：

1. 从左向右逐个检查运算元；
2. 若当前运算元的初始值的数据类型不是布尔类型，则将其隐式转换为布尔类型；
3. 若当前运算元的布尔值为 `true`   ，则立即返回当前运算元的初始值，并忽略剩余的运算元；
4. 若所有运算元的布尔值为 `false` ，则返回最后那个运算元的初始值；

### 逻辑与

从左向右逐个检查运算元，返回首个 `falsy` 运算元的初始值，并忽略剩余的运算元。若一直没有找到 `falsy` 运算元，则返回最后那个运算元的初始值。

### 逻辑空

逻辑空又被称为空值合并运算符，它的执行逻辑很简单，即：如果左运算元的值为 `null` 或 `undefined`，则返回右运算元的值，否则就返回左运算元的值。

另外，ECMAScript 规定如果没有明确的添加圆括号，就不能混合使用 `??` 和 `||`，也不能混合使用 `??` 和 `&&`。

```js
1 && 2 ?? 3; // Syntax error: Unexpected token '??'
1 || 2 ?? 3; // Syntax error: Unexpected token '??'

( 1 && 2 ) ?? 3; // 2
( 1 || 2 ) ?? 3; // 1
```

为了弥补 `||` 的缺憾，所以语言规范的制定者创造了 `??`，不过制定者们认为人们在将 `||` 切换为 `??` 的时候容易引发错误，所以制定者们才额外添加了上文的限制措施。

### 短路计算

`&&` 、 `||` 、 `??` 具有能够忽略运算元的特性， “运算元被忽略” 是指该运算元没有被执行，因此被忽略的运算元中的错误、副作用、函数调用等都不会被触发。这种忽略运算元的行为被称为短路计算。短路计算常用于简化判断语句，但它也会降低代码的可读性。

```js
if ( 1 > 0 ) console.log( true );
/* equal to */
1 > 0 && console.log( true );
```

## 一元运算符

| 名称     | 运算符   | 语法                       | 描述 |
| -------- | -------- | -------------------------- | ---- |
| 一元加法 | `+`      | `+a`                       |      |
| 一元减法 | `-`      | `-a`                       |      |
| 逻辑非   | `!`      | `!a`                       |      |
| 按位非   | `~`      |                            |      |
| void     | `void`   | `void a`     或 `void (a)` |      |
| typeof   | `typeof` | `typeof a` 或 `typeof (a)` |      |
| delete   | `delete` | `delete a`                 |      |

### void

执行右运算元，然后返回 `undefined`，它的语法是：

```js
void expression;
void ( expression );
```

使用 `void` 来构造的 IIFE 会稍微安全一些，因为它的返回值总是 `undefined`：

```js
void function iife(){}();
```

`void` 还能用来构造无响应的超链接标签，比如：

```html
<a href="javascript: void 0;"></a>
<a href="javascript: void(0);"></a>
```

### typeof

返回一个表示右运算元的数据类型的字符串，它的语法是：

```js
typeof a;
typeof ( a );
```

| 数据类型                               | 返回值             |
| -------------------------------------- | ------------------ |
| `Undefined`                            | `"undefined"`      |
| `Null`                                 | `"object"`         |
| `Boolean`                              | `"boolean"`        |
| `Number`                               | `"number"`         |
| `Bigint`                               | `"bigint"`         |
| `String`                               | `"string"`         |
| `Symbol`                               | `"symbol"`         |
| `Function`                             | `"function"`       |
| 宿主对象（如 `window` 、 `document` ） | 取决于浏览器的实现 |
| 其它对象                               | `"object"`         |
| 未声明的变量                           | `"undefined"`      |

其中，`typeof null` 的返回值是 `'object'` ，这是一个历史遗留错误。

### delete

删除对象自身的指定属性，但不会删除对象原型链上的同名属性，它的语法时是：

```js
delete obj.prop;
delete obj[expr];
```

它有 2 种返回值，分别是：

- `false` ：若 `delete` 不可配置的属性，则会返回该值，且在非严格模式下，该操作将静默失败，在严格模式下，该操作将会抛出错误。
- `true` ：其余情况都返回 `true`。

`delete` 不存在的属性也会返回 `true` ，且被操作的对象没有任何变化。

```js
delete {}.a; // true
```

在任何作用域内，由声明关键字声明的变量都是某个对象的不可配置的属性，而不经声明就直接赋值来创建的变量则是某个对象的可配置的属性。因此，`delete` 前者将会返回 `false`，`delete` 后者将会返回 `true`，比如：

```js
var a = 1;
Object.getOwnPropertyDescriptor(window, "a").configurable; // false
```

```js
a = 1;
Object.getOwnPropertyDescriptor(window, "a").configurable; // true
```

```

```

`delete` 一个数组的元素，就会清空这个元素的内容，但不会释放掉这个元素所占据的内存空间，被 `delete` 后的元素的值为 `undefined` ，意义为 empty 。数组的长度不会改变，其它元素的下标也不会重排。

```js
const a = [ 1, 2 ];
delete a[ 0 ];
a;      // [ empty, 2 ]
a[ 0 ]; // undefined
```

## 三元运算符

又被称为条件运算符，它的语法是：

```js
condition ? expr_1 : expr_2;
```

若 `condition` 的 truthy 为 `true`，则执行 `expr_1`，且忽略 `expr_2`，最后返回 `expr_1` 的初始值。否则忽略 `expr_1`，执行 `expr_2`，最后返回 `expr_2` 的初始值。

注意，非表达式的语法结构不能作为三元运算符的运算元，比如函数内部的 `return`，循环体内的 `break` 和 `continue`。

## 比较运算符

所有比较运算符均会返回布尔值。

| 名称     | 运算符 | 名称       | 运算符 | 名称 | 运算符 | 名称       | 运算符 |
| -------- | ------ | ---------- | ------ | ---- | ------ | ---------- | ------ |
| 严格相等 | `===`  | 严格不相等 | `!==`  | 大于 | `>`    | 大于或等于 | `>=`   |
| 宽松相等 | `==`   | 宽松不相等 | `!=`   | 小于 | `<`    | 小于或等于 | `<=`   |

### 字符串之间的比较

JavaScript 会根据字符串的 Unicode 来比较字符串的大小，具体来说是：

1. 首先比较左右运算元的首位字符的 Unicode，该 Unicode 更大的运算元更大。
2. 如果左右运算元的首位字符的 Unicode 一样大，那么就比较第二位字符的 Unicode，该 Unicode 更大的运算元更大。
3. 如果左右运算元的第二位字符的 Unicode 一样大，那么就比较第三位字符的 Unicode，该 Unicode 更大的运算元更大。
4. ......
5. 如果左右运算元的字符都同时用完了，且还没能分出大小，那么就判定左右运算元相等。
6. 如果某一个运算元的字符已经用完了，且另一个运算元还有字符没用完，那么后者更大。

```js
"A" < "Z";    // true
"Z" < "a";    // true
"aa" < "ab";  // true
"ab" < "abb"; // true
```

### 不同原始类型之间的比较

严格相等运算符（`===`）会比较左右运算元的数据类型与值，只有当它们的数据类型与值均相等时，它们才相等。严格不相等运算符（`!==`） 也会比较左右运算元的数据类型与值，只要数据类型或值不相等，那么它们就不相等。

对于其他的比较运算符，如果左右运算元的数据类型不一致，那么 JavaScript 就会把左右运算元都隐式转换为数字值之后再进行比较。

```js
2 > "1";     // true，其中 "1" -> 1
2 > false;   // true，其中 false -> 0
"1" > false; // true，其中 false -> 0，"1" -> 1
"" == false; // true，其中 false -> 0，"" -> 0
```

### null 和 undefined

对于 `==` 和 `!==`，`null` 和 `undefined` 不会进行类型转换，并且它们还有一套特别的针对宽松相等和宽松不相等的比较规则，即：

- `null` 与 `undefined` 宽松相等，且它们不会与除了它们之外的任何值宽松相等。

```js
undefined == null;       // true
```

对于 `>`、`<`、`>=`、`<=`，`null` 和 `undefined` 会被隐式转换为数字值，其中 `null` 会被转换为 `0`，`undefined` 会被转换为 `NaN`。

需要注意的是，对于 `>=` 和 `<=`，大小比较和宽松相等比较的逻辑是分开的，`null` 和 `undefined` 会因为其中的大小比较逻辑而被隐式转换为数字值，然后再进行大小比较和宽松相等比较，于是便会出现这样一个奇怪的现象。

```js
null >= 0; // true
null == 0; // false
null >  0; // false
```

### NaN

`NaN` 与任何值（甚至包括它自己）进行任何比较都会返回 `false`。

```js
NaN == NaN; // false
```

### 引用值之间的比较

如果两个运算元都是引用值，且它们都指向同一个对象时，那么就认为他们是宽松相等和严格相等的，否则就认为它们是宽松不相等和严格不相等的。

## 逗号运算符

从左向右逐个执行运算元，然后返回最右边的运算元的初始值，请注意，声明语句中的逗号并不是逗号运算符，只有表达式中的逗号才是逗号运算符。它的语法是：

```
expr_1, expr_2, ..., expr_n;
```

示例：

```js
const exprA = _ => 1;
const exprB = _ => 2;

(exprA(), exprB()); // 2
```

## 可选链运算符

若左运算元为 `null` 或 `undefined` ，则返回 `undefined` ，并忽略右运算元，否则执行右运算元（通常是属性访问或函数调用）。它的语法是：

```js
obj?.property;
obj?.[expression];
array?.[index];
function?.();
```

## in 运算符

若该属性存在于该对象或该对象的原型链上，则返回 `true` ，否则返回 `false` ，它的语法是：

```js
prop in obj;
```

-  `prop` ： `String` 或 `Symbol` ，代表属性名或数组索引，其它的数据类型的值都会被隐式转换为 `String` 
-  `obj`   ： `Object`

示例：

```js
'toString' in {}; // true
0 in [1, 2, 3];   // true
```

## instanceof 运算符

若对象 A 的 `prototype` 属性位于对象 B 的原型链上，则返回 `true` ，否则返回 `false` 。它的语法是：

```js
obj_b instanceof obj_a;
```

示例：

```js
const A = function() {};
const a = new A();

a instanceof A;      // true
a instanceof Object; // true
```

## 位运算符

这类运算符在实际开发中很少被用到，因此暂时忽略它们，如果你更感兴趣，可以从 [这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) 开始学习

| 名称     | 运算符 | 名称       | 运算符 |
| -------- | ------ | ---------- | ------ |
| 按位与   | `&`    | 左移       | `<<`   |
| 按位或   | `|`    | 右移       | `>>`   |
| 按位异或 | `^`    | 无符号右移 | `>>>`  |
| 按位非   | `~`    |            |        |
