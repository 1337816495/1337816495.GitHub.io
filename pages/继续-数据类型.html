
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="X-UA-Compatible" content="IE=edge">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Document</title>
                <link rel="stylesheet" href="/style/resize.css">
            </head>
            <body>
                <article>
        <h1 id="数据类型">数据类型</h1>
<p>JavaScript 是一门动态的弱类型语言。</p>
<p>静态类型语言的变量的数据类型在代码的编译阶段就被确定了，动态类型语言的变量的数据类型在代码的执行阶段才被确定。</p>
<p>弱类型语言的变量的数据类型可以隐式转换，强类型语言的变量的数据类型不可以隐式转换。</p>
<p>ECMAScript 规定了 8 种数据类型，其中 7 种是原始类型， 1 种是引用类型。</p>
<h2 id="原始类型">原始类型</h2>
<p>原始类型又称为基本数据类型，原始类型的值称为原始值。</p>
<h3 id="number-类型">Number 类型</h3>
<p><code>number</code> 是基于 IEEE-754 标准的双精度 64 位二进制格式的值，可以安全的存储 <code>[ -2^53+1, 2^53-1 ]</code> 范围的值，显然 ECMAScript 中没有整数的数字类型，只有浮点数。</p>
<p>除了常规的数字， ECMAScript 还包括一些特殊数值，具体是： <code>Infinity</code> 、 <code>-Infinity</code> 、 <code>NaN</code> 。</p>
<h4 id="极值">极值</h4>
<p>浮点数的最大值是 <code>Number.MAX_VALUE</code> ，约为 <code>1.798e+308</code> ，最小值是 <code>Number.MIN_VALUE</code> ， 约为 <code>5e-324</code> ，注意最小浮点数并不等于 <code>0</code> ，而是无限接近于 <code>0</code> 。</p>
<p>整数的最大值是 <code>Number.MAX_SAFE_INTEGER</code> ，即为 <code>2^53-1</code> ，即 <code>9007199254740991</code> ，最小值是 <code>Number.MIN_SAFE_INTEGER</code> ，即 <code>-2^53-1</code> ，即 <code>-9007199254740991</code> 。</p>
<h4 id="特殊数值">特殊数值</h4>
<p>ECMAScript 中还包括一些特殊的数值，分别是： <code>Infinity</code> 、 <code>-Infinity</code> 、 <code>NaN</code> 。</p>
<h5 id="nan">NaN</h5>
<p><code>NaN</code> 是英文“not a number”的缩写，它代表计算错误，当数学操作不正确时，表达式便会返回该值，如果数学表达式中有一个 <code>NaN</code> ，则该表达式的运算结果必然也是 <code>NaN</code> ，只有一个例外： <code>NaN ** 0</code> 的结果为 <code>1</code> 。</p>
<blockquote>
<p>数学运算是安全的：在 JavaScript 程序中，我们做的任何离谱的数学运算都不会引发错误（比如 <code>1 / 0</code> 、 <code>&quot;string&quot; + 1</code> 等等），程序也不会因此被杀死，最坏的情况下我们也只是得到 <code>NaN</code> 的结果而已。</p>
</blockquote>
<p>此外， <code>NaN</code> 是 ECMAScript 中唯一一个自己不等于自己的值：</p>
<pre><code class="language-js">NaN ==  NaN; // 返回false
NaN === NaN; // 返回false
</code></pre>
<p>虽然浏览器运行时提供了 <code>window.isNaN( v )</code> 来鉴定 <code>NaN</code> ，但是实际上这个 API 并不可靠，因为输入 <code>NaN</code> 或 <code>undefined</code> 或 <code>非空非数字字符串</code> 或 <code>函数</code> 或 <code>对象</code> 时，它都会返回 <code>true</code> ：</p>
<p>如果想要鉴定 <code>NaN</code> ，请使用 <code>Number.isNaN( v )</code> 方法，或者它的 <code>Polyfill</code> ：</p>
<pre><code class="language-js">if ( !Number.isNaN ) { 

    Number.isNaN = function( n ) { return n !== n };

}
</code></pre>
<h5 id="infinity-和--infinity">Infinity 和 -Infinity</h5>
<p><code>Infinity</code> 代表数学中的无穷大 ∞ 。</p>
<p>JavaScript 无法存储和表示超出数值极限的值，当数值超出极限后，数值会被&quot;就近&quot;的舍入到 <code>Number.MAX_VALUE</code> 或 <code>Infinity</code> ，比如：</p>
<pre><code class="language-js">Number.MAX_VALUE + Math.pow( 2, 969 ); // 返回Number.MAX_VALUE
Number.MAX_VALUE + Math.pow( 2, 970 ); // 返回Infinity
</code></pre>
<h5 id="数字分隔符">数字分隔符</h5>
<p>假如我们需要表示 10 亿，显然，我们可以这样写：</p>
<pre><code class="language-js">const billion = 1000000000;
</code></pre>
<p>我们也可以使用下划线作为分隔符：</p>
<pre><code class="language-js">const billion = 1_000_000_000;
</code></pre>
<p>这里的下划线是语法糖，它使数字具有更强的可读性，在源码编译时，引擎会自动忽略数字之间的下划线，所以下划线不仅仅可以出现在千分位，还可以出现在百分位、十分位等......当然也可以用在其他进制的数字中，比如：</p>
<pre><code class="language-js">const sixteen = 0x1_0; // 16
</code></pre>
<h5 id="不精确的小数">不精确的小数</h5>
<p>ECMAScript 使用二进制来存储数字，虽然二进制可以准确的表示所有整数，但不能准确的表示所有小数，比如 <code>0.5</code> 的二进制值是 <code>0.1</code> ，但是 <code>0.1</code> 的二进制值是 <code>0.000110011001100...</code> ，这是一个无限循环小数，循环节是 1100 。</p>
<p>IEEE 754 使用 64 位的二进制来表示一个数值，其中 52 位用于存储整数， 11 位用于存储小数， 1 位用于存储符号，当遇到无限小数的二进制值时， IEEE 754 会进行四舍五入，这就是 ECMAScript 无法准确表示某些小数的原因。</p>
<p>这会带来什么问题呢？比如：</p>
<pre><code class="language-js">( 0.1 + 0.2 ) === 0.3; // 返回false！
</code></pre>
<pre><code class="language-js">6.35.toFixed( 1 ); // 返回&quot;6.3&quot;
</code></pre>
<p>这是因为：</p>
<pre><code class="language-js">0.1.toFixed( 20 );           // 0.10000000000000000555
0.2.toFixed( 20 );           // 0.20000000000000001110
0.3.toFixed( 20 );           // 0.29999999999999998890
( 0.1 + 0.2 ).toFixed( 20 ); // 0.30000000000000004441

6.35.toFixed( 20 );          // &quot;6.34999999999999964473&quot;
</code></pre>
<p>如何解决 <code>0.1 + 0.2</code> 不等于 <code>0.3</code> 的问题呢？办法就是：如果 2 个数值的差值的绝对值小于某个误差范围，则认为这 2 个数值是相等的，一般我们取机器精度 <code>Number.EPSILON</code> 来作这个误差范围，这是一个鉴定 2 个数值是否相等的函数：</p>
<pre><code class="language-js">function numbersCloseEnoughToEqual( n_1, n_2 ) {
    
    return Math.abs( n_1 - n_2 ) &lt; Number.EPSILON;
    
}
</code></pre>
<p>我们来试试这个方法！</p>
<pre><code class="language-js">numbersCloseEnoughToEqual( 0.1 + 0.2, 0.3 ); // 返回true！
</code></pre>
<p><code>Number.EPSILON</code> 是 ES6 的新特性，它的值是 <code>2^-52</code> ，这是它的 Polyfill ：</p>
<pre><code class="language-js">if ( !Number.EPSILON ) {
    
    Number.EPSILON = Math.pow( 2, -52 );
    
}
</code></pre>
<p>如何解决 <code>6.35.toFixed( 1 )</code> 等于 <code>&quot;6.3&quot;</code> 呢？在进行舍入之前，先让 <code>6.35</code> 更加接近整数，然后再舍入，比如：</p>
<pre><code class="language-js">Math.round( 6.35 * 10 ) / 10; // 返回 6.4
</code></pre>
<p>为什么要这么做呢？因为 <code>63.5</code>  是没有精度损失的，因为小数部分的 <code>0.5</code> 是 <code>1/2</code> ，以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确的表示，这时再进行舍入就没问题了。</p>
<pre><code class="language-js">63.5.toFixed( 20 ); // &quot;63.50000000000000000000&quot;
</code></pre>
<h5 id="冷知识">冷知识</h5>
<p>可以省略小数点前面的 <code>0</code> ，比如 <code>0.1</code> 可以简写成 <code>.1</code> ，我个人更喜欢 <code>0.1</code> 这种写法，因为更清晰。</p>
<p>小数部分多余的 <code>0</code> 可以省略，比如 <code>0.10</code> 可以简写成 <code>0.1</code> ，ECMAScript 不是 C++ ，它不区分整数和浮点数。</p>
<p>在 ECMAScript 中，指数的写法有好多种，下面的写法都是合法的：</p>
<pre><code class="language-js">2E5;  // 200000
2e5;  // 20000

2E+5; // 200000
2e+5; // 200000

2E-5; // 0.00002
2e-5; // 0.00002
</code></pre>
<p>ECMAScript 默认使用十进制来计数，除了十进制外，它还支持使用二进制、八进制和十六进制，我们需要为数字添加特殊的标识才能启用这些进制，这就是那些特殊的标识：</p>
<pre><code class="language-js">/* 二进制 */
0b10; // 2

/* 八进制 */
0o70; // 56

/* 十六进制 */
0xf0; // 240
</code></pre>
<blockquote>
<p>冷知识：你可能会在某些代码中看到以 <code>0</code> 为前缀的数字，实际上这也是八进制的格式，但该特性已经被淘汰了，为了向后兼容，非严格模式仍支持该特性，严格模式则会报错。</p>
</blockquote>
<p>如果你还想使用其他的进制，比如 3 进制，你就可以使用 <code>Number.prototype.toString( [ radix ] )</code> 方法，该方法会将数字值转换为指定进制的数字字符串， <code>radix</code> 的取值范围是 <code>[ 2, 36 ]</code> ，表示将要采用的进制，缺省时将取 <code>10</code> ，这是一个例子：</p>
<pre><code class="language-js">3..toString( 3 ); // 返回&quot;10&quot;，这是将3转换为3进制下的数字字符串
</code></pre>
<p>在 ECMAScript 中，数字字面量可以直接调用 <code>Number.prototype</code> 上的方法，不过需要小心“小数点”问题，下面罗列了各种情况：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>如果数字字面量有小数点，比如 <code>0.1</code></td>
<td>直接使用点号属性访问器来调用方法，比如 <code>0.1.toString()</code></td>
</tr>
<tr>
<td>如果数字字面量是指数</td>
<td>直接使用点号属性访问器来调用方法，比如 <code>2e5.toString()</code></td>
</tr>
<tr>
<td>如果数字字面量是整数，比如 <code>1</code></td>
<td>1.改造成小数后再使用点号属性访问器来调用方法，比如 <code>1.0.toString()</code> <br />2.添加圆括号后再使用点号属性访问器来调用方法，比如 <code>( 1 ).toString()</code> <br />3.添加空格尾缀后再使用点号属性访问器来调用方法，比如 <code>1 .toString()</code> <br />4.添加换行符后再使用点号属性访问器来调用方法<br />5.添加小数点后再使用点号属性访问器来调用方法，比如 <code>1..toString()</code></td>
</tr>
</tbody></table>
<h3 id="bigint-类型">BigInt 类型</h3>
<p>TODO</p>
<h3 id="string-类型">String 类型</h3>
<h4 id="boolean-类型">Boolean 类型</h4>
<h3 id="null-类型">Null 类型</h3>
<h3 id="undefined-类型">Undefined 类型</h3>
<h3 id="symbol-类型">Symbol 类型</h3>
<h2 id="引用类型">引用类型</h2>
<p>引用类型又称为复杂数据类型，引用类型的值称为引用值。</p>
<h2 id="待定-原始类型和引用类型的区别">待定-原始类型和引用类型的区别</h2>
<p>首先，在存储方式上，原始值存储在栈空间中，引用值存储在堆空间中。</p>
<p> JavaScript 引擎可以直接获取存储在栈空间中的值，对于存储在堆空间中的值， JavaScript 引擎必须先从栈空间中获得指向引用值的指针（地址字符串），然后再根据指针从堆空间中获取引用值。</p>
<p>之所以要这么设计，是为了加快查找值的速度，因为所有原始值所占的存储空间大小是固定不变的，如果栈空间中只存储原始值，那么每个原始值的地址都相差 N 个偏移量</p>

                </article>
            </body>
            </html>
        