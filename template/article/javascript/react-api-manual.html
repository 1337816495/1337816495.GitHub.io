<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React API 手册</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=5c2e01f1-1d0e-4ba3-ac6b-656b8f8a3d6d>概述</p>
        <p data-target-id=f5823690-243c-433f-9d11-5c0322707076>UI 树与状态</p>
        <p data-target-id=72f934a1-08b9-401f-8f54-2c8be1f6cb16>StrictMode</p>
        <p data-target-id=d0cb0906-b24a-4e4f-9849-92797312f761>useState</p>
        <p data-target-id=a6a7c3c7-63b6-4ca6-9784-ac00de0e8c56>useReducer</p>
        <p data-target-id=1dfb51b1-1c59-471c-aaa8-d175c8b0a7ab>useEffect</p>
        <p data-target-id=979bb0ea-68fc-4746-a7fa-e1c7e589a530>useLayoutEffect</p>
        <p data-target-id=aa9f7d65-d29a-4b74-b3e8-9ae9c4fb8d25>useRef</p>
        <p data-target-id=1beb8513-26c5-4461-b25b-f9d77557a010>useContext</p>
        <p data-target-id=e41f1cd0-3306-46b4-b792-05968d4ea1a4>memo</p>
        <p data-target-id=83a73b93-d149-4cfb-9a26-80a97d7d6237>useMemo</p>
        <p data-target-id=a2cae887-1627-4e0e-82a1-565f3159655d>useCallback</p>
        <p data-target-id=1736457d-04ee-4073-bb44-03d4ae7ea139>useImperativeHandle</p>
        <p data-target-id=c5f8fcae-50ff-4193-a8b3-49644ee725cb>useDebugValue</p>
        <p data-target-id=e2dca137-7939-4182-aacf-cab927f32552>Custom Hook</p>
        <p data-target-id=003aa5b5-f178-4f93-8997-496ada8f919e>ref property</p>
        <p data-target-id=1af8936e-bfb0-470d-8155-8fc3c610f799>forwardRef</p>
        <p data-target-id=19375a9d-458f-42e5-945e-3b77f6c3696a>flushSync</p>
        <p data-target-id=41bf74f2-6e58-4ff4-b266-7dbba30620a3>Error Boundary</p>
    </aside>
    <article>
        <h1>React API 手册</h1>
        <h2 id="5c2e01f1-1d0e-4ba3-ac6b-656b8f8a3d6d">概述</h2>
        <p>此文用于记录 React API，并遵循下列准则：</p>
        <ul>
            <li>直白易懂</li>
            <li>总是最新</li>
            <li>专属于我</li>
        </ul>
        <h2 id="f5823690-243c-433f-9d11-5c0322707076">UI 树与状态</h2>
        <p>组件的状态就是一份用于描述组件状况的数据，然而这份数据却并不存在于组件的内部，而是存在于 React 之中，直至组件构造器被调用的时候，React 才会将属于组件的状态数据派发给组件。</p>
        <p>特别的是，React 并没有直接将状态数据和组件绑定在一起，而是将状态数据和 UI 树关联在一起，更具体的说，React 将状态数据和位置、种类、<code>key</code> 值绑定在了一起。</p>
        <ol>
            <li>如果 React 在 UI 树上的 <code>p</code> 位置新增了一个种类为 <code>t</code> 且 <code>key</code> 值为 <code>k</code> 的组件，那么 React 就会新建一份状态数据，并将这份状态数据和 <code>p</code>、<code>t</code>、<code>k</code> 关联在一起。</li>
            <li>如果 React 移除了 UI 树上 <code>p</code> 位置的组件，那么 React 就会销毁掉与 <code>p</code> 位置所对应的状态数据。</li>
            <li>如果 React 更新了 UI 树上 <code>p</code> 位置的组件的种类 <code>t</code>，那么就相当于先执行步骤 2 再执行步骤 1。</li>
            <li>如果 React 更新了 UI 树上 <code>p</code> 位置的组件的 <code>key</code> 值 <code>k</code>，那么就相当于先执行步骤 2 再执行步骤 1。</li>
        </ol>
        <p>得益于步骤 4，我们可以通过更新组件的 <code>key</code> 属性来重置组件。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>创建组件时，如果我们为组件的 <code>key</code> 属性指定了一个值，那么组件的 <code>key</code> 属性就会使用这个指定值。否则，组件的 <code>key</code> 属性就会使用默认值，这个默认值是组件在父组件中的序号，比如 <code>first</code>、<code>second</code> 等。</p>
            <p>另外，如果移除了一个组件，那么该组件的后代组件也都会被移除，所以被移除的组件的后代组件也都会执行步骤 2。</p>
        </blockquote>
        <h3 id="d9c92fe2-828c-49a5-a5ef-283d9dc4d948">UI 树</h3>
        <p>UI 树类似于 DOM 树，DOM 树描述了每个节点的位置关系，而 UI 树则描述了每个 react element 的位置关系。React 通过 JSX 来构建 UI 树，并通过 UI 树来更新 DOM 树。</p>
        <p><img src=/static/image/markdown/javascript/react-api-manual/ui-tree.png alt=UI树 loading="lazy" decoding="async"></p>
        <h2 id="72f934a1-08b9-401f-8f54-2c8be1f6cb16">StrictMode</h2>
        <p><code>StrictMode</code> 译为“严格模式”，它是 React 中的一个用于探测潜在问题的特性，我们通过 <code>&lt;React.StrictMode&gt;</code> 标签来使用这个特性。</p>
        <h3 id="a2a47f3f-6778-48dd-860a-5fa6d900b593">启用</h3>
        <p>被包含在 <code>&lt;React.StrictMode&gt;</code> 标签内的代码将会启用严格模式，我们可以对任意代码启用严格模式：</p>
        <pre><code class="language-jsx">function Component () {
    
    return (
        &lt;&gt;
            &lt;div&gt;不启用严格模式&lt;/div&gt;
            &lt;React.StrictMode&gt;
                &lt;div&gt;启用严格模式&lt;/div&gt;
            &lt;/React.StrictMode&gt;
        &lt;/&gt;
    );
    
}
</code></pre>
        <h3 id="9833f50d-3a3a-43d2-9364-5a361ba3712f">作用</h3>
        <p><code>&lt;React.StrictMode&gt;</code> 仅在开发环境下生效，在生产环境下不会生效，并且该标签就像 <code>&lt;React.Fragment&gt;</code> 标签一样，不会渲染任何可见的 UI。其作用具体如下：</p>
        <ol>
            <li>检测组件是否是纯函数。</li>
            <li>检测组件是否使用了过时的方法。</li>
        </ol>
        <p>关于第一点：在开发环境下，当挂载组件时，React 会连续调用两次组件构造器，并最后只使用其中一次调用的结果。当更新组件时，React 会连续调用两次组件的更新器（即 <code>setState</code> 函数），并最后只使用其中一次调用的结果。React 通过这种方式来检测组件是否是纯函数。</p>
        <p>另外，从 React 18 开始，在开发环境下，每当组件挂载之后，React 都会立即卸载和重新挂载组件，并在最后使用第一次挂载时的状态。React 之所以这么做，是为了给未来的某个新特性做准备。</p>
        <h2 id="d0cb0906-b24a-4e4f-9849-92797312f761">useState</h2>
        <p><code>useState</code> 用于声明、存储、更新组件的内部状态，其语法如下：</p>
        <pre><code class="language-jsx">/* 语法一 */
const [ state, setState ] = useState( initial_state );

/* 语法二 */
const [ state, setState ] = useState( function createInitialState () { return initial_state } );
</code></pre>
        <p>因为第二种语法可以动态的创建状态的初始值，所以 React 官方把第二种语法称为“惰性初始化（lazy initialize）”，把 <code>createInitialState</code> 称为“惰性初始化器（lazy initializer）”。</p>
        <h3 id="57cd4e4f-077f-437c-bfcb-c4b0c2c1b658">setState</h3>
        <p><code>setState</code> 用于更新状态、更新组件，其语法如下：</p>
        <pre><code class="language-jsx">/* 语法一 */
setState( next_state );

/* 语法二 */
setState( function createNextState ( previous_state ) { return next_state } );
</code></pre>
        <p>调用 <code>setState</code> 之后，<code>setState</code> 的入参就会被推入状态的任务队列，并创建一个异步的任务（宏/微任务）来更新组件。在更新组件的期间，<code>useState</code> 函数就会通过处理状态的任务队列，来计算出状态的值，然后返回这个值。</p>
        <h3 id="3145ad80-1253-4745-b5a6-b95edcc91e33">原理</h3>
        <p>在每一次调用组件构造器的期间，<code>useState</code> 函数都会被执行，而 <code>useState</code> 函数会返回一个代表组件当前状态的值（<code>state</code>），和一个用于更新状态的函数（<code>setState</code>）。</p>
        <p>不过，<code>useState</code> 函数在组件挂载时和更新时的行为是有区别的：</p>
        <ul>
            <li>挂载时：<code>useState</code> 函数会根据入参的类型来决定返回值：<ul>
                    <li>如果入参是一个函数，那么 React 就会立即调用这个函数，并用该函数的返回值来作为自己的第一个返回值。</li>
                    <li>否则，React 就会直接用入参来作为自己的第一个返回值。</li>
                </ul>
            </li>
            <li>更新时：<code>useState</code> 函数会忽略入参，并通过特殊手段来计算出一个值，然后再用这个值来作为自己的第一个返回值，关于“特殊手段”，详见下例。</li>
        </ul>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>其中，“挂载”代表 React 首次调用组件构造器，“更新”代表 React 非首次调用组件构造器。</p>
        </blockquote>
        <p>比如，触发 <code>click</code> 事件之后，<code>handleClick</code> 函数会多次调用 <code>setA</code> 和 <code>setB</code>，它们的入参会被依次推入各自的任务队列中去。另外，<code>setA</code> 和 <code>setB</code> 也触发了组件的更新（异步的）。</p>
        <p><img src=/static/image/markdown/javascript/react-api-manual/setstate-queue-create.png alt=状态的任务队列 loading="lazy" decoding="async"></p>
        <p>更新组件时，<code>useState</code> 函数会依次处理任务队列中的任务，然后计算出状态的值，然后返回这个值。</p>
        <p><img src=/static/image/markdown/javascript/react-api-manual/setstate-queue-calculate.png alt=计算状态值 loading="lazy" decoding="async"></p>
        <p>虽然我们多次调用了 <code>setState</code> 函数，但是 React 只更新了一次组件，React 官方把这种批处理 <code>setState</code> 函数的特性称为 batching。</p>
        <h3 id="2c4b603b-fe82-40fb-a69d-03b6bc462539">无效更新</h3>
        <p>无论 <code>setState</code> 的入参是一个函数，还是一个非函数的值，只要 <code>Object.is( previous_state, next_state )</code> 返回 <code>true</code>，那么该 <code>setState</code> 就不会触发组件的更新。</p>
        <p>不过，哪怕 <code>setState</code> 不会触发更新，这个 <code>setState</code> 的入参也会被推入状态的任务队列。</p>
        <h2 id="a6a7c3c7-63b6-4ca6-9784-ac00de0e8c56">useReducer</h2>
        <p><code>useReducer</code> 是 <code>useState</code> 的替代品，区别在于 <code>useReducer</code> 可以把更新状态的逻辑代码从组件中抽离出来。选择何者？如果更新状态的逻辑代码多/复杂，那么就使用 <code>useReducer</code>，否则使用 <code>useState</code>。</p>
        <pre><code class="language-jsx">/* 语法一 */
const [ state, dispatch ] = useReducer( reduce, initial_state );

/* 语法二 */
const [ state, dispatch ] = useReducer(
    reduce,
    initial_data,
    function initialize ( initial_data ) { return initial_state },
);

/* reduce */
function reduce ( previous_state, action ) { return next_state }
</code></pre>
        <ul>
            <li><code>state</code> 是状态值。</li>
            <li><code>dispatch</code> 是用于派发 <code>action</code> 的函数（即 <code>dispatch( action )</code>）。</li>
        </ul>
        <p>对于第二种语法，<code>initialize</code> 函数的返回值会作为状态的初始值，而该函数在调用时会接收一个入参，这个入参就是 <code>useReducer</code> 的第二个参数。React 官方把这种语法称为“惰性初始化（lazy initialize）”，理由同 <code>useState</code> 的惰性初始化。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>因为 <code>useReducer</code> 所返回的 <code>dispatch</code> 是 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">稳定的、不会改变的</a>（即 <code>dispatch</code> 并不会在组件更新时发生改变），所以我们不需要将其添加进 <code>useEffect</code> 和 <code>useCallback</code> 的 <code>dependency_array</code> 中去。</p>
        </blockquote>
        <h3 id="d9554c8c-05ca-476e-8843-4ea2fa94d820">范例</h3>
        <pre><code class="language-jsx">function Counter ( {
    step = 3,
    initialCount: initial_count = 0,
} ) {

    const [ state, dispatch ] = useReducer( reduce, { count: initial_count } );

    return (
        &lt;&gt;
            &lt;p&gt;{ state.count }&lt;/p&gt;
            &lt;button onClick={ handleAddClick }&gt;Add&lt;/button&gt;
            &lt;button onClick={ handleSubClick }&gt;Sub&lt;/button&gt;
        &lt;/&gt;
    );

    function handleAddClick () { dispatch( { type: &quot;INCREMENT&quot;, step } ) }
    function handleSubClick () { dispatch( { type: &quot;DECREMENT&quot;, step } ) }

}

function reduce ( previous_state, action ) {

    switch ( action.type ) {

        case &quot;INCREMENT&quot;:
            return { count: previous_state.count + action.step };

        case &quot;DECREMENT&quot;:
            return { count: previous_state.count - action.step };

        default:
            throw new Error( `Unsupported action type: ${ action.type }` );

    }

}
</code></pre>
        <h3 id="f0b3a1fb-664d-4cfd-ba1f-d9bd94647cd2">原理</h3>
        <p><code>useReducer</code> 的原理和 <code>useState</code> 的原理差不多，只不过在 <code>useReducer</code> 的任务队列中，排队的是 <code>action</code>。另外，你可以认为 <code>useReducer</code> 是这么实现的：</p>
        <pre><code class="language-jsx">function useReducer ( reduce, initial_state ) {

    const [ state, setState ] = useState( initial_state );
    const dispatch = action =&gt; setState( previous_state =&gt; reduce( previous_state, action ) );

    return [ state, dispatch ];

}
</code></pre>
        <h3 id="cc92603b-fa15-4a5b-b356-5ae373625f12">名称起源</h3>
        <p>虽然 <code>useReducer</code> 可以减少组件内的代码，但这并不是它叫 <code>reducer</code> 的原因。它之所以叫 <code>reducer</code>，是因为它的工作原理和 <code>Array.prototype.reduce</code> 一样。</p>
        <pre><code class="language-jsx">[ 1, 2, 3 ].reduce( ( previous, current ) =&gt; previous + current ); // 1 + 2 + 3
</code></pre>
        <p>如上所示，<code>Array.prototype.reduce</code> 会基于前一次调用的返回值和当前元素的值，来推断出本次调用的返回值，然后继续如此向后处理，直至推断出最终的值。如果我们连续 <code>dispatch</code> 了多个 <code>action</code>，那么 <code>useReducer</code> 就会做相似的事情：</p>
        <ul>
            <li>通过原始状态值和第一个 <code>action</code> 来推断出第一次变化后的状态值。</li>
            <li>通过第一次变化后的状态值和第二个 <code>action</code> 来推断出第二次变化后的状态值。</li>
            <li>...</li>
            <li>直至推断出最终的状态值。</li>
        </ul>
        <h2 id="1dfb51b1-1c59-471c-aaa8-d175c8b0a7ab">useEffect</h2>
        <p><code>useEffect</code> 用于执行带有副作用的操作，其语法如下：</p>
        <pre><code class="language-jsx">useEffect(
    function effect () { return function clean () {} },
    dependency_array
);
</code></pre>
        <ul>
            <li><code>effect</code> 函数用于装载具有副作用的操作，如果挂载或更新了组件，那么 React 就会执行 <code>effect</code> 函数，并且执行时机是在页面更新之后。</li>
            <li><code>dependency_array</code> 数组用于决定是否执行 <code>effect</code> 和 <code>clean</code> 函数。</li>
        </ul>
        <h3 id="47eb7d76-db04-45a8-a823-4d2076f4424e">clean</h3>
        <p><code>clean</code> 是由 <code>effect</code> 函数所返回的另一个函数，它用于清除副作用，它的运行机制如下：</p>
        <ul>
            <li>如果更新了组件，那么 React 就会在页面更新之后、<code>effect</code> 函数执行之前，就执行 <code>clean</code> 函数，这么做是为了消除上一次调用 <code>effect</code> 函数时所产生的副作用，否则组件在多次更新之后，副作用就会累积。</li>
            <li>如果卸载了组件，那么 React 就会在页面更新之后执行 <code>clean</code> 函数，这么做时为了消除死亡节点所遗留的副作用。</li>
        </ul>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>事实上，<code>effect</code> 函数除了可以返回函数之外，还可以返回 <code>undefined</code>，所以 <code>clean</code> 是可选的。不过，如果 <code>effect</code> 函数返回了其他数据类型的值，那么 React 就会报错。</p>
        </blockquote>
        <h3 id="394c962b-bdb5-4daa-95b9-7c48644f3af9">dependency_array</h3>
        <p><code>dependency_array</code> 数组用于决定是否执行 <code>effect</code> 和 <code>clean</code> 函数，具体来说：</p>
        <pre><code class="language-jsx">/**
 * 方式一：
 * 如果挂载或更新了组件，那么effect函数就会执行。
 * 如果卸载或更新了组件，那么clean 函数就会执行。
 */
useEffect(
    function effect () { return function clean () {} },
);

/**
 * 方式二：
 * 如果挂载了组件，那么effect函数就会执行。
 * 如果卸载了组件，那么clean 函数就会执行。
 */
useEffect(
    function effect () { return function clean () {} },
    [],
);

/**
 * 方式三：
 * 如果挂载了组件，那么effect函数就会执行；
 * 如果更新了组件，且state变量发生了变化，那么effect函数就会执行。
 * 如果卸载了组件，那么clean 函数就会执行；
 * 如果更新了组件，且state变量发生了变化，那么clean 函数就会执行。
 */
useEffect(
    function effect () { return function clean () {} },
    [ state ],
);
</code></pre>
        <p>其中，React 使用 <code>Object.js</code> 来比较新旧 <code>state</code> 是否发生了变化。</p>
        <p>另外，因为 <code>useReducer</code> 所返回的 <code>dispatch</code> 是 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">稳定的、不会改变的</a>，所以哪怕我们在 <code>effect</code> 函数中使用了 <code>dispatch</code> 函数，我们也不需要将其添加进 <code>dependency_array</code>。</p>
        <h3 id="f82bc49d-e9c1-4442-bc7b-86a7889fb947">React18 的糟糕更新</h3>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>这真是一个十分糟糕的更新，因为这个改动不仅没什么用，还给开发者带来了心智负担，你能想到或理解 <code>useEffect</code> 会有如此出人意料的行为吗？</p>
        </blockquote>
        <p>在 React 17 及之前的版本，<code>effect</code> 和 <code>clean</code> 总是在页面更新之后执行。但是从 React 18 开始，如果 <code>useEffect</code> 是由离散的输入事件所触发的（比如点击事件），那么 <code>effect</code> 和 <code>clean</code> 就会在页面更新之前执行。详见 <a href="https://github.com/reactwg/react-18/discussions/128">New in 18: useEffect fires synchronously when it&#39;s the result of a discrete input</a> 和 <a href="https://reactjs.org/docs/hooks-reference.html#timing-of-effects">Timing of effects</a>。不过无论如何，<code>effect</code> 和 <code>clean</code> 都会在 <code>layout effect</code> 和 <code>layout clean</code> 之后执行。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>“如果 <code>useEffect</code> 是由离散的输入事件所触发的”是指：离散的输入事件触发了组件更新，然后组件更新触发了 <code>useEffect</code>。</p>
        </blockquote>
        <p>如下所示，<code>useEffect</code> 是由点击事件触发的，而点击事件是离散的输入事件，因此 <code>effect</code> 会在页面更新之前执行，这会导致，用户点击了 add 按钮之后，页面会在 1000ms 之后新增一个红色的 <code>&lt;li&gt;</code>。假如 <code>effect</code> 会在页面更新之后执行，那么用户点击了 add 按钮之后，页面就会立即新增一个黑色的 <code>&lt;li&gt;</code>，然后在 1000ms 之后，<code>&lt;li&gt;</code> 又变成红色。</p>
        <pre><code class="language-jsx">function App () {

    const [ count, setCount ] = React.useState( 1 );
    const lis = [];

    for ( let i = 0; i &lt; count; i ++ ) {

        lis.push( &lt;li key={ i } id={ i }&gt;{ i }&lt;/li&gt; );

    }

    React.useEffect( function effect () {

        sleep();

        document.getElementById( count - 1 ).style.color = &quot;red&quot;;

    }, [ count ] );

    return (
        &lt;&gt;
            &lt;button onClick={ _ =&gt; setCount( count + 1 ) }&gt;add&lt;/button&gt;
            &lt;button onClick={ _ =&gt; setCount( count - 1 ) }&gt;sub&lt;/button&gt;
            &lt;ul&gt;
                { lis }
            &lt;/ul&gt;
        &lt;/&gt;
    );

}

function sleep ( time = 1000 ) {

    const wakeup_time = Date.now() + time;

    while ( Date.now() &lt; wakeup_time ) {}

}
</code></pre>
        <h2 id="979bb0ea-68fc-4746-a7fa-e1c7e589a530">useLayoutEffect</h2>
        <p><code>useLayoutEffect</code> 的用法和 <code>useEffect</code> 的完全一样，它们的区别在于：</p>
        <ul>
            <li><code>useEffect</code> 的 <code>effect</code> 和 <code>clean</code> 函数均在页面更新之后调用。</li>
            <li><code>useLayoutEffect</code> 的 <code>effect</code> 和 <code>clean</code> 函数均在 DOM 更新之后、页面更新之前被调用。</li>
        </ul>
        <p>注意，<code>useLayoutEffect</code> 的 <code>clean</code> 函数也同样会在 <code>effect</code> 函数之前执行。</p>
        <h2 id="aa9f7d65-d29a-4b74-b3e8-9ae9c4fb8d25">useRef</h2>
        <p><code>useRef</code> 用于提供一个数据仓库，这个数据仓库会伴随组件的整个生命周期，这意味着开发者可以在数据仓库中存储一些历史数据，另外我们也常常用这个数据仓库来存储 DOM 节点。</p>
        <p>具体来说 <code>useRef</code> 会返回一个只有 <code>current</code> 属性的普通对象，比如 <code>{ current: initial_value }</code>，其语法如下：</p>
        <pre><code class="language-jsx">const reference = useRef( initial_value ); // { current: initial_value }
</code></pre>
        <h3 id="75566bd1-f838-44b8-ac51-31ff21e87db1">语法糖</h3>
        <p>我们可以认为 <code>useRef</code> 是 <code>useState</code> 的语法糖，因为 React 官方说 <code>useRef</code> 大概是这么实现的：</p>
        <pre><code class="language-jsx">function useRef ( initial_value ) {

    const [ reference, setReference ] = useState( { current: initial_value } );

    return reference;

}
</code></pre>
        <h2 id="1beb8513-26c5-4461-b25b-f9d77557a010">useContext</h2>
        <p><code>context</code> 是 <code>property</code> 的替代品，它是另一种传递数据的方案，它可用于远距离传输数据和大范围发布数据。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p><code>property</code> 是指组件构造器的第一个入参，从父组件中传递下来的数据，都会保存在这个参数中。</p>
        </blockquote>
        <h3 id="70310c24-0d59-4436-8838-1c01bfd27bdc">使用</h3>
        <p>第一步：创建一个 <code>CountContext</code>。</p>
        <pre><code class="language-jsx">const CountContext = createContext( initial_value );
</code></pre>
        <p>第二步：在组件内订阅 <code>CountContext</code>，然后该组件会沿着 UI 树，向上寻找距离最近的 <code>CountContext.Provider</code>，如果找到了，那么就使用 <code>CountContext.Provider</code> 的 <code>value</code> 值，否则就使用 <code>CountContext</code> 的初始值 <code>initial_value</code>。</p>
        <pre><code class="language-jsx">function Counter () {

    const count = useContext( CountContext );

    return &lt;p&gt;{ count }&lt;/p&gt;;

}
</code></pre>
        <p>第三步（可选）：在上层组件中，使用 <code>CountContext.Provider</code> 来向下层组件发布一个新值。下例中的第一个 <code>&lt;Counter/&gt;</code> 将会返回<code>&lt;p&gt;0&lt;/p&gt;</code>，第二个 <code>&lt;Counter/&gt;</code> 将会返回 <code>&lt;p&gt;1&lt;/p&gt;</code>。</p>
        <pre><code class="language-jsx">function App () {

    return (
        &lt;&gt;
            &lt;Counter/&gt;
            &lt;CountContext.Provider value={ next_value }&gt;
                &lt;Counter/&gt;
            &lt;/CountContext.Provider&gt;
        &lt;/&gt;
    );

}
</code></pre>
        <h3 id="57bf8088-cf21-4bf3-8991-b1bc412bf3c3">远距离传输数据</h3>
        <p>想象一下，当曾曾曾祖父组件需要向曾曾曾孙组件传递数据时，如果我们使用 <code>property</code> 方案，那么数据就需要从曾曾曾祖父组件开始向下传递，依次流经曾曾祖父组件、曾祖父组件、祖父组件、父组件，最后才能到达曾曾曾孙组件。</p>
        <p>当我们使用 <code>property</code> 方案时，如果数据传递的路径非常长，那么就会给维护带来不小的麻烦，因为一旦我们需要修改传递的数据，比如更名、新增、移除，我们就需要对传递路径上的每一个环节做修改。</p>
        <p>React 官方把这种数据传递路径很长的情况称为“prop drilling（钻探）”。</p>
        <p><code>context</code> 可以直接解决这个问题，因为 <code>context</code> 可以“一步到位”的向下传递数据。不过，由于 <code>context</code> 会隐藏数据的传递路径，所以你需要翻阅更多的代码才能看清数据是如何传递的，这意味着代码的可读性会下降。</p>
        <h3 id="e8e3571c-5025-4972-ba42-34e833236fcf">大范围广播数据</h3>
        <p><code>context</code> 的另一个好处是可以大范围的广播数据，但这并没有什么好细说的。</p>
        <h2 id="e41f1cd0-3306-46b4-b792-05968d4ea1a4">memo</h2>
        <p><code>memo</code> 是高阶组件，它用于创建组件的 memoized 版本。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>高阶组件（Higher Order Component）是一种基于 React 的设计模式，它是一个参数和返回值均为组件的函数，用于转换组件。</p>
        </blockquote>
        <h3 id="0f2ce68c-964f-4faf-9fe7-75b5d3274e86">语法</h3>
        <pre><code class="language-jsx">/* 语法一 */
const MemoizedComponent = memo( Component );

/* 语法二 */
const MemoizedComponent = memo( Component, areEqual );

function areEqual ( previous_property, current_property ) {}
</code></pre>
        <p>其中：</p>
        <ul>
            <li><code>Component</code> 是原始的自定义组件。</li>
            <li><code>MemoizedComponent</code> 是 <code>Component</code> 的 memoized 版本。</li>
            <li><code>areEqual</code> 是可选的函数入参，我们使用它来自定义新旧 <code>property</code> 的比较规则，缺省情况下，React 只会浅比较新旧 <code>property</code>。</li>
        </ul>
        <h3 id="1e031d40-0b8f-47ab-8bdb-fa45277a1115">MemoizedComponent</h3>
        <p><code>MemoizedComponent</code> 的运行原理大致如下：</p>
        <ul>
            <li>挂载时：<ul>
                    <li><code>MemoizedComponent</code> 缓存自己接收到的 <code>property</code>，来作为 <code>cache_property</code>。</li>
                    <li><code>MemoizedComponent</code> 以 <code>cache_property</code> 为参数，来调用 <code>Component</code>。</li>
                    <li><code>MemoizedComponent</code> 缓存 <code>Component</code> 的调用结果，来作为 <code>cache_result</code>。</li>
                    <li><code>MemoizedComponent</code> 返回 <code>cache_result</code>。</li>
                </ul>
            </li>
            <li>更新时：<ul>
                    <li>如果 <code>MemoizedComponent</code> 自己接收到的 <code>property</code> 等于 <code>cache_property</code>，那么 <code>MemoizedComponent</code> 就会直接返回 <code>cache_result</code>。</li>
                    <li>否则，就重复挂载时的操作。</li>
                </ul>
            </li>
        </ul>
        <p>另外，如果 <code>Component</code> 的实现代码中使用了 <code>useState</code>、<code>useReducer</code>、<code>useContext</code>，那么我们可以直接使用这 3 个 hook 来更新 <code>Component</code>，这可以无视 <code>MemoizedComponent</code> 对新旧 <code>property</code> 的检查。我实践发现，如果我使用这些方式来直接更新 <code>Component</code>，那么 <code>Component</code> 的新返回值会更新 <code>MemoirzedComponent</code> 的 <code>cache_result</code>。</p>
        <p>需要特别注意的是，<code>MemoizedComponent</code> 不会缓存所有过往的 <code>property</code> 和 <code>result</code>，它只会缓存上一次的 <code>property</code> 和 <code>result</code>。</p>
        <h3 id="e0b3b00a-c146-40cd-b819-76dbafe0e44d">areEqual</h3>
        <p><code>areEqual</code> 是 <code>memo</code> 的第二个入参，它是一个函数，用于定义该如何比较新旧 <code>property</code> 是否相等，如果它返回 <code>true</code>，那么就代表新旧 <code>property</code> 相等，如果它返回 <code>false</code>，就代表新旧 <code>property</code> 不相等。</p>
        <p><code>areEqual</code> 是可选的，当它缺省时，<code>memo</code> 会通过浅比较，来判断新旧 <code>property</code> 是否相等。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>旧 <code>property</code> 是指 <code>MemoizedComponent</code> 的 <code>cache_property</code>，新 <code>property</code> 是指 <code>MemoizedComponent</code> 在当前调用时刻所接收到的 <code>property</code>。</p>
        </blockquote>
        <h2 id="83a73b93-d149-4cfb-9a26-80a97d7d6237">useMemo</h2>
        <p><code>useMemo</code> 用于创建值的 memoized 版本。</p>
        <h3 id="1abe8fdc-da27-47d3-ad9a-b2c60b92dabb">语法</h3>
        <pre><code class="language-jsx">const memoized_value = useMemo( function expensiveCalculate () {}, dependency_array );
</code></pre>
        <ul>
            <li><code>expensiveCalculate</code> 是一个无参函数，它的返回值会作为 <code>memoized_value</code> 的值。</li>
            <li><code>dependency_array</code> 数组用于决定是否执行 <code>expensiveCalculate</code> 函数来更新 <code>memoized_value</code> 的值。</li>
        </ul>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>请勿在 <code>expensiveCalculate</code> 内执行带有副作用的操作，因为 <code>expensiveCalculate</code> 会在组件构造器的调用期间被执行。</p>
        </blockquote>
        <h3 id="4618caed-1e1c-4383-b295-a48d0a883202">dependency_array</h3>
        <pre><code class="language-jsx">/**
 * 方式一：
 * 挂载或更新组件时，
 *   - useMemo会执行expensiveCalculate函数。
 *   - useMemo会缓存expensiveCalculate的返回值，来作为cache。
 *   - useMemo会返回cache。
 */
const memoized_value = useMemo( function expensiveCalculate () {} );

/*
 * 方式二：
 * 挂载组件时：
 *   - useMemo会执行expensiveCalculate函数。
 *   - useMemo会缓存expensiveCalculate的返回值，来作为cache。
 *   - useMemo会返回cache。
 * 更新组件时：
 *   - useMemo会返回cache。
 */
const memoized_value = useMemo( function expensiveCalculate () {}, [] );

/**
 * 方式三：
 * 挂载组件时：
 *   - useMemo会执行expensiveCalculate函数。
 *   - useMemo会缓存expensiveCalculate的返回值，来作为cache。
 *   - useMemo会返回cache。
 * 更新组件时：
 *   - 如果state变量没有改变，那么useMemo就会返回cache。
 *   - 如果state变量发生了改变，那么useMemo就会重复挂载时的步骤。
 */
const memoized_value = useMemo( function expensiveCalculate () {}, [ state ] );
</code></pre>
        <p>通常，<code>state</code> 是指 <code>expensiveCalculate</code> 中使用到的变量。另外，React 使用 <code>Object.is</code> 来比较新旧 <code>state</code> 是否发生了变化。</p>
        <h2 id="a2cae887-1627-4e0e-82a1-565f3159655d">useCallback</h2>
        <p><code>useCallback</code> 用于创建函数的 memoized 版本。</p>
        <h3 id="c4cce8c2-32e5-489d-8488-73cdbe9273c5">语法</h3>
        <pre><code class="language-jsx">const memoizedCallback = useCallback( function callback () {}, dependency_array );
</code></pre>
        <ul>
            <li><code>memoizedCallback</code> 函数就是 <code>callback</code> 函数。</li>
            <li><code>dependency_array</code> 数组用于决定是否使用当前的 <code>callback</code> 来更新 <code>memoizedCallback</code>。</li>
        </ul>
        <blockquote>
            <p><strong>Note</strong></p>
            <p><code>useCallback( callback, dependency_Array )</code> 相当于 <code>useMemo( _ =&gt; callback, dependency_array )</code>。</p>
        </blockquote>
        <h3 id="1bb46e4c-e5eb-483f-8106-de4e5863d06d">dependency_array</h3>
        <pre><code class="language-jsx">/**
 * 方式一：
 * 挂载或更新组件时：
 *   - useCallback会缓存callback函数，来作为cache。
 *   - useCallback会返回cache。
 */
const memoizedCallback = useCallback(
    function callback () {},
);

/*
 * 方式二：
 * 挂载组件时：
 *   - useCallback会缓存callback函数，来作为cache。
 *   - useCallback会返回cache。
 * 更新组件时：
 *   - useCallback会返回cache。
 */
const memoizedCallback = useCallback(
    function callback () {},
    [],
);

/**
 * 方式三：
 * 挂载组件时：
 *   - useCallback会缓存callback函数，来作为cache。
 *   - useCallback会返回cache。
 * 更新组件时：
 *   - 如果state变量没有改变，那么useCallback就会返回cache。
 *   - 如果state变量发生了改变，那么useCallback就会重复挂载时的步骤。
 */
const memoizedCallback = useCallback(
    function callback () {},
    [ state ],
);
</code></pre>
        <p>通常，<code>state</code> 是指 <code>callback</code> 中使用到的变量。另外，React 使用 <code>Object.is</code> 来比较新旧 <code>state</code> 是否发生了变化。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>另外，因为 <code>useReducer</code> 所返回的 <code>dispatch</code> 是 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">稳定的、不会改变的</a>，所以哪怕我们在 <code>callback</code> 函数中使用了 <code>dispatch</code> 函数，我们也不需要将其添加进 <code>dependency_array</code>。</p>
        </blockquote>
        <h3 id="6b3db56a-7bf1-494d-9990-0a035dbab615">与 useEffect 一起使用</h3>
        <p>如果 <code>useEffect</code> 的 <code>dependency_array</code> 中包含了一个函数，那么你可能就会需要使用 <code>useCallback</code> 来创建该函数的 memoized 版本，详见下例。</p>
        <pre><code class="language-jsx">function Counter ( property ) {

    const [ count, setCount ] = useState( 0 );

    /* 挂载时，React会执行effect函数。 */
    /* 更新时，React会执行effect函数 */
    const printCountEverytime =  _ =&gt; console.log( count );
    useEffect( _ =&gt; printCountEverytime(), [ printCountEverytime ] );

    /* 挂载时，React会执行effect函数。 */
    /* 更新时，如果count变量没有改变，那么React就不会执行effect函数，否则就会执行。 */
    const printCountSometime = useCallback( _ =&gt; console.log( count ), [ count ] );
    useEffect( _ =&gt; printCountSometime(), [ printCountSometime ] );

}
</code></pre>
        <h2 id="1736457d-04ee-4073-bb44-03d4ae7ea139">useImperativeHandle</h2>
        <p><code>React.useImperativeHandle</code> 需要和 <code>React.forwardRef</code> 搭配在一起来使用，因为它的作用是让开发者自由的决定应该暴露什么内容给 <code>Parent</code> 组件的 <code>reference</code>。</p>
        <h3 id="1850f73f-018c-499a-8d9d-2f126408c5a3">语法</h3>
        <pre><code class="language-jsx">const Child = React.forwardRef( function Child ( property, reference ) {

    React.useImperativeHandle(
        reference,
        _ =&gt; reference_current_value,
    );

} );
</code></pre>
        <p><code>React.useImperativeHandle</code> 接收 2 个入参：</p>
        <ul>
            <li>第一个参数：组件的第二个参数 <code>reference</code></li>
            <li>第二个参数：一个无参函数，它的返回值将会作为 <code>reference</code> 的 <code>current</code> 属性的值。</li>
        </ul>
        <h3 id="5dfa919d-1f09-4bf0-881a-5a0ac00f221e">示例</h3>
        <p>该示例演示了：<code>Child</code> 组件仅向 <code>Parent</code> 组件暴露 <code>input</code> 元素的 <code>focus</code> 方法，而不暴露 <code>input</code> 元素本身。</p>
        <pre><code class="language-jsx">function Parent () {

    const parent_reference = React.useRef();

    return &lt;Child ref={ parent_reference }/&gt;;

}

const Child = React.forwardRef( function Child ( property, parent_reference ) {

    const child_reference = React.useRef();

    React.useImperativeHandle(
        parent_reference,
        _ =&gt; ( { focus: _ =&gt; child_reference.current.focus() } ),
    );

    return &lt;input ref={ child_reference }/&gt;;

} );
</code></pre>
        <h3 id="cd844d65-3ace-42a1-a25b-5e7fd8c7d8a8">polyfill</h3>
        <pre><code class="language-jsx">const Child = React.forwardRef( function Child ( property, parent_reference ) {

    return &lt;input ref={ refCallback }/&gt;;

    function refCallback ( dom ) {

        parent_reference.current = { focus: _ =&gt; dom?.focus() };

    }

} );
</code></pre>
        <p>Kent C. Dodds 说：虽然这是可以运行的，但是它在极少数情况下会产生 bug，所以还是推荐使用 <code>React.useImperativeHandle</code>。</p>
        <h2 id="c5f8fcae-50ff-4193-a8b3-49644ee725cb">useDebugValue</h2>
        <p><code>React.useDebugValue</code> 用于给 custom hook 添加标签，当 custom hook 被多个组件多次使用时，你可以通过标签来区分出每一个 custom hook。</p>
        <p>另外，你只能通过控制台的 <code>⚛️Components</code> 项来看到 custom hook 的标签，如果浏览器没有安装 React Developer Tools 插件，那么控制台就没有 <code>⚛️Components</code> 项。</p>
        <h3 id="2b855a66-d1bf-40eb-9ccc-4a94e0bd2477">语法</h3>
        <pre><code class="language-jsx">/* 语法一 */
function useMyHook () {

    React.useDebugValue( tag );

}

/* 语法二 */
function useMyHook () {

    React.useDebugValue( tag, function format ( tag ) { return tag } );

}
</code></pre>
        <ul>
            <li>第一个参数：必选的，允许任意数据类型。<ul>
                    <li>如果没有传递第二个参数，那么该参数就会成为 custom hook 的标签。</li>
                    <li>如果传递了第二个参数，那么该参数就会作为入参传递给第二个参数。</li>
                </ul>
            </li>
            <li>第二个参数：可选的，只允许函数或 <code>undefined</code>。<ul>
                    <li>如果该参数是 <code>undefined</code>，那么就等同于没有传递该参数。</li>
                    <li>如果该参数是一个函数，那么第一个入参就会作为该函数的入参，该函数的返回值将会作为 custom hook 的标签，且仅当控制台激活时，该函数才会被调用。</li>
                </ul>
            </li>
        </ul>
        <h3 id="e5d66913-8bbb-4c08-9c1b-6f06777397a8">延迟创建标签</h3>
        <p>对于产品的用户而言，创建 custom hook 的标签是一种浪费性能的行为，因为产品的用户不需要查看 custom hook 的标签。当 <code>React.useDebugValue</code> 的入参 <code>tag</code> 需要耗时的计算才能获得时，这种浪费便尤为严重。</p>
        <p>为了解决这个问题，React 官方为 <code>React.useDebugValue</code> 提供了第二种语法，我个人倾向于在所有情况下都使用这种语法。</p>
        <h3 id="3896a667-37f8-4299-8cf8-1335aa4a056e">示例</h3>
        <p>下例展示了如何创建、查看 custom hook 的标签。</p>
        <p><img src=/static/image/markdown/javascript/react-api-manual/usedebugvalue.png alt=React.useDebugValue loading="lazy" decoding="async"></p>
        <pre><code class="language-jsx">function App () {

    return (
        &lt;&gt;
            &lt;Counter initial={ 10 } step={ 1 }/&gt;
            &lt;Counter initial={ 20 } step={ 2 }/&gt;
        &lt;/&gt;
    );

}

function useCount ( initial, step ) {

    React.useDebugValue( { initial, step }, parameter =&gt; parameter );

    const [ count, setCount ] = React.useState( initial );
    const increase = _ =&gt; setCount( count + step );

    return [ count, increase ];

}

function Counter ( property ) {

    const { initial, step } = property;
    const [ count, increase ] = useCount( initial, step );

    return &lt;button onClick={ increase }&gt;{ count }&lt;/button&gt;;

}
</code></pre>
        <h2 id="e2dca137-7939-4182-aacf-cab927f32552">Custom Hook</h2>
        <p>custom hook 是一个用于封装 hook 的函数，并且 React 要求 custom hook 的命名必须以 <code>use</code> 开头。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>React 要检查 custom hook 内的 hook 使用是否符合规范，为了方便分辨出哪些函数才是 custom hook，React 便要求 custom hook 的命名必须以 <code>use</code> 开头。</p>
        </blockquote>
        <h3 id="5f6ea4c2-2e62-4172-a5d6-9172dd9b2ee3">示例</h3>
        <pre><code class="language-jsx">function Name () {

    const [ name, setName ] = useLocalStorageState( &quot;name&quot;, &quot;Jynxio&quot; );

    return &lt;input value={ name } onChange={ event =&gt; setName( event.target.value ) } /&gt;;

}

function useLocalStorageState ( key, initial_value ) {

    const [ state, setState ] = React.useState(
        JSON.parse( globalThis.localStorage.getItem( key ) ) || initial_value
    );

    React.useEffect( _ =&gt; {

        globalThis.localStorage.setItem( key, JSON.stringify( state ) );

        return _ =&gt; globalThis.localStorage.removeItem( key );

    }, [ key, state ] );

    return [ state, setState ];

}
</code></pre>
        <h3 id="295dfb67-6365-4d4b-a136-ff102099e81b">原理</h3>
        <p>为了减少代码的冗余或增强代码的可读性，我们会把代码从原处提取出来，封装到一个函数中去，custom hook 就是这么一种产物，只不过其内的代码包含了 hook 而已。</p>
        <p>所以 custom hook 和普通函数其实没有本质的区别，在组件内调用一个 custom hook 就和调用一个普通函数一样。</p>
        <p>不过需要提醒的是，在 custom hook 内，用 <code>useState</code> 所创建出来的状态不是跟随 custom hook 的，而是跟随调用 custom hook 的组件的，其他的内建 hook 也同理。之所以会有这种现象，我猜测是因为由 <code>useState</code> 所创建出来的状态会自动吸附到组件上。</p>
        <h2 id="003aa5b5-f178-4f93-8997-496ada8f919e">ref property</h2>
        <p>React 元素具有一个 <code>ref</code> 属性，<code>ref</code> 属性用于捕获元素节点，它有 2 种调用方式：</p>
        <pre><code class="language-jsx">/* 方式一 */
&lt;div ref={ { current: undefined } }&gt;&lt;/div&gt;

/* 方式二 */
&lt;div ref={ element =&gt; {} }&gt;&lt;/div&gt;
</code></pre>
        <h3 id="aa0d9aba-e4ee-43d4-9749-47d3aa3e3c08">方式一</h3>
        <p><code>ref</code> 属性可以接收一个 <code>{ current: * }</code> 格式的普通对象，此时其运行机制如下：</p>
        <ul>
            <li>React 会在创建了 <code>div</code> 元素之后，将 <code>div</code> 元素赋值给 <code>current</code> 属性。</li>
            <li>React 会在移除了 <code>div</code> 元素之后，将 <code>null</code> 赋值给 <code>current</code> 属性。</li>
        </ul>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>直至调用了 <code>ReactDOM.createRoot( dom ).render</code> 方法之后，React 才会创建 DOM 元素。</p>
        </blockquote>
        <p>如果把 <code>useRef</code> 的返回值传递给 <code>ref</code> 属性，那么我们就可以持久的存储 DOM 元素了：</p>
        <pre><code class="language-jsx">function Component () {

    const reference = useRef();

    return &lt;div ref={ reference }&gt;&lt;/div&gt;

}
</code></pre>
        <h3 id="33a62294-7c8c-466d-8d48-fb5213a4ced4">方式二</h3>
        <p><code>ref</code> 属性也可以接收一个函数，我们把这个函数称为 <code>refCallback</code>，此时其运行机制如下：</p>
        <ul>
            <li>React 会在创建了 <code>div</code> 元素之后，调用 <code>refCallback</code> 函数，并将 <code>div</code> 元素作为入参传递给 <code>refCallback</code>。</li>
            <li>React 会在移除了 <code>div</code> 元素之后，调用 <code>refCallback</code> 函数，并将 <code>null</code> 作为入参传递给 <code>refCallback</code>。</li>
        </ul>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>如果 React 更新了组件，那么 React 就会创建一个新的 <code>div</code> 元素来替代旧的 <code>div</code> 元素，这意味着 React 将会调用两次 <code>refCallback</code>，第一次调用是因为移除了旧的 <code>div</code> 元素，第二次调用时因为创建了新的 <code>div</code> 元素。</p>
        </blockquote>
        <h2 id="1af8936e-bfb0-470d-8155-8fc3c610f799">forwardRef</h2>
        <p>React 不允许通过下述方式来在 <code>Parent</code> 组件中获取 <code>Child</code> 组件的 DOM，因为 React 认为这是一种不安全的编程范式。</p>
        <pre><code class="language-jsx">function Parent () {
    
    const reference = useRef();
    
    return &lt;Child ref={ reference }/&gt;; // Error
    
}
</code></pre>
        <p>不过，React 提供了另一种途径来获取 <code>Child</code> 组件的 DOM，那就是 <code>React.forwardRef</code>，详见下文。</p>
        <h3 id="34512987-0d45-4aa9-a200-3077a50eec9e">语法</h3>
        <pre><code class="language-jsx">function Parent () {

    const reference = useRef();

    return &lt;Child ref={ reference }/&gt;

}

const Child = React.forwardRef( function Child ( property, reference ) {

    return &lt;div ref={ reference }&gt;&lt;/div&gt;;

} );
</code></pre>
        <h3 id="e6380c02-e2d8-4772-8218-62f17b29fbb6">原理</h3>
        <p>无论组件是否经过了 <code>React.forwardRef</code> 的改造，它们都总是可以接收到第二个参数 <code>reference</code>。只不过，如果组件没有经过 <code>React.forwardRef</code> 的改造，那么它的第二个参数 <code>reference</code> 就总是一个空对象 <code>{}</code>。</p>
        <p><code>React.forwardRef</code> 就像一个开关，仅当组件经过了它的改造之后，组件的 <code>reference</code> 参数才能接收到上游的数据。</p>
        <pre><code class="language-jsx">function Child ( property, reference ) {

    console.log( reference );  // {}

}
</code></pre>
        <h3 id="8b685e2b-e710-41ef-9221-47239b7b3c7b">polyfill</h3>
        <pre><code class="language-jsx">function Parent () {

    const reference = useRef();

    return &lt;Child secret={ reference }/&gt;

}

function Child ( property ) {

    return &lt;div ref={ property.secret }&gt;&lt;/div&gt;

}
</code></pre>
        <h2 id="19375a9d-458f-42e5-945e-3b77f6c3696a">flushSync</h2>
        <p><code>flushSync</code> 用于让 React 立即更新 DOM，它来自于 <code>react-dom</code>。</p>
        <h3 id="aaa6a651-6105-4d70-b7cc-9641fa64c886">语法</h3>
        <p><code>flushSync</code> 接收并立即执行一个回调函数，待回调函数执行结束之后，React 就会立即更新 DOM。</p>
        <pre><code class="language-jsx">import { flushSync } from &quot;react-dom&quot;;

flushSync( _ =&gt; {} );
</code></pre>
        <h3 id="e597a5ec-8f46-4b08-8b56-83736715e55c">示例</h3>
        <p><code>(1)</code> 会同步的更新组件，并在更新好后立即更新 DOM，所以挂载或卸载 <code>div</code> 元素之后，<code>(2)</code> 行代码总是可以正确的输出 <code>div</code> 元素或 <code>null</code>。</p>
        <pre><code class="language-jsx">function Component () {

    const reference = useRef();
    const [ visible, setVisible ] = useState( false );

    function handleClick () {

        flushSync( _ =&gt; setVisible( ! visible ) ); // (1)

        console.log( reference.current );          // (2)

    }

    return (
        &lt;&gt;
            &lt;button onClick={ handleClick }&gt;reverse&lt;/button&gt;
            &lt;div ref={ reference }&gt;&lt;/div&gt;
        &lt;/&gt;
    );

}
</code></pre>
        <h2 id="41bf74f2-6e58-4ff4-b266-7dbba30620a3">Error Boundary</h2>
        <p>error boundary 是指定义了 <code>getDerivedStateFromError</code> 或 <code>componentDidCatch</code> 方法的 class 组件。</p>
        <p>一旦 error boundary 组件的后代组件发生了崩溃，那么这个崩溃就会冒泡至 error boundary 组件，这时 Reacy 就会依次调用 error boundary 组件的 <code>getDerivedStateFromError</code>、<code>render</code>、<code>componentDidCatch</code> 方法。而我们就可以通过操纵 <code>getDerivedStateFromError</code> 方法来渲染降级的 UI，用 <code>componentDidCatch</code> 方法来向服务器发送崩溃日志。</p>
        <p>如果 error boundary 组件的后代组件没有发生崩溃，那么 React 就不会调用 error boundary 的 <code>getDericedStateFromError</code> 和 <code>componentDidCatch</code> 方法。</p>
        <h3 id="b9d0ff08-aadb-4f65-ab88-3f5781d005fa">getDerivedStateFromError</h3>
        <p><code>getDerivedStateFromError</code> 是 error boundary 组件的静态方法，该方法先于 <code>render</code> 方法被调用。该方法接收一个入参 <code>error</code>，其代表后代组件所抛出的错误，而该方法的返回值会更新 error boundary 组件的 <code>state</code>。</p>
        <p>如果后代组件没有发生崩溃，React 就不会调用该方法。</p>
        <pre><code class="language-jsx">class ErrorBoundary {

    /*
     * @param { Error } - 后代组件所抛出的错误。
     * @returns { * }   - 该返回值会更新error boundary组件的state。
     */
    static getDerivedStateFromError ( error ) { return new_state }

}
</code></pre>
        <h3 id="2e95b5a5-ede3-4c4c-9855-cf8a707f862d">componentDidCatch</h3>
        <p><code>componentDidCatch</code> 是 error boundary 组件的原型方法，该方法后于 <code>render</code> 方法被调用。该方法接收 2 个入参，分别是 <code>error</code> 和 <code>information</code>，<code>error</code> 代表后代组件所抛出的错误，<code>information</code> 是一个带有 <code>componentStack</code> 属性的普通对象，<code>componentStack</code> 属性是一个字符串，该字符串记录了抛出错误的后代组件的栈信息。</p>
        <p>如果后代组件没有发生崩溃，React 就不会调用该方法。</p>
        <pre><code class="language-jsx">class ErrorBoundary {

    /*
     * @param { Error }  - 后代组件所抛出的错误。
     * @param { Object } - 抛出错误的后代组件的栈信息。
     */
    componentDidCatch ( error, information ) {}

}
</code></pre>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>在开发环境下，被 <code>componentDidCatch</code> 方法所捕获的错误会冒泡至浏览器根对象 <code>window</code>，而在生产环境下，则不会发生冒泡。</p>
        </blockquote>
        <h3 id="0dc9f589-df3f-4c46-9a85-f394fe47b81f">示例</h3>
        <pre><code class="language-jsx">class ErrorBoundary extends Component {

    constructor ( props ) {

        super( props );
        
        this.state = { error: undefined };

    }

    static getDerivedStateFromError ( error ) {

        /* 更新state。 */
        return { error };

    }

    componentDidCatch ( error, information ) {

        /* 反馈错误。 */
        postErrorToService( error.message );
        postErrorToService( information.componentStack );

    }

    render () {

        if ( ! this.state.error ) this.props.children;

        return &lt;pre&gt;{ this.state.error.message }&lt;/pre&gt;;

    }

}

function App () {

    return &lt;ErrorBoundary&gt;&lt;Bomb/&gt;&lt;/ErrorBoundary&gt;;

}

function Bomb () {

    throw new Error( &quot;Bomb!&quot; );

}
</code></pre>
        <h3 id="efeecb29-21d0-4e29-8108-7728d4fb773b">react-error-boundary</h3>
        <p><a href="https://github.com/bvaughn/react-error-boundary#readme">react-error-boundary</a> 是一个 <code>ErrorBoundary</code> 库，它可以让你免于手动编写 <code>ErrorBoundary</code> 类，并且它还提供了一些额外的特性。</p>
        <pre><code class="language-jsx">import { ErrorBoundary } from &quot;react-error-boundary&quot;;

function App () {

    const [ key, setKey ] = useState( 0 );
    const handleReset = _ =&gt; setKey( key + 1 ); // 重置ErrorBoundary组件。

    return (
        &lt;ErrorBoundary
            key={ key }
            onReset={ handleReset }
            FallbackComponent={ ErrorFallback }
        &gt;
            &lt;Bomb/&gt;
        &lt;/ErrorBoundary&gt;
    );

}

/*
 * ErrorBoundary的fallback函数。
 * @param { Error }    - 冒泡至ErrorBoundary的Error对象。
 * @param { Function } - ErrorBoundary的onReset参数的值。
 * @returns { * }      - 其返回值将会作为ErrorBoundary的getDerivedStateFromError方法的返回值。
 */
function ErrorFallback ( { error, resetErrorBoundary } ) {

    return (
        &lt;div&gt;
            &lt;pre&gt;{ error.message }&lt;/pre&gt;
            &lt;button onClick={ resetErrorBoundary }&gt;&lt;/button&gt;
        &lt;/div&gt;
    );

}

function Bomb () {

    throw new Error( &quot;Bomb!&quot; );

}
</code></pre>
    </article>
</body>

</html>