<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>运算符</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=4c7e15d9-93d4-4dea-9dd7-8fc101dffe78>汇总</p>
        <p data-target-id=53988003-35ce-4ec9-9f87-c96e8023b7ee>算术运算符</p>
        <p data-target-id=8ea73f9f-6309-4795-af17-7b8d90e47885>赋值运算符</p>
        <p data-target-id=92c5a30d-89aa-4ca9-b2b8-7022c5a76dd1>逻辑运算符</p>
        <p data-target-id=78b633f9-e0b5-4369-b769-d7b1d1c8a90d>一元运算符</p>
        <p data-target-id=d33c8eac-c896-4d42-9514-37dc2d988983>三元运算符</p>
        <p data-target-id=f8ebc703-05b3-479d-a57b-8975f719095e>比较运算符</p>
        <p data-target-id=455e24a5-fcee-400f-896e-61badc2c4db4>逗号运算符</p>
        <p data-target-id=ed0d82d3-23d7-4f17-bf4e-2fac02204162>可选链运算符</p>
        <p data-target-id=517e4fc3-c897-4bc9-bbef-b99eff14fbe0>in 运算符</p>
        <p data-target-id=edc6cd5f-d43f-43f9-abe5-f225bc04e3ed>instanceof 运算符</p>
        <p data-target-id=bd73cc64-e965-4e40-a1a8-46a93c180983>位运算符</p>
    </aside>
    <article>
        <h1>运算符</h1>
        <h2 id="4c7e15d9-93d4-4dea-9dd7-8fc101dffe78">汇总</h2>
        <p>参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#%E6%B1%87%E6%80%BB%E8%A1%A8">MDN-运算符优先级-汇总表</a>。</p>
        <h2 id="53988003-35ce-4ec9-9f87-c96e8023b7ee">算术运算符</h2>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>加</td>
                    <td><code>+</code></td>
                    <td>求幂</td>
                    <td><code>**</code></td>
                </tr>
                <tr>
                    <td>减</td>
                    <td><code>-</code></td>
                    <td>自增</td>
                    <td><code>++</code></td>
                </tr>
                <tr>
                    <td>乘</td>
                    <td><code>*</code></td>
                    <td>自减</td>
                    <td><code>--</code></td>
                </tr>
                <tr>
                    <td>除</td>
                    <td><code>/</code></td>
                    <td>一元正值符</td>
                    <td><code>+</code></td>
                </tr>
                <tr>
                    <td>取余</td>
                    <td><code>%</code></td>
                    <td>一元负值符</td>
                    <td><code>-</code></td>
                </tr>
            </tbody>
        </table>
        <p>算数运算符会对左右运算元进行算数运算，然后返回一个数字值，不是数字值的运算元会在运算开始前被隐式的转换为数字值（加法例外），下文是转换规则：</p>
        <ul>
            <li>对于二元加法运算符，若左、右运算元都不是 <code>String</code> ，则非 <code>Number</code> 的运算元会被转换为 <code>Number</code></li>
            <li>对于二元加法运算符，若有至少一个运算元是 <code>String</code> ，则非 <code>String</code> 的运算元会被转换为 <code>String</code> </li>
            <li>对于其它算术运算符，所有非 <code>Number</code> 的运算元都会被转换为 <code>Number</code></li>
        </ul>
        <h3 id="c0f742ae-a011-4e65-b749-693a20e8d665">求幂</h3>
        <p>以左运算元为底数，以右运算元为指数，返回它们的乘方。注意，该运算符的关联性是从右到左，因此 <code>2 ** 2 ** 3</code> 等价于 <code>2 ** (2 ** 3)</code>，不等价于 <code>(2 ** 2) ** 3</code> 。</p>
        <h3 id="9cca0abd-5e41-4d1b-8c69-e19ac02a3154">自增 和 自减</h3>
        <p>对于前置自增，先令运算元自增 <code>1</code> ，再返回运算元的值。对于后置自增，先返回运算元的值，再令运算元自增 <code>1</code> 。自减运算符同理。</p>
        <h3 id="9ccd27dd-b6f1-4d6a-a2b1-541da0901b95">加法</h3>
        <p>对于二元加法运算符，若有至少一个运算元是 <code>String</code> ，则非 <code>String</code> 的运算元会被隐式转换为 <code>String</code> ，然后再进行字符串的连接，最后返回连接的结果。</p>
        <h2 id="8ea73f9f-6309-4795-af17-7b8d90e47885">赋值运算符</h2>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>描述</th>
                    <th>返回值</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>普通赋值</td>
                    <td><code>=</code></td>
                    <td>将右运算元的值分配给左运算元</td>
                    <td>右运算元的值</td>
                </tr>
                <tr>
                    <td>加赋值</td>
                    <td><code>+=</code></td>
                    <td><code>a += b</code> 等价于 <code>a = a + b</code></td>
                    <td><code>a + b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>减赋值</td>
                    <td><code>-=</code></td>
                    <td><code>a -= b</code> 等价于 <code>a = a - b</code></td>
                    <td><code>a - b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>乘赋值</td>
                    <td><code>*=*</code></td>
                    <td><code>a *= b</code> 等价于 <code>a = a * b</code></td>
                    <td><code>a * b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>除赋值</td>
                    <td><code>/=</code></td>
                    <td><code>a /= b</code> 等价于 <code>a = a / b</code></td>
                    <td><code>a / b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>取余赋值</td>
                    <td><code>%=</code></td>
                    <td><code>a %= b</code> 等价于 <code>a = a % b</code></td>
                    <td><code>a % b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>求幂赋值</td>
                    <td><code>**=</code></td>
                    <td><code>a **= b</code> 等价于 <code>a = a ** b</code></td>
                    <td><code>a ** b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>逻辑与赋值</td>
                    <td><code>&amp;&amp;=</code></td>
                    <td><code>a &amp;&amp;= b</code> 等价于 <code>a &amp;&amp; (a = b)</code></td>
                    <td><code>a</code> 最终的值</td>
                </tr>
                <tr>
                    <td>逻辑或赋值</td>
                    <td>`</td>
                    <td></td>
                    <td>=`</td>
                </tr>
                <tr>
                    <td>逻辑空赋值</td>
                    <td><code>??=</code></td>
                    <td><code>a ??= b</code> 等价于 <code>a ?? (a = b)</code></td>
                    <td><code>a</code> 最终的值</td>
                </tr>
            </tbody>
        </table>
        <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN-运算符优先级</a> 明确表示：“赋值运算符的返回结果就是赋值运算符右边的那个值”。通过下述例子亦可佐证该观点：</p>
        <pre><code class="language-js">let a, b;

( a = b ) = 1; // Error: Uncaught SyntaxError: Invalid left-hand side in assignment
</code></pre>
        <p>因为 <code>a = b</code> 的返回值是变量 <code>b</code> 的值而不是变量 <code>b</code>，所以才会抛出 <code>Invalid left-hand</code>。</p>
        <p>逻辑与赋值的定义是：若左运算元为 <code>truthy</code>，则将右运算元的值赋予左运算元，否则不进行赋值操作。因为逻辑与赋值具有短路计算的特性，因此 <code>a &amp;&amp;= b</code> 才会等价于 <code>a &amp;&amp; ( a = b )</code> ，而不是 <code>a = a &amp;&amp; b</code>，因为前者才符合短路计算的特性。对于逻辑或赋值、逻辑空赋值也是同理的。</p>
        <h2 id="92c5a30d-89aa-4ca9-b2b8-7022c5a76dd1">逻辑运算符</h2>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>语法</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>逻辑与</td>
                    <td><code>&amp;&amp;</code></td>
                    <td><code>a &amp;&amp; b</code></td>
                    <td>若 <code>a</code> 的布尔值为 <code>true</code> ，则返回 <code>b</code> 的初始值；<br />若 <code>a</code> 的布尔值为 <code>false</code> ，则返回 <code>a</code> 的初始值，忽略 <code>b</code>；</td>
                </tr>
                <tr>
                    <td>逻辑或</td>
                    <td>`</td>
                    <td></td>
                    <td>`</td>
                </tr>
                <tr>
                    <td>逻辑非</td>
                    <td><code>!</code></td>
                    <td><code>!a</code></td>
                    <td>若 <code>a</code> 的布尔值为 <code>true</code> ，则返回 <code>false</code> ；<br />否则返回 <code>true</code> ；</td>
                </tr>
                <tr>
                    <td>逻辑空</td>
                    <td><code>??</code></td>
                    <td><code>a ?? b</code></td>
                    <td>若 <code>a</code> 的初始值为 <code>null</code> 或 <code>undefined</code> ，则返回 <code>b</code> 的初始值；<br />否则返回 <code>a</code> 的初始值，忽略 <code>b</code> ；</td>
                </tr>
            </tbody>
        </table>
        <p>注意，<code>a</code> 和 <code>b</code> 是变量或表达式，变量的初始值就是变量的值，表达式的初始值就是表达式的计算结果。</p>
        <h3 id="88ae32f3-44fc-4b8b-a11c-07c598042810">逻辑或</h3>
        <p>从左向右逐个检查运算元，然后返回首个 <code>truthy</code> 运算元的初始值，并忽略剩余的运算元。若一直没有找到 <code>truthy</code> 运算元，则返回最后那个运算元的初始值。比如对于 <code>a &amp;&amp; b &amp;&amp; c</code> ，JavaScript 引擎会这么做：</p>
        <ol>
            <li>从左向右逐个检查运算元；</li>
            <li>若当前运算元的初始值的数据类型不是布尔类型，则将其隐式转换为布尔类型；</li>
            <li>若当前运算元的布尔值为 <code>true</code> ，则立即返回当前运算元的初始值，并忽略剩余的运算元；</li>
            <li>若所有运算元的布尔值为 <code>false</code> ，则返回最后那个运算元的初始值；</li>
        </ol>
        <h3 id="40ebe6fa-365e-4682-bd27-03ae7f65998e">逻辑与</h3>
        <p>从左向右逐个检查运算元，返回首个 <code>falsy</code> 运算元的初始值，并忽略剩余的运算元。若一直没有找到 <code>falsy</code> 运算元，则返回最后那个运算元的初始值。</p>
        <h3 id="82a1ffc4-1112-4bda-8780-2002c674c681">逻辑空</h3>
        <p>逻辑空又被称为空值合并运算符，它的执行逻辑很简单，即：如果左运算元的值为 <code>null</code> 或 <code>undefined</code>，则返回右运算元的值，否则就返回左运算元的值。</p>
        <p>另外，ECMAScript 规定如果没有明确的添加圆括号，就不能混合使用 <code>??</code> 和 <code>||</code>，也不能混合使用 <code>??</code> 和 <code>&amp;&amp;</code>。</p>
        <pre><code class="language-js">1 &amp;&amp; 2 ?? 3; // Syntax error: Unexpected token &#39;??&#39;
1 || 2 ?? 3; // Syntax error: Unexpected token &#39;??&#39;

( 1 &amp;&amp; 2 ) ?? 3; // 2
( 1 || 2 ) ?? 3; // 1
</code></pre>
        <p>为了弥补 <code>||</code> 的缺憾，所以语言规范的制定者创造了 <code>??</code>，不过制定者们认为人们在将 <code>||</code> 切换为 <code>??</code> 的时候容易引发错误，所以制定者们才额外添加了上文的限制措施。</p>
        <h3 id="69be4b2b-f052-4189-bf52-77936a4bd1b9">短路计算</h3>
        <p><code>&amp;&amp;</code> 、 <code>||</code> 、 <code>??</code> 具有能够忽略运算元的特性， “运算元被忽略” 是指该运算元没有被执行，因此被忽略的运算元中的错误、副作用、函数调用等都不会被触发。这种忽略运算元的行为被称为短路计算。短路计算常用于简化判断语句，但它也会降低代码的可读性。</p>
        <pre><code class="language-js">if ( 1 &gt; 0 ) console.log( true );
/* equal to */
1 &gt; 0 &amp;&amp; console.log( true );
</code></pre>
        <h2 id="78b633f9-e0b5-4369-b769-d7b1d1c8a90d">一元运算符</h2>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>语法</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>一元加法</td>
                    <td><code>+</code></td>
                    <td><code>+a</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>一元减法</td>
                    <td><code>-</code></td>
                    <td><code>-a</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>逻辑非</td>
                    <td><code>!</code></td>
                    <td><code>!a</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>按位非</td>
                    <td><code>~</code></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>void</td>
                    <td><code>void</code></td>
                    <td><code>void a</code> 或 <code>void (a)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>typeof</td>
                    <td><code>typeof</code></td>
                    <td><code>typeof a</code> 或 <code>typeof (a)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>delete</td>
                    <td><code>delete</code></td>
                    <td><code>delete a</code></td>
                    <td></td>
                </tr>
            </tbody>
        </table>
        <h3 id="dd150fd9-287e-4eee-a333-30a3b1989f6a">void</h3>
        <p>执行右运算元，然后返回 <code>undefined</code>，它的语法是：</p>
        <pre><code class="language-js">void expression;
void ( expression );
</code></pre>
        <p>使用 <code>void</code> 来构造的 IIFE 会稍微安全一些，因为它的返回值总是 <code>undefined</code>：</p>
        <pre><code class="language-js">void function iife(){}();
</code></pre>
        <p><code>void</code> 还能用来构造无响应的超链接标签，比如：</p>
        <pre><code class="language-html">&lt;a href=&quot;javascript: void 0;&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;javascript: void(0);&quot;&gt;&lt;/a&gt;
</code></pre>
        <h3 id="387b3ca0-a053-4773-af32-f59fc0f29624">typeof</h3>
        <p>返回一个表示右运算元的数据类型的字符串，它的语法是：</p>
        <pre><code class="language-js">typeof a;
typeof ( a );
</code></pre>
        <table>
            <thead>
                <tr>
                    <th>数据类型</th>
                    <th>返回值</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>Undefined</code></td>
                    <td><code>&quot;undefined&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Null</code></td>
                    <td><code>&quot;object&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Boolean</code></td>
                    <td><code>&quot;boolean&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Number</code></td>
                    <td><code>&quot;number&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Bigint</code></td>
                    <td><code>&quot;bigint&quot;</code></td>
                </tr>
                <tr>
                    <td><code>String</code></td>
                    <td><code>&quot;string&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Symbol</code></td>
                    <td><code>&quot;symbol&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Function</code></td>
                    <td><code>&quot;function&quot;</code></td>
                </tr>
                <tr>
                    <td>宿主对象（如 <code>window</code> 、 <code>document</code> ）</td>
                    <td>取决于浏览器的实现</td>
                </tr>
                <tr>
                    <td>其它对象</td>
                    <td><code>&quot;object&quot;</code></td>
                </tr>
                <tr>
                    <td>未声明的变量</td>
                    <td><code>&quot;undefined&quot;</code></td>
                </tr>
            </tbody>
        </table>
        <p>其中，<code>typeof null</code> 的返回值是 <code>&#39;object&#39;</code> ，这是一个历史遗留错误。</p>
        <h3 id="d1b42666-dfaf-4229-a5ff-c0087e059d87">delete</h3>
        <p>删除对象自身的指定属性，但不会删除对象原型链上的同名属性，它的语法时是：</p>
        <pre><code class="language-js">delete obj.prop;
delete obj[expr];
</code></pre>
        <p>它有 2 种返回值，分别是：</p>
        <ul>
            <li><code>false</code> ：若 <code>delete</code> 不可配置的属性，则会返回该值，且在非严格模式下，该操作将静默失败，在严格模式下，该操作将会抛出错误。</li>
            <li><code>true</code> ：其余情况都返回 <code>true</code>。</li>
        </ul>
        <h4 id="8dde67fc-47b9-4502-9964-791b02260aea">delete 不存在的属性</h4>
        <p><code>delete</code> 不存在的属性也会返回 <code>true</code> ，且被操作的对象没有任何变化。</p>
        <pre><code class="language-js">delete {}.a; // true
</code></pre>
        <h4 id="39ba0737-0ef6-4a7d-afaf-5c4a52da09b9">delete 由 var、let、const、function 生命的变量</h4>
        <p>在任何作用域内，由声明关键字声明的变量都是某个对象的不可配置的属性，而不经声明就直接赋值来创建的变量则是某个对象的可配置的属性。因此，<code>delete</code> 前者将会返回 <code>false</code>，<code>delete</code> 后者将会返回 <code>true</code>，比如：</p>
        <pre><code class="language-js">var a = 1;
Object.getOwnPropertyDescriptor(window, &quot;a&quot;).configurable; // false
</code></pre>
        <pre><code class="language-js">a = 1;
Object.getOwnPropertyDescriptor(window, &quot;a&quot;).configurable; // true
</code></pre>
        <pre><code>
</code></pre>
        <h4 id="29ee5bde-114a-4d7f-83cb-dd1222ab956c">delete 数组元素</h4>
        <p><code>delete</code> 一个数组的元素，就会清空这个元素的内容，但不会释放掉这个元素所占据的内存空间，被 <code>delete</code> 后的元素的值为 <code>undefined</code> ，意义为 empty 。数组的长度不会改变，其它元素的下标也不会重排。</p>
        <pre><code class="language-js">const a = [ 1, 2 ];
delete a[ 0 ];
a;      // [ empty, 2 ]
a[ 0 ]; // undefined
</code></pre>
        <h2 id="d33c8eac-c896-4d42-9514-37dc2d988983">三元运算符</h2>
        <p>又被称为条件运算符，它的语法是：</p>
        <pre><code class="language-js">condition ? expr_1 : expr_2;
</code></pre>
        <p>若 <code>condition</code> 的 truthy 为 <code>true</code>，则执行 <code>expr_1</code>，且忽略 <code>expr_2</code>，最后返回 <code>expr_1</code> 的初始值。否则忽略 <code>expr_1</code>，执行 <code>expr_2</code>，最后返回 <code>expr_2</code> 的初始值。</p>
        <p>注意，非表达式的语法结构不能作为三元运算符的运算元，比如函数内部的 <code>return</code>，循环体内的 <code>break</code> 和 <code>continue</code>。</p>
        <h2 id="f8ebc703-05b3-479d-a57b-8975f719095e">比较运算符</h2>
        <p>所有比较运算符均会返回布尔值。</p>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>严格相等</td>
                    <td><code>===</code></td>
                    <td>严格不相等</td>
                    <td><code>!==</code></td>
                    <td>大于</td>
                    <td><code>&gt;</code></td>
                    <td>大于或等于</td>
                    <td><code>&gt;=</code></td>
                </tr>
                <tr>
                    <td>宽松相等</td>
                    <td><code>==</code></td>
                    <td>宽松不相等</td>
                    <td><code>!=</code></td>
                    <td>小于</td>
                    <td><code>&lt;</code></td>
                    <td>小于或等于</td>
                    <td><code>&lt;=</code></td>
                </tr>
            </tbody>
        </table>
        <h3 id="dd6c2e83-2d15-4fcb-8dff-3e7faaae9679">字符串之间的比较</h3>
        <p>JavaScript 会根据字符串的 Unicode 来比较字符串的大小，具体来说是：</p>
        <ol>
            <li>首先比较左右运算元的首位字符的 Unicode，该 Unicode 更大的运算元更大。</li>
            <li>如果左右运算元的首位字符的 Unicode 一样大，那么就比较第二位字符的 Unicode，该 Unicode 更大的运算元更大。</li>
            <li>如果左右运算元的第二位字符的 Unicode 一样大，那么就比较第三位字符的 Unicode，该 Unicode 更大的运算元更大。</li>
            <li>......</li>
            <li>如果左右运算元的字符都同时用完了，且还没能分出大小，那么就判定左右运算元相等。</li>
            <li>如果某一个运算元的字符已经用完了，且另一个运算元还有字符没用完，那么后者更大。</li>
        </ol>
        <pre><code class="language-js">&quot;A&quot; &lt; &quot;Z&quot;;    // true
&quot;Z&quot; &lt; &quot;a&quot;;    // true
&quot;aa&quot; &lt; &quot;ab&quot;;  // true
&quot;ab&quot; &lt; &quot;abb&quot;; // true
</code></pre>
        <h3 id="049bed3d-6caa-4717-add2-e2fbbacad591">不同原始类型之间的比较</h3>
        <p>严格相等运算符（<code>===</code>）会比较左右运算元的数据类型与值，只有当它们的数据类型与值均相等时，它们才相等。严格不相等运算符（<code>!==</code>） 也会比较左右运算元的数据类型与值，只要数据类型或值不相等，那么它们就不相等。</p>
        <p>对于其他的比较运算符，如果左右运算元的数据类型不一致，那么 JavaScript 就会把左右运算元都隐式转换为数字值之后再进行比较。</p>
        <pre><code class="language-js">2 &gt; &quot;1&quot;;     // true，其中 &quot;1&quot; -&gt; 1
2 &gt; false;   // true，其中 false -&gt; 0
&quot;1&quot; &gt; false; // true，其中 false -&gt; 0，&quot;1&quot; -&gt; 1
&quot;&quot; == false; // true，其中 false -&gt; 0，&quot;&quot; -&gt; 0
</code></pre>
        <h3 id="db63c9d8-9797-4f81-8c7f-b7c1298bdd91">null 和 undefined</h3>
        <p>对于 <code>==</code> 和 <code>!==</code>，<code>null</code> 和 <code>undefined</code> 不会进行类型转换，并且它们还有一套特别的针对宽松相等和宽松不相等的比较规则，即：</p>
        <ul>
            <li><code>null</code> 与 <code>undefined</code> 宽松相等，且它们不会与除了它们之外的任何值宽松相等。</li>
        </ul>
        <pre><code class="language-js">undefined == null;       // true
</code></pre>
        <p>对于 <code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>，<code>null</code> 和 <code>undefined</code> 会被隐式转换为数字值，其中 <code>null</code> 会被转换为 <code>0</code>，<code>undefined</code> 会被转换为 <code>NaN</code>。</p>
        <p>需要注意的是，对于 <code>&gt;=</code> 和 <code>&lt;=</code>，大小比较和宽松相等比较的逻辑是分开的，<code>null</code> 和 <code>undefined</code> 会因为其中的大小比较逻辑而被隐式转换为数字值，然后再进行大小比较和宽松相等比较，于是便会出现这样一个奇怪的现象。</p>
        <pre><code class="language-js">null &gt;= 0; // true
null == 0; // false
null &gt;  0; // false
</code></pre>
        <h3 id="cc03cd3b-5aa1-4124-ad21-6a1ee85395ee">NaN</h3>
        <p><code>NaN</code> 与任何值（甚至包括它自己）进行任何比较都会返回 <code>false</code>。</p>
        <pre><code class="language-js">NaN == NaN; // false
</code></pre>
        <h3 id="d5f388a9-6ab9-4ea9-8dcb-7e932ad7a60c">引用值之间的比较</h3>
        <p>如果两个运算元都是引用值，且它们都指向同一个对象时，那么就认为他们是宽松相等和严格相等的，否则就认为它们是宽松不相等和严格不相等的。</p>
        <h2 id="455e24a5-fcee-400f-896e-61badc2c4db4">逗号运算符</h2>
        <p>从左向右逐个执行运算元，然后返回最右边的运算元的初始值，请注意，声明语句中的逗号并不是逗号运算符，只有表达式中的逗号才是逗号运算符。它的语法是：</p>
        <pre><code>expr_1, expr_2, ..., expr_n;
</code></pre>
        <p>示例：</p>
        <pre><code class="language-js">const exprA = _ =&gt; 1;
const exprB = _ =&gt; 2;

(exprA(), exprB()); // 2
</code></pre>
        <h2 id="ed0d82d3-23d7-4f17-bf4e-2fac02204162">可选链运算符</h2>
        <p>若左运算元为 <code>null</code> 或 <code>undefined</code> ，则返回 <code>undefined</code> ，并忽略右运算元，否则执行右运算元（通常是属性访问或函数调用）。它的语法是：</p>
        <pre><code class="language-js">obj?.property;
obj?.[expression];
array?.[index];
function?.();
</code></pre>
        <h2 id="517e4fc3-c897-4bc9-bbef-b99eff14fbe0">in 运算符</h2>
        <p>若该属性存在于该对象或该对象的原型链上，则返回 <code>true</code> ，否则返回 <code>false</code> ，它的语法是：</p>
        <pre><code class="language-js">prop in obj;
</code></pre>
        <ul>
            <li><code>prop</code> ： <code>String</code> 或 <code>Symbol</code> ，代表属性名或数组索引，其它的数据类型的值都会被隐式转换为 <code>String</code> </li>
            <li><code>obj</code> ： <code>Object</code></li>
        </ul>
        <p>示例：</p>
        <pre><code class="language-js">&#39;toString&#39; in {}; // true
0 in [1, 2, 3];   // true
</code></pre>
        <h2 id="edc6cd5f-d43f-43f9-abe5-f225bc04e3ed">instanceof 运算符</h2>
        <p>若对象 A 的 <code>prototype</code> 属性位于对象 B 的原型链上，则返回 <code>true</code> ，否则返回 <code>false</code> 。它的语法是：</p>
        <pre><code class="language-js">obj_b instanceof obj_a;
</code></pre>
        <p>示例：</p>
        <pre><code class="language-js">const A = function() {};
const a = new A();

a instanceof A;      // true
a instanceof Object; // true
</code></pre>
        <h2 id="bd73cc64-e965-4e40-a1a8-46a93c180983">位运算符</h2>
        <p>这类运算符在实际开发中很少被用到，因此暂时忽略它们，如果你更感兴趣，可以从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">这里</a> 开始学习</p>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>按位与</td>
                    <td><code>&amp;</code></td>
                    <td>左移</td>
                    <td><code>&lt;&lt;</code></td>
                </tr>
                <tr>
                    <td>按位或</td>
                    <td>`</td>
                    <td>`</td>
                    <td>右移</td>
                </tr>
                <tr>
                    <td>按位异或</td>
                    <td><code>^</code></td>
                    <td>无符号右移</td>
                    <td><code>&gt;&gt;&gt;</code></td>
                </tr>
                <tr>
                    <td>按位非</td>
                    <td><code>~</code></td>
                    <td></td>
                    <td></td>
                </tr>
            </tbody>
        </table>
    </article>
</body>

</html>