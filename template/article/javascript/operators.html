<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>运算符</title>
</head>

<body>
    <header>
        <button class="catalogue"><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
        <button class="homepage"><a href="/index.html"><strong>HOMEPAGE</strong></a></button>
    </header>
    <aside>
        <p><a href="#">IN THIS ARTICLE</a></p>
        <p data-level="1"><a href="#eac1fa9d-81bb-4415-9208-bd16eb29ccda">汇总表</a></p>
        <p data-level="1"><a href="#8e1d01fe-c2ee-4eb3-99d4-59ee4a53ab2c">算术运算符</a></p>
        <p data-level="2"><a href="#d84831c6-b39c-40da-83b0-d80640f93ee0">求幂</a></p>
        <p data-level="2"><a href="#b05de886-514d-4984-9026-235050ccde82">自增 和 自减</a></p>
        <p data-level="2"><a href="#cc984d59-351f-492b-ad21-98612bd7830d">加法</a></p>
        <p data-level="1"><a href="#4f01a061-b29e-40bf-b9af-a165be749238">赋值运算符</a></p>
        <p data-level="1"><a href="#e673b93a-3bf1-4361-951c-6419e38bc686">逻辑运算符</a></p>
        <p data-level="2"><a href="#15c18349-9e07-4888-a808-e8e87b6bdd62">逻辑或</a></p>
        <p data-level="2"><a href="#e029ecb9-1300-4198-ab8b-1118b6ea1b58">逻辑与</a></p>
        <p data-level="2"><a href="#2ab0ee7e-8dfb-449c-b86d-10c3d07e62a4">短路计算</a></p>
        <p data-level="1"><a href="#0e4bba3c-e939-4770-9229-52db60cac955">一元运算符</a></p>
        <p data-level="2"><a href="#271dd89e-b02a-4249-8bea-941032167971">void</a></p>
        <p data-level="2"><a href="#d38b9f25-0fe9-47e2-8963-ce49aad2465f">typeof</a></p>
        <p data-level="2"><a href="#db645f31-8ea3-49be-a475-9db96ac11054">delete</a></p>
        <p data-level="3"><a href="#94bb359a-8b72-40be-af8b-17aabf4c1ee5">delete 不存在的属性</a></p>
        <p data-level="3"><a href="#ab2613a5-22ed-4e78-a761-717ad9109670">delete 由 var、let、const、function 生命的变量</a></p>
        <p data-level="3"><a href="#cc5e20e0-89fc-4911-b2d7-983b1de85894">delete 数组元素</a></p>
        <p data-level="1"><a href="#f9fbbabd-17f7-48b5-babf-2044199c24bd">三元运算符</a></p>
        <p data-level="1"><a href="#e67be5c0-71e9-4cdf-b0a1-49fff5b5e9e5">比较运算符</a></p>
        <p data-level="1"><a href="#1da61ad8-c846-40e8-8223-a0db7e4aae7d">逗号运算符</a></p>
        <p data-level="1"><a href="#d972797a-133b-46d1-bc95-0ded46654a6e">可选链运算符</a></p>
        <p data-level="1"><a href="#826d5171-9dc2-4ed2-9916-a37cebc5a1bd">in 运算符</a></p>
        <p data-level="1"><a href="#bd70cc7a-ab3e-46ba-b1b1-ce8e8b658dff">instanceof 运算符</a></p>
        <p data-level="1"><a href="#6babc510-24a9-4eaa-83a8-7cb8b1a520d6">位运算符</a></p>
    </aside>
    <article>
        <h1>运算符</h1>
        <p id="last-updated">Last Updated: 25/04/2022</p>
        <h2 id="eac1fa9d-81bb-4415-9208-bd16eb29ccda">汇总表</h2>
        <p>参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#%E6%B1%87%E6%80%BB%E8%A1%A8">MDN-运算符优先级-汇总表</a>。</p>
        <h2 id="8e1d01fe-c2ee-4eb3-99d4-59ee4a53ab2c">算术运算符</h2>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>加</td>
                    <td><code>+</code></td>
                    <td>求幂</td>
                    <td><code>**</code></td>
                </tr>
                <tr>
                    <td>减</td>
                    <td><code>-</code></td>
                    <td>自增</td>
                    <td><code>++</code></td>
                </tr>
                <tr>
                    <td>乘</td>
                    <td><code>*</code></td>
                    <td>自减</td>
                    <td><code>--</code></td>
                </tr>
                <tr>
                    <td>除</td>
                    <td><code>/</code></td>
                    <td>一元正值符</td>
                    <td><code>+</code></td>
                </tr>
                <tr>
                    <td>取余</td>
                    <td><code>%</code></td>
                    <td>一元负值符</td>
                    <td><code>-</code></td>
                </tr>
            </tbody>
        </table>
        <p>算数运算符会对左右运算元进行算数运算，然后返回一个数字值，不是数字值的运算元会在运算开始前被隐式的转换为数字值（加法例外），下文是转换规则：</p>
        <ul>
            <li>对于二元加法运算符，若左、右运算元都不是 <code>String</code> ，则非 <code>Number</code> 的运算元会被转换为 <code>Number</code></li>
            <li>对于二元加法运算符，若有至少一个运算元是 <code>String</code> ，则非 <code>String</code> 的运算元会被转换为 <code>String</code> </li>
            <li>对于其它算术运算符，所有非 <code>Number</code> 的运算元都会被转换为 <code>Number</code></li>
        </ul>
        <h3 id="d84831c6-b39c-40da-83b0-d80640f93ee0">求幂</h3>
        <p>以左运算元为底数，以右运算元为指数，返回它们的乘方。注意，该运算符的关联性是从右到左，因此 <code>2 ** 2 ** 3</code> 等价于 <code>2 ** (2 ** 3)</code>，不等价于 <code>(2 ** 2) ** 3</code> 。</p>
        <h3 id="b05de886-514d-4984-9026-235050ccde82">自增 和 自减</h3>
        <p>对于前置自增，先令运算元自增 <code>1</code> ，再返回运算元的值。对于后置自增，先返回运算元的值，再令运算元自增 <code>1</code> 。自减运算符同理。</p>
        <h3 id="cc984d59-351f-492b-ad21-98612bd7830d">加法</h3>
        <p>对于二元加法运算符，若有至少一个运算元是 <code>String</code> ，则非 <code>String</code> 的运算元会被隐式转换为 <code>String</code> ，然后再进行字符串的连接，最后返回连接的结果。</p>
        <h2 id="4f01a061-b29e-40bf-b9af-a165be749238">赋值运算符</h2>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>描述</th>
                    <th>返回值</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>普通赋值</td>
                    <td><code>=</code></td>
                    <td>将右运算元的值分配给左运算元</td>
                    <td>右运算元的值</td>
                </tr>
                <tr>
                    <td>加赋值</td>
                    <td><code>+=</code></td>
                    <td><code>a += b</code> 等价于 <code>a = a + b</code></td>
                    <td><code>a + b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>减赋值</td>
                    <td><code>-=</code></td>
                    <td><code>a -= b</code> 等价于 <code>a = a - b</code></td>
                    <td><code>a - b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>乘赋值</td>
                    <td><code>*=*</code></td>
                    <td><code>a *= b</code> 等价于 <code>a = a * b</code></td>
                    <td><code>a * b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>除赋值</td>
                    <td><code>/=</code></td>
                    <td><code>a /= b</code> 等价于 <code>a = a / b</code></td>
                    <td><code>a / b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>取余赋值</td>
                    <td><code>%=</code></td>
                    <td><code>a %= b</code> 等价于 <code>a = a % b</code></td>
                    <td><code>a % b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>求幂赋值</td>
                    <td><code>**=</code></td>
                    <td><code>a **= b</code> 等价于 <code>a = a ** b</code></td>
                    <td><code>a ** b</code> 的返回值</td>
                </tr>
                <tr>
                    <td>逻辑与赋值</td>
                    <td><code>&amp;&amp;=</code></td>
                    <td><code>a &amp;&amp;= b</code> 等价于 <code>a &amp;&amp; (a = b)</code></td>
                    <td><code>a</code> 最终的值</td>
                </tr>
                <tr>
                    <td>逻辑或赋值</td>
                    <td>`</td>
                    <td></td>
                    <td>=`</td>
                </tr>
                <tr>
                    <td>逻辑空赋值</td>
                    <td><code>??=</code></td>
                    <td><code>a ??= b</code> 等价于 <code>a ?? (a = b)</code></td>
                    <td><code>a</code> 最终的值</td>
                </tr>
            </tbody>
        </table>
        <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN-运算符优先级</a> 明确表示：“赋值运算符的返回结果就是赋值运算符右边的那个值”。通过下述例子亦可佐证该观点：</p>
        <pre><code class="language-js">let a, b;

( a = b ) = 1; // Error: Uncaught SyntaxError: Invalid left-hand side in assignment
</code></pre>
        <p>因为 <code>a = b</code> 的返回值是变量 <code>b</code> 的值而不是变量 <code>b</code>，所以才会抛出 <code>Invalid left-hand</code>。</p>
        <p>逻辑与赋值的定义是：若左运算元为 <code>truthy</code>，则将右运算元的值赋予左运算元，否则不进行赋值操作。因为逻辑与赋值具有短路计算的特性，因此 <code>a &amp;&amp;= b</code> 才会等价于 <code>a &amp;&amp; ( a = b )</code> ，而不是 <code>a = a &amp;&amp; b</code>，因为前者才符合短路计算的特性。对于逻辑或赋值、逻辑空赋值也是同理的。</p>
        <h2 id="e673b93a-3bf1-4361-951c-6419e38bc686">逻辑运算符</h2>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>语法</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>逻辑与</td>
                    <td><code>&amp;&amp;</code></td>
                    <td><code>a &amp;&amp; b</code></td>
                    <td>若 <code>a</code> 的布尔值为 <code>true</code> ，则返回 <code>b</code> 的初始值；<br />若 <code>a</code> 的布尔值为 <code>false</code> ，则返回 <code>a</code> 的初始值，忽略 <code>b</code>；</td>
                </tr>
                <tr>
                    <td>逻辑或</td>
                    <td>`</td>
                    <td></td>
                    <td>`</td>
                </tr>
                <tr>
                    <td>逻辑非</td>
                    <td><code>!</code></td>
                    <td><code>!a</code></td>
                    <td>若 <code>a</code> 的布尔值为 <code>true</code> ，则返回 <code>false</code> ；<br />否则返回 <code>true</code> ；</td>
                </tr>
                <tr>
                    <td>逻辑空</td>
                    <td><code>??</code></td>
                    <td><code>a ?? b</code></td>
                    <td>若 <code>a</code> 的初始值为 <code>null</code> 或 <code>undefined</code> ，则返回 <code>b</code> 的初始值；<br />否则返回 <code>a</code> 的初始值，忽略 <code>b</code> ；</td>
                </tr>
            </tbody>
        </table>
        <p>注意，<code>a</code> 和 <code>b</code> 是变量或表达式，变量的初始值就是变量的值，表达式的初始值就是表达式的计算结果。</p>
        <h3 id="15c18349-9e07-4888-a808-e8e87b6bdd62">逻辑或</h3>
        <p>从左向右逐个检查运算元，然后返回首个 <code>truthy</code> 运算元的初始值，并忽略剩余的运算元。若一直没有找到 <code>truthy</code> 运算元，则返回最后那个运算元的初始值。比如对于 <code>a &amp;&amp; b &amp;&amp; c</code> ，JavaScript 引擎会这么做：</p>
        <ol>
            <li>从左向右逐个检查运算元；</li>
            <li>若当前运算元的初始值的数据类型不是布尔类型，则将其隐式转换为布尔类型；</li>
            <li>若当前运算元的布尔值为 <code>true</code> ，则立即返回当前运算元的初始值，并忽略剩余的运算元；</li>
            <li>若所有运算元的布尔值为 <code>false</code> ，则返回最后那个运算元的初始值；</li>
        </ol>
        <h3 id="e029ecb9-1300-4198-ab8b-1118b6ea1b58">逻辑与</h3>
        <p>从左向右逐个检查运算元，返回首个 <code>falsy</code> 运算元的初始值，并忽略剩余的运算元。若一直没有找到 <code>falsy</code> 运算元，则返回最后那个运算元的初始值。</p>
        <h3 id="2ab0ee7e-8dfb-449c-b86d-10c3d07e62a4">短路计算</h3>
        <p><code>&amp;&amp;</code> 、 <code>||</code> 、 <code>??</code> 具有能够忽略运算元的特性， “运算元被忽略” 是指该运算元没有被执行，因此被忽略的运算元中的错误、副作用、函数调用等都不会被触发。这种忽略运算元的行为被称为短路计算。短路计算常用于简化判断语句，但它也会降低代码的可读性。</p>
        <pre><code class="language-js">if ( 1 &gt; 0 ) console.log( true );
/* equal to */
1 &gt; 0 &amp;&amp; console.log( true );
</code></pre>
        <h2 id="0e4bba3c-e939-4770-9229-52db60cac955">一元运算符</h2>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>语法</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>一元加法</td>
                    <td><code>+</code></td>
                    <td><code>+a</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>一元减法</td>
                    <td><code>-</code></td>
                    <td><code>-a</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>逻辑非</td>
                    <td><code>!</code></td>
                    <td><code>!a</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>按位非</td>
                    <td><code>~</code></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>void</td>
                    <td><code>void</code></td>
                    <td><code>void a</code> 或 <code>void (a)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>typeof</td>
                    <td><code>typeof</code></td>
                    <td><code>typeof a</code> 或 <code>typeof (a)</code></td>
                    <td></td>
                </tr>
                <tr>
                    <td>delete</td>
                    <td><code>delete</code></td>
                    <td><code>delete a</code></td>
                    <td></td>
                </tr>
            </tbody>
        </table>
        <h3 id="271dd89e-b02a-4249-8bea-941032167971">void</h3>
        <p>执行右运算元，然后返回 <code>undefined</code>，它的语法是：</p>
        <pre><code class="language-js">void expression;
void ( expression );
</code></pre>
        <p>使用 <code>void</code> 来构造的 IIFE 会稍微安全一些，因为它的返回值总是 <code>undefined</code>：</p>
        <pre><code class="language-js">void function iife(){}();
</code></pre>
        <p><code>void</code> 还能用来构造无响应的超链接标签，比如：</p>
        <pre><code class="language-html">&lt;a href=&quot;javascript: void 0;&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;javascript: void(0);&quot;&gt;&lt;/a&gt;
</code></pre>
        <h3 id="d38b9f25-0fe9-47e2-8963-ce49aad2465f">typeof</h3>
        <p>返回一个表示右运算元的数据类型的字符串，它的语法是：</p>
        <pre><code class="language-js">typeof a;
typeof ( a );
</code></pre>
        <table>
            <thead>
                <tr>
                    <th>数据类型</th>
                    <th>返回值</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>Undefined</code></td>
                    <td><code>&quot;undefined&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Null</code></td>
                    <td><code>&quot;object&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Boolean</code></td>
                    <td><code>&quot;boolean&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Number</code></td>
                    <td><code>&quot;number&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Bigint</code></td>
                    <td><code>&quot;bigint&quot;</code></td>
                </tr>
                <tr>
                    <td><code>String</code></td>
                    <td><code>&quot;string&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Symbol</code></td>
                    <td><code>&quot;symbol&quot;</code></td>
                </tr>
                <tr>
                    <td><code>Function</code></td>
                    <td><code>&quot;function&quot;</code></td>
                </tr>
                <tr>
                    <td>宿主对象（如 <code>window</code> 、 <code>document</code> ）</td>
                    <td>取决于浏览器的实现</td>
                </tr>
                <tr>
                    <td>其它对象</td>
                    <td><code>&quot;object&quot;</code></td>
                </tr>
                <tr>
                    <td>未声明的变量</td>
                    <td><code>&quot;undefined&quot;</code></td>
                </tr>
            </tbody>
        </table>
        <p>其中，<code>typeof null</code> 的返回值是 <code>&#39;object&#39;</code> ，这是一个历史遗留错误。</p>
        <h3 id="db645f31-8ea3-49be-a475-9db96ac11054">delete</h3>
        <p>删除对象自身的指定属性，但不会删除对象原型链上的同名属性，它的语法时是：</p>
        <pre><code class="language-js">delete obj.prop;
delete obj[expr];
</code></pre>
        <p>它有 2 种返回值，分别是：</p>
        <ul>
            <li><code>false</code> ：若 <code>delete</code> 不可配置的属性，则会返回该值，且在非严格模式下，该操作将静默失败，在严格模式下，该操作将会抛出错误。</li>
            <li><code>true</code> ：其余情况都返回 <code>true</code>。</li>
        </ul>
        <h4 id="94bb359a-8b72-40be-af8b-17aabf4c1ee5">delete 不存在的属性</h4>
        <p><code>delete</code> 不存在的属性也会返回 <code>true</code> ，且被操作的对象没有任何变化。</p>
        <pre><code class="language-js">delete {}.a; // true
</code></pre>
        <h4 id="ab2613a5-22ed-4e78-a761-717ad9109670">delete 由 var、let、const、function 生命的变量</h4>
        <p>在任何作用域内，由声明关键字声明的变量都是某个对象的不可配置的属性，而不经声明就直接赋值来创建的变量则是某个对象的可配置的属性。因此，<code>delete</code> 前者将会返回 <code>false</code>，<code>delete</code> 后者将会返回 <code>true</code>，比如：</p>
        <pre><code class="language-js">var a = 1;
Object.getOwnPropertyDescriptor(window, &quot;a&quot;).configurable; // false
</code></pre>
        <pre><code class="language-js">a = 1;
Object.getOwnPropertyDescriptor(window, &quot;a&quot;).configurable; // true
</code></pre>
        <pre><code>
</code></pre>
        <h4 id="cc5e20e0-89fc-4911-b2d7-983b1de85894">delete 数组元素</h4>
        <p><code>delete</code> 一个数组的元素，就会清空这个元素的内容，但不会释放掉这个元素所占据的内存空间，被 <code>delete</code> 后的元素的值为 <code>undefined</code> ，意义为 empty 。数组的长度不会改变，其它元素的下标也不会重排。</p>
        <pre><code class="language-js">const a = [ 1, 2 ];
delete a[ 0 ];
a;      // [ empty, 2 ]
a[ 0 ]; // undefined
</code></pre>
        <h2 id="f9fbbabd-17f7-48b5-babf-2044199c24bd">三元运算符</h2>
        <p>又被称为条件运算符，它的语法是：</p>
        <pre><code class="language-js">condition ? expr_1 : expr_2;
</code></pre>
        <p>若 <code>condition</code> 的 truthy 为 <code>true</code>，则执行 <code>expr_1</code>，且忽略 <code>expr_2</code>，最后返回 <code>expr_1</code> 的初始值。否则忽略 <code>expr_1</code>，执行 <code>expr_2</code>，最后返回 <code>expr_2</code> 的初始值。</p>
        <h2 id="e67be5c0-71e9-4cdf-b0a1-49fff5b5e9e5">比较运算符</h2>
        <blockquote>
            <p>⏳：《部分转换规则》和《部分比较规则》不齐全，需要继续补充。</p>
        </blockquote>
        <p>严格比较运算符需比较左、右运算元的数据类型与值，其余的比较运算符会将左、右运算元隐式转换为同一种数据类型后再比较它们的值。</p>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>严格相等</td>
                    <td><code>===</code></td>
                    <td>严格不相等</td>
                    <td><code>!==</code></td>
                    <td>大于</td>
                    <td><code>&gt;</code></td>
                    <td>大于或等于</td>
                    <td><code>&gt;=</code></td>
                </tr>
                <tr>
                    <td>宽松相等</td>
                    <td><code>==</code></td>
                    <td>宽松不相等</td>
                    <td><code>!=</code></td>
                    <td>小于</td>
                    <td><code>&lt;</code></td>
                    <td>小于或等于</td>
                    <td><code>&lt;=</code></td>
                </tr>
            </tbody>
        </table>
        <p>部分转换规则：</p>
        <ul>
            <li>若两个运算元分别是 <code>Number</code> 和 <code>String</code> ，则 <code>String</code> 会被转换为 <code>Number</code>。</li>
            <li>若两个运算元分别是 <code>Number</code> 和 <code>Boolean</code> ，则 <code>Boolean</code> 会被转换为 <code>Number</code> 。</li>
        </ul>
        <p>部分比较规则：</p>
        <ul>
            <li>若两个运算元都是 <code>Object</code> ，则当它们都指向同一个对象时，认为它们宽松相等和严格相等，否则认为它们宽松不相等和严格不相等；</li>
            <li><code>NaN</code> 不与任何值（包括它自己）宽松相等或严格相等；</li>
            <li><code>+0</code> 和 <code>-0</code> 严格相等；</li>
        </ul>
        <h2 id="1da61ad8-c846-40e8-8223-a0db7e4aae7d">逗号运算符</h2>
        <p>从左向右逐个执行运算元，然后返回最右边的运算元的初始值，请注意，声明语句中的逗号并不是逗号运算符，只有表达式中的逗号才是逗号运算符。它的语法是：</p>
        <pre><code>expr_1, expr_2, ..., expr_n;
</code></pre>
        <p>示例：</p>
        <pre><code class="language-js">const exprA = _ =&gt; 1;
const exprB = _ =&gt; 2;

(exprA(), exprB()); // 2
</code></pre>
        <h2 id="d972797a-133b-46d1-bc95-0ded46654a6e">可选链运算符</h2>
        <p>若左运算元为 <code>null</code> 或 <code>undefined</code> ，则返回 <code>undefined</code> ，并忽略右运算元，否则执行右运算元（通常是属性访问或函数调用）。它的语法是：</p>
        <pre><code class="language-js">obj?.property;
obj?.[expression];
array?.[index];
function?.();
</code></pre>
        <h2 id="826d5171-9dc2-4ed2-9916-a37cebc5a1bd">in 运算符</h2>
        <p>若该属性存在于该对象或该对象的原型链上，则返回 <code>true</code> ，否则返回 <code>false</code> ，它的语法是：</p>
        <pre><code class="language-js">prop in obj;
</code></pre>
        <ul>
            <li><code>prop</code> ： <code>String</code> 或 <code>Symbol</code> ，代表属性名或数组索引，其它的数据类型的值都会被隐式转换为 <code>String</code> </li>
            <li><code>obj</code> ： <code>Object</code></li>
        </ul>
        <p>示例：</p>
        <pre><code class="language-js">&#39;toString&#39; in {}; // true
0 in [1, 2, 3];   // true
</code></pre>
        <h2 id="bd70cc7a-ab3e-46ba-b1b1-ce8e8b658dff">instanceof 运算符</h2>
        <p>若对象 A 的 <code>prototype</code> 属性位于对象 B 的原型链上，则返回 <code>true</code> ，否则返回 <code>false</code> 。它的语法是：</p>
        <pre><code class="language-js">obj_b instanceof obj_a;
</code></pre>
        <p>示例：</p>
        <pre><code class="language-js">const A = function() {};
const a = new A();

a instanceof A;      // true
a instanceof Object; // true
</code></pre>
        <h2 id="6babc510-24a9-4eaa-83a8-7cb8b1a520d6">位运算符</h2>
        <p>这类运算符在实际开发中很少被用到，因此暂时忽略它们，如果你更感兴趣，可以从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">这里</a> 开始学习</p>
        <table>
            <thead>
                <tr>
                    <th>名称</th>
                    <th>运算符</th>
                    <th>名称</th>
                    <th>运算符</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>按位与</td>
                    <td><code>&amp;</code></td>
                    <td>左移</td>
                    <td><code>&lt;&lt;</code></td>
                </tr>
                <tr>
                    <td>按位或</td>
                    <td>`</td>
                    <td>`</td>
                    <td>右移</td>
                </tr>
                <tr>
                    <td>按位异或</td>
                    <td><code>^</code></td>
                    <td>无符号右移</td>
                    <td><code>&gt;&gt;&gt;</code></td>
                </tr>
                <tr>
                    <td>按位非</td>
                    <td><code>~</code></td>
                    <td></td>
                    <td></td>
                </tr>
            </tbody>
        </table>
    </article>
</body>

</html>