<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 对象在 V8 引擎中的实现</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=012e7547-3b97-4303-bec7-026c77cbf3a8>概述</p>
        <p data-target-id=3e45417c-e94f-4cca-bfed-327f78755dae>环境</p>
        <p data-target-id=cdbc2a57-f820-413e-91a6-66a5db705318>调试</p>
        <p data-target-id=386a52e6-a69e-4e7a-8f8b-4fab09cf9cb3>对象</p>
        <p data-target-id=b58bb134-76dc-43e0-9525-7555a5747541>实现</p>
        <p data-target-id=e26f934b-60ca-4661-a153-5a019f9ebaef>参考</p>
    </aside>
    <article>
        <h1>JavaScript 对象在 V8 引擎中的实现</h1>
        <h2 id="012e7547-3b97-4303-bec7-026c77cbf3a8">概述</h2>
        <p>本文将会描述 V8 引擎是如何实现 JavaScript 对象的。</p>
        <h2 id="3e45417c-e94f-4cca-bfed-327f78755dae">环境</h2>
        <p>本文使用 Node 运行时来作为测试环境，其版本为 16.13.1。该 Node 运行时所使用的 V8 引擎的版本是 9.4.146.24。</p>
        <h2 id="cdbc2a57-f820-413e-91a6-66a5db705318">调试</h2>
        <p>在 V8 引擎中，有一些内建的函数可以帮助开发者进行 debug，其中有一个名为 <code>%DebugPrint</code> 的函数可以帮助开发者观察 JavaScript 值的内部信息。不过，在使用 <code>%DebugPrint</code> 之类的内建函数之前，我们必须先执行 <code>--allow-natives-syntax</code> 命令。</p>
        <p>具体来说，在 Node 运行时中，我们可以通过如下做法来调用 <code>%DebugPrint</code> 函数，并让其打印字面量 <code>{a: 1}</code> 的内部信息。</p>
        <pre><code>node --allow-natices-syntax       // input
Welcome to Node.js v16.13.1.      // output
Type &quot;.help&quot; for more information // output
&gt; %DebugPrint( { a: 1 } );        // input
internal information...           // output
internal information...           // output
internal information...           // output
{ a: 1 }                          // output
</code></pre>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>我们不仅可以在 Node 运行时中使用 V8 引擎的内建函数，也能在 Chromium 中使用这些内建函数，因为这些运行时都使用了 V8 引擎。</p>
        </blockquote>
        <h2 id="386a52e6-a69e-4e7a-8f8b-4fab09cf9cb3">对象</h2>
        <p>JavaScript 中的对象和面向对象语言中的对象是不一样的，在 JavaScript 中，对象是一种字典类型的数据结构，比如 <code>{a: 1}</code>。其中，对象的键只能使用 <code>String</code> 或 <code>Symbol</code> 类型的值，对象的值则可以使用任意的数据类型。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>JavaScript 中有 2 个特别的内建 API，分别是 <code>Map</code> 和 <code>WeakMap</code>，它们都同样是字典类型的数据结构。和 JavaScript 对象不同的是，<code>Map</code> 可以使用任意数据类型来作为键，<code>WeakMap</code> 只能使用对象来作为键。</p>
        </blockquote>
        <p>另外，如果我们遍历对象的属性，那么就会先按照索引值的升序顺序来输出对象的数组索引属性，然后再按照属性创建的先后顺序来输出其他属性，这是根据 ECMAScript 规范的要求来设计的。</p>
        <pre><code class="language-js">const obj = {};

obj[ &quot;2&quot; ] = &quot;&quot;;
obj[ &quot;1&quot; ] = &quot;&quot;;
obj[ &quot;0&quot; ] = &quot;&quot;;
obj[ &quot;a&quot; ] = &quot;&quot;;
obj[ &quot;b&quot; ] = &quot;&quot;;
obj[ &quot;c&quot; ] = &quot;&quot;;

for ( let key in obj ) console.log( key );
// 0 1 2 a b c
</code></pre>
        <h2 id="b58bb134-76dc-43e0-9525-7555a5747541">实现</h2>
        <h3 id="4b479bc2-0370-4e64-b244-a2917a2cbc2e">总览</h3>
        <p>首先，V8 引擎会申请一块连续的内存空间来存储 JavaScript 对象的信息，为方便起见，本文会将该内存空间称为 JavaScript 对象容器。</p>
        <p>V8 官方将 JavaScript 对象的属性分成两种类型，一种是 named property（命名属性），另一种是 array-indexed property（数组索引属性）。V8 官方将 named property 和 array-indexed property 分别简称为 property 和 element，本文会沿用这种叫法。</p>
        <p>对于 element，V8 引擎将它存储在另一个独立的内存空间中。对于 property，V8 引擎的做法则有一些复杂，首先，V8 引擎有可能会将一部分 property 直接存储在 JavaScript 对象容器上，然后将剩余的 property 存储在另一个独立的内存空间中，前者被称为 in-object property，后者被称为 normal property。</p>
        <p>JavaScript 对象容器的前 3 个位置存储了 3 个指针，每个指针占 8 个字节（64位系统下）。其中，第一个指针指向 hidden class 的内存空间，第二个指针指向 normal property 的内存空间，第三个指针指向 element 的内存空间。</p>
        <p>关于 hidden class，它是 <code>HiddenClass</code> 类的实例，而 <code>HiddenClass</code> 则是一个由 V8 官方实现的标准的 C++ 类。hidden class 用于存储 JavaScript 对象的内部信息，比如属性的数量，原型的地址等，我们会在后文继续介绍 hidden class。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/hiddenclass-property-element.png" alt="hidden class &amp; property &amp; element"></p>
        <h3 id="10988887-04c3-4fae-b06f-95c002658ef1">property</h3>
        <p>在介绍 hidden class 之前，我们需要先了解 property 来作为前置知识。</p>
        <p>property 的准确名称是 named property（命名属性），它是指使用除了正整数字符串之外的其他字符串来作为键的属性，比如 <code>{ a: 1 }</code> 等。另外，使用 <code>Symbol</code> 类型的值来作为键的属性也属属于 named property。下文将会使用 property 来指代 named property。</p>
        <p>property 又分为 in-object property 和 normal property。</p>
        <h4 id="60082057-b11c-4e99-931e-612e39e82714">in-object property</h4>
        <p>正如前文所述，V8 引擎“有可能”会将一部分的 property 直接存储在 JavaScript 对象容器上，V8 官方将这些 property 称为 in-object property。为方便起见，我们将 JavaScript 对象容器所能存储的 in-object property 的数量称为 in-object property 的容量。</p>
        <p>具体来说，V8 引擎在创建 JavaSript 对象容器的时候，就会预留一些内存空间来用于存储 in-object property，V8 引擎既可能会预留零个 in-object property 的位置，也有可能会预留几十上百个 in-object property 的位置。in-object property 的容量的大小完全取决于你创建 JavaScript 对象的方式，并且这个容量是不可改变的。</p>
        <p>其实，我不知道决定 in-object property 的容量的根本因素是什么，不过，实践证明：</p>
        <ul>
            <li>空 JavaScript 对象的 in-object property 的容量是 4</li>
            <li>如果用字面量赋值的方式来创建的 JavaScript 对象的话，那么字面量中的命名属性就都会变成 in-object property，并且命名属性的数量就是 in-object property 的容量</li>
        </ul>
        <p>对于第二点，比如，如果我们使用字面量 <code>{ a:1, b:2, c:3 }</code> 来创建一个 JavaScript 对象，那么这个 JavaScript 对象的 in-object property 就是 <code>a</code>、<code>b</code>、<code>c</code>，它的 in-object property 的容量就是 3，并且后续追加的命名属性都会变成 normal property。你可以在 Node 运行时中依次键入下述命令来验证一下。</p>
        <pre><code>node --allow-natives-syntax
const obj = { a:1, b:2, c:3 };
%DebugPrint( obj );
obj.d = 4;
%DebugPrint( obj );
</code></pre>
        <p>第一次 <code>%DebugPrint( obj )</code> 的输出如下，可见，in-object property 的容量为 3（见 <code>inobject properties: 3</code>），normal property 的容量为 0（见 <code>&lt;FixedArray[0]&gt;</code>），并且属性 <code>a</code>、<code>b</code>、<code>c</code> 都是 in-object property。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/in-object-properties-capacity-1.png" alt="in-object property的容量"></p>
        <p>第二次 <code>%DebugPrint( obj )</code> 的输出如下，可见，in-object property 的容量没有变化，不过追加的 <code>d</code> 属性成为了 normal property。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/in-object-properties-capacity-2.png" alt="in-object property的容量"></p>
        <p>最后，in-object property 的访问速度要比 normal property 的更快，因为 V8 引擎在查找命名属性时，会先查找 in-object property，然后再查找 normal property。另外，哪怕 V8 引擎同时在 in-object property 和 normal property 中查找目标属性，in-object property 的访问速度也会更快，这是因为 in-object property 的访问路径更短。</p>
        <p>当我们经常采用字面量赋值的方式来创建仅拥有少量命名属性的小型对象时，这些小型对象的属性访问速度都会很快，这是因为这些小型对象的命名属性都被当作 in-object property 来存储了，这正是 V8 官方设计 in-object property 的原因之一。</p>
        <h4 id="c16dd11c-cba6-4362-be20-78b0f981d86b">normal property</h4>
        <p>超出 in-object property 容量的 property 会被存储在另一个独立的内存空间中，这些 property 就被称为 normal property。</p>
        <p>V8 引擎会采用数组数据结构或字典数据结构来存储 normal property，为避免混淆，在下文中，我们会把这个数组和字典称为 “数组容器” 和 “字典容器”。其中，V8 引擎所使用的数组容器是 <code>FixedArray</code> 实例或 <code>PropertyArray</code> 实例，它们是由 V8 引擎实现的数组数据结构。而 V8 引擎所使用的字典容器是 <code>NameDictionary</code> 实例，它是 V8 引擎实现的基于散列函数的字典数据结构，即散列表。</p>
        <p>因为数组容器的访问速度要比字典容器的访问速度更快，所以 V8 引擎会把采用数组容器来存储的 normal property 称为 fast property，并把采用字典容器来存储的 normal property 称为 slow property。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>对于数组，我们可以通过下标来直接访问到数组的数据，对于散列表，我们需要通过散列函数来计算出目标数据的存储地址，然后才能访问到目标数据，所以数组的访问速度要更快。你可以通过阅读《散列表》来进一步了解散列表的实现原理，它是本博客的另一片文章。</p>
        </blockquote>
        <p>V8 引擎更加青睐于使用 fast property，并且 V8 引擎还为其做了额外的优化，来进一步提升它的访问性能，比如 <a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">inline caches</a>。</p>
        <p>虽然 fast property 的访问速度更快，但是在涉及到属性的增加和删除时，slow property 的性能则会更好，这就是 V8 还额外支持 slow property 的原因。另外，inline caches 并不适用于 slow property。</p>
        <p>最后，V8 引擎会视情况来决定到底是使用 fast property 还是 slow property，并且也会视情况来决定是否要切换至 fast property 或 slow property。我不清楚其中的规律，不过实践发现，如果我们 <code>delete</code> 了对象的某个 in-object property，那么 V8 引擎就会将 fast property 切换为 slow property。</p>
        <h4 id="2c551054-b433-4268-bf6e-1025f4a98921">hidden class</h4>
        <p>hidden class 存储了 JavaScript 对象的信息，比如属性的数量、原型的地址等。其中，hidden class 的 bit field 3 字段存储了 JavaScript 对象的属性数量，以及一个指向 descriptor array 的指针，descriptor array 存储了 fast property 的键、值地址、属性描述符。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/hidden-class.png" alt="hidden class"></p>
        <p>descriptor array 是一个 <code>FixedArray</code> 实例，它用于帮助 V8 引擎找到 fast property 的值。具体来说，所有 fast property 的值都被存储在一个数组容器中，如果 fast property 的键和值之间缺少了映射关系，那么 V8 引擎就无法根据键来找到对应的值。打个比方，对于 <code>{a: 1, b: 2, ... }</code> 而言，如果 V8 引擎要查询属性 <code>a</code>，那么 V8 引擎该怎么知道值 <code>1</code> 存储在数组容器的哪个位置呢？为了解决这个问题，V8 引擎将键与值的地址存储在了 descriptor array 中，如此一来，V8 引擎就可以通过键来在 descriptor array 中找到对应的值的地址了。所以 descriptor array 就相当于一个地址簿，V8 引擎通过被呼人的名字（键）来在这个地址簿上找到被呼人的住址（值的地址），最后再找到被呼人本身（值）。</p>
        <p>显然的是，如果 V8 引擎要更新 fast property，那么它自然也就需要更新 hidden class 和其中的 descriptor array，这是 fast property 的增删速度要比 slow property 的增删速度更慢的另一个原因。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/fast-property-descriptor-array.png" alt="descriptor array服务于fast property"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>对于上图，实际上，我不确定属性描述符是否会真的存储在 <code>detail</code> 中，这只是我的推测。</p>
        </blockquote>
        <p>另外，descriptor array 不服务于 slow property。因为当 V8 引擎使用字典容器来存储 normal property 的时候，V8 引擎就会直接将属性的键、值、属性描述符一一对应的存进这个字典中，然后 V8 引擎可以直接根据属性的键来在这个字典中找到对应的值，而不需要使用到 descriptor array。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/slow-property-descriptor-array.png" alt="descriptor array不服务于slow property"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>你可以通过 <a href="https://zh.javascript.info/property-descriptors">这篇文章</a> 来了解属性描述符。</p>
        </blockquote>
        <p>最后，descriptor array 也不会存储 element 的信息，因为对于 element 而言，V8 引擎总是可以将键和值关联在一起，详见下文。</p>
        <h3 id="6e4cd031-209f-4ec1-9819-99166d999ec2">element</h3>
        <p>element 的准确名称是 array-indexed property（数组索引属性），它是指使用正整数字符串来作为键的属性，比如 <code>&quot;0&quot;</code>、<code>&quot;1&quot;</code> 等。需要注意的是，<code>&quot;+0&quot;</code>、<code>&quot;-0&quot;</code>、<code>&quot;+1&quot;</code>、<code>&quot;-1&quot;</code> 等都不属于正整数字符串，如果你使用它们来作为属性的键，那么这个属性就属于 property 而不是 element。</p>
        <h4 id="d5c416c2-50f9-412e-9903-c4c9abb37546">存储方式</h4>
        <p>element 没有类似于 in-object property 的东西，所有的 element 都被直接存储在另一个独立的内存空间中。V8 引擎会采用数组数据结构或字典数据结构来存储 element，其中，V8 引擎所使用的数组容器是 <code>FixedArray</code> 实例，V8 引擎所使用的字典容器是 <code>NumberDictionary</code>，这是一个由 V8 引擎实现的散列表。</p>
        <p>另外，因为 element 属性的键都是数组索引字符串，所以不论 V8 引擎使用数组容器来存储 element，还是使用字典容器来存储 element，V8 引擎都可以直接将 element 属性的键和值一一对应的存储在数组容器或字典容器上。得益于这个特点，V8 引擎可以直接通过 element 的键来在数组容器或字典容器中找到对应的值，而不需要像 fast property 一样依赖 hidden class 的 descriptor array。</p>
        <p>和 fast / slow property 相似的是，当 V8 引擎使用数组容器来存储 element 时，element 的访问速度会更快。</p>
        <h4 id="e9142047-17d2-4e93-8be6-5dc633124117">用数组来存储 —— 稀疏数组</h4>
        <p>当 V8 引擎使用数组容器来存储 element 时，如果 element 的键不是从 <code>0</code> 起算的，或者键与键之间不是连续的，对应的数组容器就会产生空元素，我们把数组中的空元素称为数组的孔，我们把含有孔的数组称为稀疏数组。</p>
        <p>比如，我们使用下述代码来创建一个只含有一个 element 属性的 JavaScript 对象，然后通过 <code>%DebugPrint( obj )</code> 来打印该对象的内部信息。</p>
        <pre><code>node --allow-natives-syntax
const obj = { 1:1 };
%DebugPrint( obj );
</code></pre>
        <p>如下图所示，V8 引擎使用一个长度为 19 的 <code>FixedArray</code> 实例来存储 element，这个 <code>FixedArray</code> 实例的 <code>0</code> 号以及 <code>2~18</code> 号元素的值都是 <code>&lt;the_hole&gt;</code>，这是一个由 V8 引擎定义的特殊值，它代表着该元素为空。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/sparse-array.png" alt="稀疏数组"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>你应该会很好奇为什么上图中的 <code>FixedArray</code> 实例的长度是 19 而不是 2，具体来说，如果 element 的数量超出了 <code>FixedArray</code> 实例的容量（即长度），那么 V8 引擎就需要对 <code>FixedArray</code> 实例进行扩容。如果 <code>FixedArray</code> 实例的容量总是刚好等于 element 的数量的话，那么每次新增 element 时，V8 引擎都需要扩充 <code>FixedArray</code> 实例的容量。然而，这个扩容是一个耗时的行为，为了避免频繁的扩容，V8 引擎会在初始化和扩容 <code>FixedArray</code> 实例的时候，就多申请一些额外的存储空间，用来存储新增的 element，这样 V8 引擎就只需要在 <code>FixedArray</code> 实例容量不足时再进行扩容就可以了。</p>
            <p>另外，这个扩容的大致原理是，V8 引擎创建一个新的 <code>FixedArray</code> 实例，这个新的 <code>FixedArray</code> 实例有更大的容量，然后再将旧的 <code>FixedArray</code> 实例的数据，和新增的 element 的数据，一起拷贝到新的 <code>FixedArray</code> 实例中去。你可以通过 <a href="https://zhuanlan.zhihu.com/p/26388217">这篇文章</a> 来进一步了解 V8 引擎是如何实现这个扩容和收缩的。</p>
            <p>不过，V8 引擎有时候也会创建出容量刚好等于 element 数量的 <code>FixedArray</code> 实例，比如 <code>const array = [ 0, 1, 2 ]</code> 所创建出的 JavaScript 对象会使用 <code>FixedArray</code> 实例来存储 element，而这个 <code>FixedArray</code> 实例的容量就刚好等于 3。</p>
        </blockquote>
        <p>当 V8 引擎在存储 element 的数组容器上找到 <code>&lt;the_hole&gt;</code> 时，V8 引擎就可以立即断定出该 JavaScript 对象上不存在目标属性，然后 V8 引擎就可以开始从该 JavaScript 对象的原型链上继续查找目标属性了。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/the-hole-use.png" alt="&lt;the_hole&gt;的用处"></p>
        <h4 id="c3933a5a-32b1-4ac2-8059-ed6831fa0860">用数组来存储 —— 数组容器的类型</h4>
        <p>当 V8 引擎使用数组容器来存储 element 时，V8 引擎会根据数组容器是否是稀疏的，以及数组容器的元素的数据类型来进行分类，不同类型的数组容器的性能是不一样的，因为 V8 引擎可以对不同类型的数组容器进行不同程度的优化。比如，有这些类型：</p>
        <ul>
            <li>如果数组容器是无孔的：<ul>
                    <li>且数组容器中元素都是整数，那么类型就是 <code>PACKED_SMI_ELEMENTS</code></li>
                    <li>且数组容器中的元素只包含整数和浮点数，那么类型就是 <code>PACKED_DOUBLE_ELEMENTS</code></li>
                    <li>且数组容器中的元素包含整数、浮点数和其他，那么类型就是 <code>PACKED_ELEMENTS</code></li>
                </ul>
            </li>
            <li>如果数组容器是有孔的：<ul>
                    <li>且数组容器中元素都是整数，那么类型就是 <code>HOLEY_SMI_ELEMENTS</code></li>
                    <li>且数组容器中的元素只包含整数和浮点数，那么类型就是 <code>HOLEY_DOUBLE_ELEMENTS</code></li>
                    <li>且数组容器中的元素包含整数、浮点数和其他，那么类型就是 <code>HOLEY_ELEMENTS</code></li>
                </ul>
            </li>
        </ul>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>SMI 是 small integer 的缩写。</p>
            <p>实际上，V8 引擎一共划分了 21 种不同类型的数组容器，本文只讨论了其中 6 种，你可以通过这份 <a href="https://source.chromium.org/chromium/v8/v8.git/+/ec37390b2ba2b4051f46f153a8cc179ed4656f5d:src/elements-kind.h;l=14">源码</a> 来查看其他类型的数组容器。</p>
        </blockquote>
        <p><code>PACKED</code> 数组容器的性能比 <code>HOLEY</code> 数组容器的性能更好，因为 V8 引擎可以对 <code>PACKED</code> 数组容器进行更加积极的优化。</p>
        <p><code>PACKED_SMI_ELEMENTS</code>、<code>PACKED_DOUBLE_ELEMENTS</code>、<code>PACKED_ELEMENTS</code> 数组容器的性能依次降低，类似的，<code>HOLEY_SMI_ELEMENTS</code>、<code>HOLEY_DOUBLE_ELEMENTS</code>、<code>HOLEY_ELEMENTS</code> 数组容器的性能也依次下降。总的来说，如果数组容器的元素的数据类型越具体，那么数组容器的性能就越好，这是因为 V8 引擎可以对数据类型更加具体的数组容器进行更细粒度的优化。</p>
        <p>这种性能差异的具体表现之一是，在调用 JavaScript 数组对象的内置方法时，V8 引擎会针对不同类型的数组容器来调用不同版本的内置方法，不同版本的内置方法的性能是不同的，原因正如上文所说，是因为 V8 引擎进行了不同程度的优化。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/array-type-function.png" alt="不同类型的数组容器会调用不同版本的内置方法"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>因为 JavaScript 数组和 JavaScript 对象采用了一模一样的存储方法，所以这个例子可以使用 JavaScript 数组来替代 JavaScript 对象。</p>
        </blockquote>
        <p>另外，<code>%DebugPrint</code> 函数可以查看数组容器的类型。比如，我创建了下列 6 种 JavaScript 对象，并打印了它们的内部信息，最后再把它们的内部信息的片段汇总到下图中，我们可以从该图中清晰的看到数组容器的类型。其中，<code>COW</code> 是 <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy on write</a> 的缩写，这是另一种优化技术，你可以忽略它们。</p>
        <pre><code>const packed_smi_elements = [ 0, 1, 2 ];
const packed_double_elements = [ 0, 1.1, 2 ];
const packed_elements = [ 0, &quot;1&quot;, 2 ];

const holey_smi_elements = [ , 1, 2 ];
const holey_double_elements = [ , 1.1, 2 ];
const holey_elements = [ , &quot;1&quot;, 2 ];
</code></pre>
        <p><img src="/static/image/markdown/javascript/v8-object/array-type.png" alt="数组容器的类型"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>因为通过字面量赋值的方式来创建的 JavaScript 数组的数组容器的容量刚好等于字面量数组中的元素数量，所以这个例子使用了 JavaScript 数组来替代 JavaScript 对象。</p>
        </blockquote>
        <p>最后，数组容器的类型是可以转化的，不过只能从 <code>PACKED</code> 转化为 <code>HOLEY</code>，以及只能从具体类型转化为模糊类型，即这种转化是单向的。</p>
        <p><img src="/static/image/markdown/javascript/v8-object/array-type-translation-performance.png" alt="数组容器的类型与性能"></p>
        <h4 id="3ed641a6-6698-4cb6-8b0d-c8a8f673bbf8">用数组来存储 —— 性能优化</h4>
        <p>当你的 JavaScript 对象使用数组来存储 element 时，遵循下述行为规范有助于获得更好的性能。</p>
        <p>行为规范一：因为数组容器的类型转化是单向的，所以为了更好的性能，请尽可能的使用 <code>PACKED</code> 和数据类型更具体的 element，并且不轻易的向 element 中引入孔或向其添加其他数据类型的值。另外，<code>-0</code>、<code>NaN</code>、<code>Infinity</code> 这 3 个值都可以将 <code>PACKED_SMI_ELEMENTS</code> 转化为 <code>PACKED_DOUBLE_ELEMENTS</code>，同理于 <code>HOLEY_SMI_ELEMENTS</code>。</p>
        <p>行为规范二：避免越界读取 JavaScript 对象的 element，或者避免越界读取 JavaScript 数组的属性，因为这种越界读取的行为会使得这个 JavaScript 对象或 JavaScript 数组的性能永远变差一些。具体来说，这是因为当 V8 引擎遇到越界读取时，V8 引擎就会在这个 JavaScript 对象或 JavaScript 数组的原型链上查找越界读取的属性，而搜索原型链是一件耗时的事情，并且 V8 引擎会认为这个 javaScript 对象或 JavaScript 数组在未来还会发生同样的事，然后就会将其标记为“总是需要进行特殊处理”的对象，这就导致了 V8 引擎以后在处理这个 JavaScript 对象或 JavaScript 数组的时候，总是要做一些额外的处理。</p>
        <p>行为规范三：使用数组来替代类数组。虽然我们可以通过 <code>Array.property.forEach.call( array_like, ( value, index ) =&gt; {} )</code> 的方式来在类数组身上调用数组的内置方法，但是这些内置方法在数组身上的运行效率要高得多。</p>
        <h4 id="e253f315-ab12-4e17-bd9f-cc99a1a559d2">用字典来存储</h4>
        <p>如果 V8 引擎遇到了以下三种情况中的任何一种，V8 引擎都会使用字典来存储 element，另外，这个字典是一个 <code>键-值-属性描述符</code> 格式的字典。最后，使用字典来存储 element 的好处是可以节省存储空间，坏处是访问的速度较慢。</p>
        <p>情况一：如果 element 中有大量的孔，那么 V8 引擎就会使用字典来存储 element。比如，下述代码会创建一个使用字典来存储 element 的 JavaScript 对象。</p>
        <pre><code class="language-js">const obj = { 999: 999 };
</code></pre>
        <p>又比如，下述代码会把一个原本使用数组来存储 element 的 JavaScript 对象，改为使用字典来存储 element。</p>
        <pre><code class="language-js">const obj = { 0: 0 };

obj[ 999 ] = 999;
</code></pre>
        <p>你可以通过 <a href="https://zhuanlan.zhihu.com/p/192468212">这篇文章</a> 来进一步了解，当 element 中出现了多少孔时，V8 引擎才会用字典容器来替换数组容器，以及当 element 中的孔减少到多少时，V8 引擎才会用数组容器来替代字典容器。</p>
        <p>情况二：如果使用 <code>Object.defineProperty</code> API 来创建一个新的数组索引属性，那么 V8 引擎就会使用字典来存储 element。比如，下述代码创建一个使用字典来存储 element 的 JavaScript 对象。</p>
        <pre><code class="language-js">const obj = {};

Object.defineProperty( obj, &quot;0&quot;, { value: 0 } );
</code></pre>
        <p>情况三：如果使用 <code>Object.defineProperty</code> API 来修改一个已存在的数组索引属性的 <code>enumarable</code> 和 <code>configurable</code>，那么 V8 引擎就会使用字典来存储 element。比如，下述代码会将一个原本使用数组来存储 element 的 JavaScript 对象变为使用字典来存储 element 的 JavaScript 对象。</p>
        <pre><code class="language-js">const obj = { &quot;0&quot;: 0 };

Object.defineProperty( obj, &quot;0&quot;, { enumerable: false } );
</code></pre>
        <h2 id="e26f934b-60ca-4661-a153-5a019f9ebaef">参考</h2>
        <ul>
            <li><a href="https://v8.dev/blog/fast-properties">Fast properties in V8</a></li>
            <li><a href="https://v8.dev/blog/elements-kinds">Elements kinds in V8</a></li>
            <li><a href="https://itnext.io/v8-deep-dives-understanding-array-internals-5b17d7a28ecc">[V8 Deep Dives] Understanding Array Internals</a></li>
        </ul>
    </article>
</body>

</html>