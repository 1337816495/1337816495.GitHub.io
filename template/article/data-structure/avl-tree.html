<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL 树</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=fc9a2ee4-16f0-498f-8a12-8522e16ca7cd>概述</p>
        <p data-target-id=3b310062-5717-42e1-94a2-1f0cf64a374b>平衡因子</p>
        <p data-target-id=1d788ef0-59a4-4bb9-9d05-bbf5d52c1a1f>平衡操作</p>
        <p data-target-id=dcaaa9b4-ae9d-401a-903b-6d2942924c46>实现</p>
        <p data-target-id=eaf39ea4-3483-49ff-9b19-a85e0a7cf4a9>源码</p>
    </aside>
    <article>
        <h1>AVL 树</h1>
        <h2 id="fc9a2ee4-16f0-498f-8a12-8522e16ca7cd">概述</h2>
        <p>AVL 树（Adelson-Velskii-Landi Tree）是计算机科学中最早被发明的自平衡二叉搜索树，而自平衡树是一种会自动保持平衡的二叉树。具体来说，每当新增或删除节点之后，自平衡二叉搜索树都会检查自身是否仍然处于平衡状态，如果任意节点的左侧子树和右侧子树的高度差不大于 <code>1</code>，那么就可以认为自己处于平衡状态，否则自平衡二叉树就需要通过旋转操作来使自己回归到平衡状态。</p>
        <p>相较于二叉搜索树，AVL 树的新增、删除、搜索操作在平均和最坏情况下的时间复杂度都是 <code>O(logn)</code>，这得益于 AVL 树总是会保持着一种较为接近满二叉树的形态。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>二叉搜索树是 AVL 树的基础，如果你不了解二叉搜索树，那么你可以通过本博客的另一篇文章《二叉搜索树》来了解它。</p>
        </blockquote>
        <h2 id="3b310062-5717-42e1-94a2-1f0cf64a374b">平衡因子</h2>
        <p>AVL 树在每次新增和移除节点之后，都要检查每个节点是否处于平衡状态，而平衡因子（Balance Factor）就是一个量化平衡状态的指标，它的定义是：左子树的高度减去右子树的高度（反之亦可）。</p>
        <p>如果 AVL 树中某个节点的平衡因子的大于 <code>1</code> 了，那么就意味着该节点的左子树和右子树的高度差超过了 <code>1</code>，这时就要对 AVL 树进行旋转操作，来使其回归到平衡状态。</p>
        <p>下图展示了一棵二叉树的各个节点的高度（<code>h</code>）和平衡因子（<code>bc</code>）。</p>
        <p><img src="/static/image/markdown/data-structure/avl-tree/avl-tree-balance-factor.png" alt="AVL树的平衡因子"></p>
        <h2 id="1d788ef0-59a4-4bb9-9d05-bbf5d52c1a1f">平衡操作</h2>
        <p>当 AVL 树新增或移除一个节点之后，如果有某些节点变得不平衡了，那么我们就需要从深度最深的不平衡节点开始，自下而上的处理每一个不平衡的节点，直至处理完 AVL 树的根节点。</p>
        <p>在 AVL 树中，我们使用旋转来处理不平衡的节点，旋转是指：通过挪移节点的位置，来使树回归到平衡状态。由于新树看起来就像是旧树进行顺/逆时针旋转后的产物，所以我们把这个挪移操作比喻为旋转。</p>
        <p>在 AVL 树中，如果某个节点变得不平衡了，那么这个节点一定会呈现出 4 种形态中的一种，这 4 种形态分别是：左-左、右-右、左-右、右-左。而这 4 种形态分别对应 4 种旋转操作，分别是：右旋、左旋、左旋再右旋、右旋再左旋。我们将在后文详细解释这 4 种形态与旋转。</p>
        <h3 id="da1af8b7-7fb1-4010-acd6-97b518e5665f">原理</h3>
        <p>让我们举个例子来看看 AVL 树是如何旋转的吧。</p>
        <p>下图展示了一棵原本平衡的 AVL 树，当我们插入了 <code>70</code> 节点后，树中的 <code>40</code> 和 <code>80</code> 节点就变得不平衡了，因为它们的平衡因子分别是 <code>-2</code> 和 <code>2</code>。这时我们就需要旋转该树，具体的操作步骤如下：</p>
        <ol>
            <li>旋转蓝框内的树。</li>
            <li>检查以 <code>30</code> 节点为根节点的树是否平衡：<ol>
                    <li>如果不平衡，那么就旋转这棵树。</li>
                    <li>如果平衡，那么就跳转到下一步。</li>
                </ol>
            </li>
            <li>旋转黄框内的树。</li>
        </ol>
        <p><img src="/static/image/markdown/data-structure/avl-tree/avl-tree-rotation-example.png" alt="AVL树的平衡操作"></p>
        <p>当我们对蓝框内的树进行了旋转之后，这棵树就回归平衡状态了。不过由于这棵树的形态发生了改变，所以以这棵树为子节点的树的形态也会发生改变，具体来说，就是以 <code>30</code> 节点作为根节点的树的形态会发生改变。</p>
        <p>这时我们就需要再检查 <code>30</code> 节点的平衡因子，如果 <code>30</code> 节点不平衡了，那么我们就需要对其进行旋转，否则就不需要进行旋转。而无论 <code>30</code> 节点旋转与否，以 <code>30</code> 节点作为根节点的树的形态都已经发生了改变，这就导致了以 <code>80</code> 节点作为根节点的树的形态也会发生改变。</p>
        <p>这时我们需要继续向上检查 <code>80</code> 节点，并在需要时对其进行旋转。因为 <code>80</code> 节点是整棵树的根节点，所以我们处理到 <code>80</code> 节点就为止了。然而，如果 <code>80</code> 节点还有父节点话，那么我们就需要继续向上检查和处理。</p>
        <p>很显然，整个处理过程是自下而上的，就像冒泡一样。总结来说，无论 AVL 树中出现了多少个不平衡的节点，AVL 树的平衡处理都是从深度最深的不平衡节点开始进行旋转，然后沿着路径，不断向上检查和旋转，直到处理完根节点为止。</p>
        <h3 id="6fd25319-9b20-4e66-a269-1e5b0b61e2a0">左旋 vs 右-右</h3>
        <p>右-右形态是指：树的平衡因子为 <code>-2</code>，且右侧子节点的平衡因子为 <code>0</code> 或 <code>-1</code>。</p>
        <p>当树呈现右-右形态时，我们就需要对其进行左旋，具体操作是：</p>
        <ol>
            <li>右侧子节点替代根节点，成为新的根节点。</li>
            <li>新根节点的左侧子节点转移给旧根节点，成为旧根节点的右侧子节点。</li>
            <li>旧根节点成为新根节点的左侧子节点。</li>
        </ol>
        <p><img src="/static/image/markdown/data-structure/avl-tree/avl-tree-rotate-left.png" alt="左旋"></p>
        <h3 id="92c148f9-23bc-449f-bd0c-180e40261674">右旋 vs 左-左</h3>
        <p>左-左形态是指：树的平衡因子为 <code>2</code>，且左侧子节点的平衡因子为 <code>0</code> 或 <code>1</code>。</p>
        <p>当树呈现左-左形态时，我们就需要对其进行右旋，具体操作时：</p>
        <ol>
            <li>左侧子节点替代根节点，成为新的根节点。</li>
            <li>新根节点的右侧子节点转移给旧根节点，成为旧根节点的左侧子节点。</li>
            <li>旧根节点成为新根节点的右侧子节点。</li>
        </ol>
        <p><img src="/static/image/markdown/data-structure/avl-tree/avl-tree-rotate-right.png" alt="右旋"></p>
        <h3 id="cfc1496c-ce67-4b65-913b-10a77f79d465">左旋再右旋</h3>
        <p>左-右形态是指：树的平衡因子为 <code>2</code>，且左侧子节点的平衡因子为 <code>-1</code>。</p>
        <p>左旋再右旋用于处理左-右形态的不平衡节点，其具体操作是：</p>
        <ol>
            <li>对树的左侧子节点进行左旋，来将树转换成左-左形态。</li>
            <li>对树进行右旋。</li>
        </ol>
        <p><img src="/static/image/markdown/data-structure/avl-tree/avl-tree-rotate-left-right.png" alt="左旋再右旋"></p>
        <h3 id="79da24f9-d9c1-46e2-8980-0adb5cd83f30">右旋再左旋</h3>
        <p>左-右形态是指：树的平衡因子为 <code>-2</code>，且左侧子节点的平衡因子为 <code>1</code>。</p>
        <p>右旋再左旋用于处理右-左形态的不平衡节点，其具体操作是：</p>
        <ol>
            <li>对树的右侧子节点进行右旋，来将树转换成右-右形态。</li>
            <li>对树进行左旋。</li>
        </ol>
        <p><img src="/static/image/markdown/data-structure/avl-tree/avl-tree-rotate-right-left.png" alt="右旋再左旋"></p>
        <h2 id="dcaaa9b4-ae9d-401a-903b-6d2942924c46">实现</h2>
        <p>本文将会实现一个名为 <code>AdelsonVelskiiLandiTree</code> 的 AVL 树类，这个类将会拥有和 <code>BinarySearchTree</code> 一样的方法。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p><code>BinarySearchTree</code> 是本博客的另一篇文章《二叉搜索树》中所实现的二叉搜索树的类。</p>
        </blockquote>
        <p>为了复用代码，<code>AdelsonVelskiiLandiTree</code> 将会继承自 <code>BinarySearchTree</code>，不过我们需要重写 <code>AdelsonVelskiiLandiTree</code> 中的 <code>insert</code> 和 <code>remove</code> 方法，因为 AVL 树需要在插入和移除节点后，进行自平衡操作。</p>
        <p>最后，<code>AdelsonVelskiiLandiTree</code> 类所拥有的方法如下：</p>
        <table>
            <thead>
                <tr>
                    <th>方法名</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>insert( value )</code></td>
                    <td>插入一个值为 <code>value</code> 的节点，然后返回更新后的树。</td>
                </tr>
                <tr>
                    <td><code>remove( value )</code></td>
                    <td>移除一个值为 <code>value</code> 的节点，然后返回更新后的树。</td>
                </tr>
                <tr>
                    <td><code>search( value )</code></td>
                    <td>搜索一个值为 <code>value</code> 的节点，然后返回一个布尔值来代表该节点是否存在。</td>
                </tr>
                <tr>
                    <td><code>inorderTraverse( callback )</code></td>
                    <td>中序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。</td>
                </tr>
                <tr>
                    <td><code>preorderTraverse( callback )</code></td>
                    <td>先序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。</td>
                </tr>
                <tr>
                    <td><code>postorderTraverse( callback )</code></td>
                    <td>后序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。</td>
                </tr>
            </tbody>
        </table>
        <h3 id="ca7333f9-f8d0-4d9d-b5b5-4b8ee7b5d90f">创建类</h3>
        <p>首先，让我们来创建 <code>AdelsonVelskiiLandiTree</code> 的类。</p>
        <pre><code class="language-js">class AdelsonVelskiiLandiTree extends BinarySearchTree {

    constructor () { super() }

}
</code></pre>
        <h3 id="d588aa85-8c1e-4de4-bf4e-330e59fd881d">创建 _balance 方法</h3>
        <p>在插入和移除一个节点之后，我们都需要对树进行平衡化处理，那么我们就需要编写一个平衡化处理的方法，<code>_balance</code> 就是这个平衡化处理的方法。由于平衡化处理是不需要暴露给外界的，所以 <code>_balance</code> 是一个内部方法。</p>
        <p><code>_balance</code> 方法的内部包含了许多子函数，这些子函数用于：计算节点高度、计算节点平衡因子、左旋、右旋、左旋再右旋、右旋再左旋。这些子函数是实现平衡化处理的必要套件。</p>
        <p>下文便是 <code>_balance</code> 方法的实现代码：</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class AdelsonVelskiiLandiTree extends BinarySearchTree {

    /**
     * （内部方法）对树进行平衡处理。
     * @param { Object } root - 树的根节点。
     * @returns { Object } - 处理后的新树的根节点。
     */
    _balance ( root ) {

        const root_balance_factor = calculateBalanceFactor( root );

        /* 树已平衡，无需处理。 */
        if ( root_balance_factor === 0 ) return root;
        if ( root_balance_factor === 1 ) return root;
        if ( root_balance_factor === - 1 ) return root;

        /* 树非平衡，需要处理。 */
        if ( root_balance_factor === 2 ) {

            const left_balance_factor = calculateBalanceFactor( root.left );

            switch ( left_balance_factor ) {

                case 0: return rotateRight( root );       // 处理左-左形态。

                case 1: return rotateRight( root );       // 处理左-左形态。

                case - 1: return rotateLeftRight( root ); // 处理左-右形态。

            }

        }

        if ( root_balance_factor === - 2 ) {

            const right_balance_factor = calculateBalanceFactor( root.right );

            switch ( right_balance_factor ) {

                case 0: return rotateLeft( root );      // 处理右-右形态。

                case 1: return rotateRightLeft( root ); // 处理右-左形态。

                case - 1: return rotateLeft( root );    // 处理右-右形态。

            }

        }

        /**
         * 计算根节点的高度。
         * @param { Object } root - 树的根节点。
         * @returns { number } - 高度。
         */
        function calculateHeight ( root ) {

            if ( root === undefined ) return - 1;

            return Math.max( calculateHeight( root.left ), calculateHeight( root.right ) ) + 1;

        }

        /**
         * 计算根节点的平衡因子（左子树高度-右子树高度）。
         * @param { Object } root - 树的根节点。
         * @returns { number } - 平衡因子。
         */
        function calculateBalanceFactor ( root ) {

            if ( root === undefined ) return;
            if ( root.left === undefined &amp;&amp; root.right === undefined ) return 0;
            if ( root.left === undefined ) return - calculateHeight( root.right ) - 1;
            if ( root.right === undefined ) return calculateHeight( root.left ) + 1;

            return calculateHeight( root.left ) - calculateHeight( root.right );

        }

        /**
         * 向左旋转树，用于处理左-左形态的非平衡树。
         * @param { Object } root - 树的根节点。
         * @returns { Object } - 旋转后的新树的根节点。
         */
        function rotateLeft ( root ) {

            const new_root = root.right;

            root.right = new_root.left;
            new_root.left = root;

            return new_root;

        }

        /**
         * 向右旋转树，用于处理右-右形态的非平衡树。
         * @param { Object } root - 树的根节点。
         * @returns { Object } - 旋转后的新树的根节点。
         */
        function rotateRight ( root ) {

            const new_root = root.left;

            root.left = new_root.right;
            new_root.right = root;

            return new_root;

        }

        /**
         * 先向左旋转树的左子树，再向右旋转树，用于处理左-右形态的非平衡树。
         * @param { Object } root - 树的根节点。
         * @returns { Object } - 旋转后的新树的根节点。
         */
        function rotateLeftRight ( root ) {

            root.left = rotateLeft( root.left );

            return rotateRight( root );

        }

        /**
         * 先向右旋转树的右子树，再向左旋转树，用于处理右-左形态的非平衡树。
         * @param { Object } root - 树的根节点。
         * @returns { Object } - 旋转后的新树的根节点。
         */
        function rotateRightLeft ( root ) {

            root.right = rotateRight( root.right );

            return rotateLeft( root );

        }

    }

}
</code></pre>
        <h3 id="5ae140b8-64c2-4282-83ad-3bd7c570e48c">重写 insert 方法</h3>
        <p><code>AdelsonVelskiiLandiTree</code> 的 <code>insert</code> 方法和 <code>BinarySearchTree</code> 的 <code>insert</code> 方法几乎是一模一样的，关键的区别在于，前者增加了一行平衡化处理的代码（<code>const balance_root = balance( root )</code>）。随着 <code>core</code> 递归调用自身，这行代码会自下而上的对树进行平衡化处理。</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class AdelsonVelskiiLandiTree extends BinarySearchTree {

    /**
     * 插入节点，并对树进行平衡处理。
     * @param { number } value - 节点的值。
     * @returns { Object } - 更新后的BinarySearchTree实例。
     */
    insert ( value ) {

        const balance = this._balance;

        this.root = core( this.root, value );

        return this;

        function core ( root, value ) {

            /* 基线条件 */
            if ( root === undefined ) return new BinarySearchTreeNode( value );
            if ( root.value === value ) throw new Error( &quot;This value already exists.&quot; );

            /* 递归 */
            if ( root.value &gt; value ) root.left = core( root.left, value );
            if ( root.value &lt; value ) root.right = core( root.right, value );

            /* 平衡化 */
            const balance_root = balance( root );

            /*  */
            return balance_root;

        }

    }

}
</code></pre>
        <h3 id="930397b5-bb0c-48aa-89c5-277f14883595">重写 remove 方法</h3>
        <p><code>AdelsonVelskiiLandiTree</code> 的 <code>remove</code> 方法和 <code>BinarySearchTree</code> 的 <code>remove</code> 方法几乎是一模一样的，关键的区别在于，前者增加了两行平衡化处理的代码，同理，随着 <code>core</code> 递归调用自身，这两行代码会自下而上的对树进行平衡化处理。</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class AdelsonVelskiiLandiTree extends BinarySearchTree {

    /**
     * 删除节点，并对树进行平衡处理。
     * @param { number } value - 节点的值。
     * @returns { Object } - 更新后的BinarySearchTree实例。
     */
    remove ( value ) {

        const balance = this._balance;

        this.root = core( this.root, value );

        return this;

        function core ( root, value ) {

            /* 基线条件 */
            if ( root === undefined ) return;
            if ( root.value === value ) {

                if ( root.left === undefined &amp;&amp; root.right === undefined ) return;
                if ( root.left === undefined ) return root.right;
                if ( root.right === undefined ) return root.left;

                const new_root = new BinarySearchTreeNode( findMaxValue( root.left ) );
                const new_left = core( root.left, new_root.value );
                const new_right = root.right;

                new_root.left = new_left;
                new_root.right = new_right;

                const balance_root = balance( new_root );

                return balance_root;

            }

            /* 递归 */
            if ( root.value &gt; value ) root.left = core( root.left, value );
            if ( root.value &lt; value ) root.right = core( root.right, value );

            const balance_root = balance( root );

            return balance_root;

        }

        function findMaxValue ( root ) {

            if ( root.right === undefined ) return root.value;

            return findMaxValue( root.right );

        }

    }

}
</code></pre>
        <h2 id="eaf39ea4-3483-49ff-9b19-a85e0a7cf4a9">源码</h2>
        <p>你可以通过该 <a href="https://github.com/jynxio/leetcode-everyday">库</a> 的 <a href="https://github.com/jynxio/leetcode-everyday/blob/main/Tree.js">Tree.js</a> 文件，来获取 <code>AdelsonVelskiiLandiTree</code> 的完整源码。</p>
    </article>
</body>

</html>