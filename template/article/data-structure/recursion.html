<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>递归</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=1020d31a-dce3-484d-8bba-eefa81f442a8>概述</p>
        <p data-target-id=074ed235-50ec-4fad-9675-5873ca704a67>基线条件</p>
        <p data-target-id=1e3fb724-8e0f-4316-ad09-7d7db8f215c9>阶乘</p>
        <p data-target-id=53d5494a-b949-43f2-8ad4-c390527346ef>斐波那契数列</p>
        <p data-target-id=863dbcc3-31dd-4627-baf6-95414d2b0507>意义</p>
    </aside>
    <article>
        <h1>递归</h1>
        <h2 id="1020d31a-dce3-484d-8bba-eefa81f442a8">概述</h2>
        <p>递归函数是一种会调用自身的函数，比如这个 <code>loop</code> 函数就是一个递归函数。</p>
        <pre><code class="language-js">function loop () {

    console.log( 1 );

    loop();

}
</code></pre>
        <h2 id="074ed235-50ec-4fad-9675-5873ca704a67">基线条件</h2>
        <p>基线条件是指递归函数停止递归的条件，如果递归函数没有基线条件，那么递归函数就会无限的执行下去。一个无限递归的递归函数容易造成“爆栈”，最终导致程序被杀死，比如上文中的 <code>loop</code> 函数就会造成“爆栈”。</p>
        <pre><code class="language-js">loop(); // RangeError: Maximum call stack size exceeded
</code></pre>
        <p>编写递归函数是一项需要经验和灵感的工作，如果你不知道该如何开始编写一个递归函数，那么我建议你先找到递归函数的基线条件，这可以帮助你更快的找到头绪。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>如果你想了解什么是“爆栈”，那么你可以读读下面这则短文。</p>
            <p>JavaScript 引擎在执行一个函数之前，都会创建一个函数执行上下文，并将这个函数执行上下文推入调用栈中，直至函数执行完成之后，调用栈才会弹出该函数执行上下文。</p>
            <p>调用栈只能容纳有限的执行上下文，这是因为执行上下文是需要消耗内存空间的，而调用栈所拥有的内存空间又是有限的。当 JavaScript 引擎执行 <code>loop()</code> 时，引擎就会不断的向调用栈推入新创建的函数执行上下文，最终调用栈就会因为超出了承载上限而不得不停止执行，并抛出一个 <code>RangeError</code> 错误，这便是爆栈。</p>
            <p>如果你熟悉事件循环，那么你就可以通过一些奇技淫巧来避免“爆栈”，就像下面这个 <code>loop</code> 函数，它可以无限的执行下去，而不会爆栈。</p>
            <pre><code class="language-js">function loop () {

    console.log( 1 );

    setTimeout( loop, 0 );

}
</code></pre>
            <p>另外，或许你还听说过“尾调用优化”，这是另一种防止爆栈并提升递归性能的手段，不过请忘了它吧，因为除了 Apple 之外的浏览器厂商都拒绝实现该特性。</p>
        </blockquote>
        <h2 id="1e3fb724-8e0f-4316-ad09-7d7db8f215c9">阶乘</h2>
        <h3 id="e0d7da00-ca53-4285-9121-2c981408e1ba">概念</h3>
        <p>在数学中，正整数的阶乘是所有小于及等于该数的正整数的积，表示为 <code>n!</code>。比如 <code>5</code> 的阶乘表示为 <code>5!</code>，其值为 <code>120</code>，因为：</p>
        <pre><code>5! = 1 * 2 * 3 * 4 * 5 = 120
</code></pre>
        <p>另外，<code>1</code> 和 <code>0</code> 的阶乘都等于 <code>1</code>。</p>
        <h3 id="347186ae-6b89-49f1-af83-3e46f083d9d8">实现</h3>
        <p>灵感乍现，令我一下子找到了 <code>calculateFactorial</code> 函数的基线条件，然后顺势编写好了整个函数。</p>
        <pre><code class="language-js">function calculateFactorial( n ) {
    
    if ( n === 0 || n === 1 ) return 1; // 基线条件
    
    return n * calculateFactorial( n - 1 );
    
}
</code></pre>
        <h2 id="53d5494a-b949-43f2-8ad4-c390527346ef">斐波那契数列</h2>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>真怀念啊！我记得我的第一个 DOM 程序就是一个汉诺塔动画的网页，她还很兴奋的鼓励了我呢！</p>
        </blockquote>
        <h3 id="fa6da304-64e2-4398-b207-37dd799f0c16">概念</h3>
        <p>斐波那契数列是一个特殊的数列，它的规律是：</p>
        <ul>
            <li><code>0号元素 = 0</code></li>
            <li><code>1号元素 = 1</code></li>
            <li><code>2号元素 = 1</code></li>
            <li><code>n号元素 = n-1号元素 + n-2号元素</code></li>
        </ul>
        <h3 id="ae7bc266-4e47-4f7e-8aaf-2657b25b13f0">实现</h3>
        <p>这是第二次灵感乍现。</p>
        <pre><code class="language-js">function calculateFibonacci ( n ) {
    
    if ( n === 0 ) return 0;
    if ( n === 1 || n === 2 ) return 1;
    
    return calculateFibonacci( n - 1 ) + calculateFibonacci( n - 2 );
    
}
</code></pre>
        <h3 id="62ea7c28-60f5-41e4-9032-c3a836d80c36">优化</h3>
        <p>这是 <code>calculateFibonacci</code> 函数的优化版本，你分别使用旧版与新版的 <code>calculateFibonacci</code> 函数来计算 <code>20</code> 的斐波那契数，便会发现新版本的计算速度要快的多。</p>
        <pre><code class="language-js">const calculateFibonacci = createFibonacciCalculator();

function createFibonacciCalculator () {

    const cache = [ 0, 1, 1 ];
    
    return function calculateFibonacci ( n ) {

        if ( cache[ n ] !== undefined ) return cache[ n ];

        return cache[ n ] = calculateFibonacci( n - 1 ) + calculateFibonacci( n - 2 );

    }

}
</code></pre>
        <p>新版的 <code>calculateFibonacci</code> 函数之所以会更快，是因为它缓存了曾经计算过的斐波那契数，从而减少了很多重复的计算。</p>
        <h2 id="863dbcc3-31dd-4627-baf6-95414d2b0507">意义</h2>
        <p>递归函数的意义在于提高函数的可读性，如果你仔细阅读了上述两个例子的代码，你就会发现它们都是自解释的。</p>
        <p>不过，如果你期望得到的是高性能的函数，那么你可以尝试把递归函数改造成普通的迭代函数，迭代函数往往会比递归函数更快，这是因为创建额外的函数执行上下文会带来额外的性能负荷。</p>
    </article>
</body>

</html>