<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>递归</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=4323494a-372d-40ec-91ea-e473297bfcb9>概述</p>
        <p data-target-id=cd6fb8aa-33ef-4636-bd7b-b9f81c996a68>基线条件</p>
        <p data-target-id=728f5077-b0cb-4a73-a023-d9930eacefff>阶乘</p>
        <p data-target-id=cee5744d-dd70-463f-97f4-79bca2cd020d>斐波那契</p>
        <p data-target-id=93081a21-9494-4cda-9f64-5123fb0e0ac7>深拷贝</p>
        <p data-target-id=aafae83c-1c85-49b7-87eb-aaf629e754ba>意义</p>
    </aside>
    <article>
        <h1>递归</h1>
        <h2 id="4323494a-372d-40ec-91ea-e473297bfcb9">概述</h2>
        <p>递归函数是一种会调用自身的函数，比如这个 <code>loop</code> 函数就是一个递归函数。</p>
        <pre><code class="language-js">function loop () {

    console.log( 1 );

    loop();

}
</code></pre>
        <h2 id="cd6fb8aa-33ef-4636-bd7b-b9f81c996a68">基线条件</h2>
        <p>基线条件是指递归函数停止递归的条件，如果递归函数没有基线条件，那么递归函数就会无限的执行下去。一个无限递归的递归函数容易造成“爆栈”，最终导致程序被杀死，比如上文中的 <code>loop</code> 函数就会造成“爆栈”。</p>
        <pre><code class="language-js">loop(); // RangeError: Maximum call stack size exceeded
</code></pre>
        <p>编写递归函数是一项需要经验和灵感的工作，如果你不知道该如何开始编写一个递归函数，那么我建议你先找到递归函数的基线条件，这可以帮助你更快的找到头绪。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>如果你想了解什么是“爆栈”，那么你可以读读下面这则短文。</p>
            <p>JavaScript 引擎在执行一个函数之前，都会创建一个函数执行上下文，并将这个函数执行上下文推入调用栈中，直至函数执行完成之后，调用栈才会弹出该函数执行上下文。</p>
            <p>调用栈只能容纳有限的执行上下文，这是因为执行上下文是需要消耗内存空间的，而调用栈所拥有的内存空间又是有限的。当 JavaScript 引擎执行 <code>loop()</code> 时，引擎就会不断的向调用栈推入新创建的函数执行上下文，最终调用栈就会因为超出了承载上限而不得不停止执行，并抛出一个 <code>RangeError</code> 错误，这便是爆栈。</p>
            <p>如果你熟悉事件循环，那么你就可以通过一些奇技淫巧来避免“爆栈”，就像下面这个 <code>loop</code> 函数，它可以无限的执行下去，而不会爆栈。</p>
            <pre><code class="language-js">function loop () {

    console.log( 1 );

    setTimeout( loop, 0 );

}
</code></pre>
            <p>另外，或许你还听说过“尾调用优化”，这是另一种防止爆栈并提升递归性能的手段，不过请忘了它吧，因为除了 Apple 之外的浏览器厂商都拒绝实现该特性。</p>
        </blockquote>
        <h2 id="728f5077-b0cb-4a73-a023-d9930eacefff">阶乘</h2>
        <h3 id="b8cb8616-c932-42b3-bac7-d963dba6d6ba">概念</h3>
        <p>在数学中，正整数的阶乘是所有小于及等于该数的正整数的积，我们把它表示为 <code>n!</code>，另外 <code>1</code> 和 <code>0</code> 的阶乘都等于 <code>1</code>。让我们来举个例子，<code>5</code> 的阶乘表示为 <code>5!</code>，其值为 <code>120</code>，因为：</p>
        <pre><code>5! = 1 * 2 * 3 * 4 * 5 = 120
</code></pre>
        <h3 id="82c6cf3a-80f1-407f-9dbb-0b8fa95198da">实现</h3>
        <p>灵感乍现，我一下子找到了 <code>calculateFactorial</code> 函数的基线条件，然后顺势编写好了整个函数。</p>
        <pre><code class="language-js">function calculateFactorial( n ) {

    if ( n === 0 || n === 1 ) return 1; // 基线条件

    return n * calculateFactorial( n - 1 );

}
</code></pre>
        <h2 id="cee5744d-dd70-463f-97f4-79bca2cd020d">斐波那契</h2>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>真怀念啊！我记得我的第一个 DOM 程序就是一个汉诺塔动画的网页，她还很兴奋的鼓励了我呢！</p>
        </blockquote>
        <h4 id="fa384dab-584a-4cdd-a68a-a4d035a0d3d0">概念</h4>
        <p>斐波那契数列是一个特殊的数列，它的规律是：</p>
        <ul>
            <li><code>0号元素 = 0</code></li>
            <li><code>1号元素 = 1</code></li>
            <li><code>2号元素 = 1</code></li>
            <li><code>n号元素 = n-1号元素 + n-2号元素</code></li>
        </ul>
        <h4 id="e2a85fc2-22d7-4fcc-bb23-5fe8795daa2e">实现</h4>
        <p>这是第二次灵感乍现。</p>
        <pre><code class="language-js">function calculateFibonacci ( n ) {

    /* 基线条件 */
    if ( n === 0 ) return 0;
    if ( n === 1 || n === 2 ) return 1;

    /*  */
    return calculateFibonacci( n - 1 ) + calculateFibonacci( n - 2 );

}
</code></pre>
        <h4 id="7b13186b-d259-4dc8-86ac-13b4ab08083d">优化</h4>
        <p>这是 <code>calculateFibonacci</code> 函数的优化版本，你分别使用旧版与新版的 <code>calculateFibonacci</code> 函数来计算 <code>20</code> 的斐波那契数，便会发现新版本的计算速度要快的多。</p>
        <pre><code class="language-js">const calculateFibonacci = createFibonacciCalculator();

function createFibonacciCalculator () {

    const cache = [ 0, 1, 1 ];

    return function calculateFibonacci ( n ) {

        if ( cache[ n ] !== undefined ) return cache[ n ]; // 基线条件

        return cache[ n ] = calculateFibonacci( n - 1 ) + calculateFibonacci( n - 2 );

    }

}
</code></pre>
        <p>新版的 <code>calculateFibonacci</code> 函数之所以会更快，是因为它缓存了曾经计算过的斐波那契数，从而减少了很多重复的计算。</p>
        <h2 id="93081a21-9494-4cda-9f64-5123fb0e0ac7">深拷贝</h2>
        <p>这是一个深拷贝的简单实现，它可以深拷贝普通对象。</p>
        <pre><code class="language-js">function deepClone ( source ) {

    /* 基线条件 */
    if ( typeof source !== &quot;object&quot; ) return source;

    /*  */
    const target = {};
    const keys = Object.keys( source );

    keys.forEach( key =&gt; target[ key ] = deepClone( source[ key ] ) );

    return target;

}
</code></pre>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>如果你想在生产环境中使用深拷贝，那么请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/structuredClone">structuredClone API</a>，这是一个由 HTML5 规范定义的深拷贝方法，它已内建于浏览器运行时与 Node.js 运行时中，它的兼容性良好。</p>
            <p><code>structuredClone</code> 比 <code>_.cloneDeep()</code> 和 <code>JSON.parse(JSON.stringify())</code> 更好，你可以从 <a href="https://www.builder.io/blog/structured-clone">这篇文章</a> 了解到更多。</p>
        </blockquote>
        <h2 id="aafae83c-1c85-49b7-87eb-aaf629e754ba">意义</h2>
        <p>递归函数的意义在于提高函数的可读性，如果你仔细阅读了上述两个例子的代码，你就会发现它们都是自解释的。</p>
        <p>不过，如果你期望得到的是高性能的函数，那么你可以尝试把递归函数改造成普通的迭代函数，迭代函数往往会比递归函数更快，这是因为创建额外的函数执行上下文会带来额外的性能负荷。</p>
    </article>
</body>

</html>