<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二叉堆</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=f9bfe536-b9f3-438b-b6a2-f350dd40561e>概述</p>
        <p data-target-id=d123be56-6be1-48ca-b670-0d53305bbb61>实现</p>
        <p data-target-id=1e2dec02-b0cb-468f-909c-73b560c74f20>堆排序算法</p>
        <p data-target-id=70703d95-6d8a-4be8-a82a-317c0a55b280>动态中位数算法</p>
        <p data-target-id=e0bc4370-91df-4e75-b095-52ee30e5c09d>源码</p>
    </aside>
    <article>
        <h1>二叉堆</h1>
        <h2 id="f9bfe536-b9f3-438b-b6a2-f350dd40561e">概述</h2>
        <p>二叉堆是一种特殊的完全二叉树，其分为最小堆和最大堆。其中，最小堆的定义是：父节点的值必须不大于子节点的值，而最大堆的定义是：父节点的值必须不小于子节点的值。</p>
        <p><img src=/static/image/markdown/data-structure/binary-heap/minheap-and-maxheap.png alt=最小堆和最大堆 loading="lazy" decoding="async"></p>
        <h2 id="d123be56-6be1-48ca-b670-0d53305bbb61">实现</h2>
        <p>我们将会实现 3 个类，分别是 <code>BaseHeap</code>、<code>MinHeap</code>、<code>MaxHeap</code>，其中 <code>BaseHeap</code> 是 <code>MinHeap</code> 和 <code>MaxHeap</code> 的父类。</p>
        <p>之所以要这么做，是因为 <code>MinHeap</code> 的实现过程几乎和 <code>MaxHeap</code> 的实现过程一模一样，唯一的区别只在于，两者在数值比较上的做法完全相反。你只要浏览一下后文的实现代码，就会立即明白我的意思。</p>
        <p>我们实现的 <code>MinHeap</code> 和 <code>MaxHeap</code> 将会拥有下述方法，并且我们会把这些公共方法提取到 <code>BaseHeap</code> 中去。</p>
        <table>
            <thead>
                <tr>
                    <th>方法名</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>getCount()</code></td>
                    <td>获取堆的节点的数量。</td>
                </tr>
                <tr>
                    <td><code>getTree()</code></td>
                    <td>获取完全二叉树格式的堆，以便于查看堆的内容。</td>
                </tr>
                <tr>
                    <td><code>shift()</code></td>
                    <td>移除堆的第一个节点（极值节点），然后返回堆本身。</td>
                </tr>
                <tr>
                    <td><code>insert( value )</code></td>
                    <td>向堆插入一个值，然后返回堆本身。</td>
                </tr>
            </tbody>
        </table>
        <p>另外，<code>MinHeap</code> 和 <code>MaxHeap</code> 各自都会拥有一个独属于自己的方法。对于 <code>MinHeap</code> 来说，这个方法是：</p>
        <table>
            <thead>
                <tr>
                    <th>方法名</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>getMinimum</code></td>
                    <td>获取堆的最小值。</td>
                </tr>
            </tbody>
        </table>
        <p>对于 <code>MaxHeap</code> 来说，这个方法是：</p>
        <table>
            <thead>
                <tr>
                    <th>方法名</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>getMaximum</code></td>
                    <td>获取堆的最大值。</td>
                </tr>
            </tbody>
        </table>
        <h3 id="0190d050-4987-4fa8-90ca-b474f5451f9e">存储容器</h3>
        <p>在真正开始实现二叉堆之前，我们需要选择一种数据结构来存储二叉堆的数据。</p>
        <p>在 <a href="https://www.jynxio.com/article/data-structure/binary-search-tree.html">二叉搜索树</a> 一文中，我们使用了 JavaScript 中的普通对象 <code>{}</code> 来作为存储数据的容器。虽然二叉堆也是二叉树的一种，但是我们会选用数组来作为存储数据的容器，这是因为数组非常适合用来实现完全二叉树。</p>
        <p>如果我们使用数组来存储二叉堆的数据，那么我们就可以获得如下规律：</p>
        <ul>
            <li>如果一个节点的序号是 <code>index</code>，那么其父节点的序号就是 <code>Math.floor( ( index - 1 ) / 2 )</code>。</li>
            <li>如果一个节点的序号是 <code>index</code>，那么其左子节点的序号就是 <code>2 * index + 1</code>。</li>
            <li>如果一个节点的序号是 <code>index</code>，那么其右子节点的序号就是 <code>2 * index + 2</code>。</li>
        </ul>
        <h3 id="6e693483-c8aa-4760-a2c6-f39b6dd10e49">实现 BaseHeap</h3>
        <p><code>BaseHeap</code> 的实现代码如下所示：</p>
        <pre><code class="language-javascript">class BaseHeap {

    /**
     * 最小堆类和最大堆类的基类，该类仅用于实现最小堆类和最大堆类，你不应该直接使用该类。
     * @param { string } - 比较的模式，仅接受&quot;MinHeap&quot;或&quot;MaxHeap&quot;。
     * @returns { Object } - 基类的实例。
     */
    constructor ( comparative_mode ) {

        if ( comparative_mode !== &quot;MinHeap&quot; &amp;&amp; comparative_mode !== &quot;MaxHeap&quot; ) throw new Error( &quot;实例化失败，因为入参不合法。&quot; );

        this._heap = [];
        this._comparativeMode = comparative_mode;

    }

    /**
     * 向堆插入一个值。
     * @param { number } value - 待插入的值。
     * @returns { Object } - 实例本身。
     */
    insert ( value ) {

        this._heap.push( value );
        this._shiftUp( this.getCount() - 1 );

        return this;

    }

    /**
     * 移除堆的第一个节点（即极值节点）。
     * @returns { Object } - 实例本身。
     */
    shift () {

        if ( this.getCount() === 0 ) return this;
        if ( this.getCount() === 1 ) {

            this._heap.length --;

            return this;

        }

        this._swap( 0, this.getCount() - 1 );
        this._heap.length --;
        this._shiftDown( 0 );

        return this;

    }

    /**
     * 获取堆的节点数。
     * @returns { number } - 堆的节点数。
     */
    getCount () {

        return this._heap.length;

    }

    /**
     * 获取堆的极值（即第一个节点的值）。
     * @returns { number } - 对于最小堆而言，是最小值。对于最大堆而言，是最大值。
     */
    _getExtremum () {

        if ( this.getCount() === 0 ) throw new Error( &quot;获取失败：因为该堆为空。&quot; );

        return this._heap[ 0 ];

    }

    /**
     * 获取完全二叉树格式的堆。
     */
    getTree () {

        const core = index =&gt; {

            /* 基线条件 */
            if ( index === - 1 ) return;

            const node = {};

            node.value = this._heap[ index ];
            node.leftChild = core( this._getLeftChildIndex( index ) );
            node.rightChild = core( this._getRightChildIndex( index ) );

            return node;

        };

        return core( 0 );

    }

    /**
     * （内部方法）获取父节点的index。
     * @param { number } index - 当前节点的index。
     * @returns { number } - 父节点的index（如果当前节点没有父节点，那么就会返回-1）。
     */
    _getParentIndex ( index ) {

        if ( index &gt;= this.getCount() ) throw new Error( &quot;获取失败：因为入参不合法。&quot; );

        return Math.floor( ( index - 1 ) / 2 );

    }

    /**
     * （内部方法）获取左子节点的index。
     * @param { number } index - 当前节点的index。
     * @returns { number } - 左子节点的index（如果当前节点没有左子节点，那么就会返回-1）。
     */
    _getLeftChildIndex ( index ) {

        if ( index &gt;= this.getCount() ) throw new Error( &quot;获取失败：因为入参不合法。&quot; );

        const left_child_index = index * 2 + 1;

        if ( left_child_index &gt;= this.getCount() ) return - 1;

        return left_child_index;

    }

    /**
     * （内部方法）获取右子节点的index。
     * @param { number } index - 当前节点的index。
     * @returns { number } - 右子节点的index（如果当前节点没有右子节点，那么就会返回-1）。
     */
    _getRightChildIndex ( index ) {

        if ( index &gt;= this.getCount() ) throw new Error( &quot;获取失败：因为入参不合法。&quot; );

        const right_child_index = index * 2 + 2;

        if ( right_child_index &gt;= this.getCount() ) return - 1;

        return right_child_index;

    }

    /**
     * （内部方法）比较第一个值是否不大于第二个值，或第二个值是否不大于第一个值。
     * @param { number } value_1 - 第一个值。
     * @param { number } value_2 - 第二个值。
     * @returns { boolean } - 如果是最小堆的实例调用该方法，那么就会返回value_1 &lt;= value_2的结果。如果是最大堆的实例调用该方法，那么就会返回value_1 &gt;= value_2的结果。
     */
    _compare ( value_1, value_2 ) {

        if ( this._comparativeMode === &quot;MinHeap&quot; ) return value_1 &lt; value_2;
        if ( this._comparativeMode === &quot;MaxHeap&quot; ) return value_1 &gt; value_2;

        throw new Error( &quot;比较失败：因为发生了意外的情况。&quot; );

    }

    /**
     * （内部方法）交换两个节点的值。
     * @param { number } index_1 - 第一个节点的index。
     * @param { number } index_2 - 第二个节点的index。
     */
    _swap ( index_1, index_2 ) {

        if ( index_1 &gt;= this.getCount() ) throw new Error( &quot;交换失败：因为入参不合法。&quot; );
        if ( index_2 &gt;= this.getCount() ) throw new Error( &quot;交换失败：因为入参不合法。&quot; );

        [ this._heap[ index_1 ], this._heap[ index_2 ] ] = [ this._heap[ index_2 ], this._heap[ index_1 ] ];

    }

    /**
     * （内部方法）上移节点，通过向上移动节点来使堆保持正确。
     * @param { number } index - 待上移的节点的index。
     */
    _shiftUp ( index ) {

        const parent_index = this._getParentIndex( index );

        /* 基线条件 */
        if ( parent_index === - 1 ) return;
        if ( ! this._compare( this._heap[ index ], this._heap[ parent_index ] ) ) return;

        this._swap( index, parent_index );
        this._shiftUp( parent_index );

    }

    /**
     * （内部方法）下移节点，通过向下移动节点来使堆保持正确。
     * @param { number } index - 待下移的节点的index。
     */
    _shiftDown( index ) {

        let largest_node_index = index;

        const left_child_index = this._getLeftChildIndex( index );
        const right_child_index = this._getRightChildIndex( index );

        left_child_index !== - 1
        &amp;&amp;
        this._compare( this._heap[ left_child_index ], this._heap[ largest_node_index ] )
        &amp;&amp;
        ( largest_node_index = left_child_index );

        right_child_index !== - 1
        &amp;&amp;
        this._compare( this._heap[ right_child_index ], this._heap[ largest_node_index ] )
        &amp;&amp;
        ( largest_node_index = right_child_index );

        /* 基线条件 */
        if ( largest_node_index === index ) return;

        this._swap( index, largest_node_index );
        this._shiftDown( largest_node_index );

    }

}
</code></pre>
        <h3 id="9b9cd46a-e214-4831-9c43-9feb443c63fb">实现 MinHeap</h3>
        <p><code>MinHeap</code> 的实现代码如下所示：</p>
        <pre><code class="language-javascript">class MinHeap extends BaseHeap {

    /**
     * 最小堆类。
     * @returns { Object } - 最小堆类的实例。
     */
    constructor () {

        super( &quot;MinHeap&quot; );

    }

    /**
     * 获取堆的最小值。
     * @returns { number } - 堆的最小值。
     */
    getMinimum () {

        return this._getExtremum();

    }

}
</code></pre>
        <h3 id="7b1a72b1-91ca-4e7d-9399-5ce9c8e0a71b">实现 MaxHeap</h3>
        <p><code>MaxHeap</code> 的实现代码如下所示：</p>
        <pre><code class="language-javascript">class MaxHeap extends BaseHeap {

    /**
     * 最大堆类。
     * @returns { Object } - 最大堆的实例。
     */
    constructor () {

        super( &quot;MaxHeap&quot; );

    }

    /**
     * 获取堆的最大值。
     * @returns { number } - 堆的最大值。
     */
    getMaximum () {

        return this._getExtremum();

    }

}
</code></pre>
        <h2 id="1e2dec02-b0cb-468f-909c-73b560c74f20">堆排序算法</h2>
        <p>堆排序算法是指基于二叉堆数据结构来实现的排序算法，它可以对无序数组进行排序，以生成升序数组或降序数组。堆排序算法的时间复杂度是 <code>O(nlogn)</code>。</p>
        <p>如果你已经明白了最小堆和最大堆的实现原理，那么你就可以很轻易的想到堆排序算法的实现思路：</p>
        <ol>
            <li>将无序数组的所有数字值都依次插入到一个最小堆中去。</li>
            <li>不断弹出并记录最小堆的最小值，直至最小堆变空为止。</li>
            <li>即可获得升序数组或降序数组。</li>
        </ol>
        <p><img src=/static/image/markdown/data-structure/binary-heap/heap-sort-algorithm.png alt=堆排序算法 loading="lazy" decoding="async"></p>
        <p>其实现代码如下：</p>
        <pre><code class="language-javascript">/**
 * 堆排序算法，用于对无序数组进行升序排序和降序排序，该算法不会改变原始数据。
 * @param { number[] } data - 无序数组。
 * @returns { Array } - 一个数组，第一个元素是升序排列数组，第二个元素是降序排列数组。
 * @example
 * f( [ 3, 1, 2 ] ); // return [ [ 1, 2, 3 ], [ 3, 2 ,1 ] ]
 */
function heapSort ( data ) {

    /*  */
    const min_heap = new MinHeap;

    data.forEach( number =&gt; min_heap.insert( number ) )

    /*  */
    const ascending_order = [];  // 升序排列
    const descending_order = []; // 降序排列

    for ( let i = 0; i &lt; data.length; i ++ ) {

        const minimum = min_heap.getMinimum();

        ascending_order[ i ] = minimum;
        descending_order[ data.length - 1 - i ] = minimum;

        min_heap.shift();

    }

    return [ ascending_order, descending_order ];

}
</code></pre>
        <h2 id="70703d95-6d8a-4be8-a82a-317c0a55b280">动态中位数算法</h2>
        <p>基于二叉堆，我们可以实现一个有趣且实用的动态中位数算法。</p>
        <p>该算法可用于计算动态的无序数组的中位数，该算法的冷启动效率较低，热更新效率较高。具体来说，就是当你第一次获取一个无序数组的中位数时，该操作的时间复杂度为 <code>O(nlogn)</code>，而当你向该无序数组新增一个数字值，并再次获取该无序数组的中位数时，该操作的时间复杂度为 <code>O(logn)</code>。</p>
        <h3 id="5dc127ae-5846-4b8d-a15e-024d7ff560af">思想</h3>
        <p>该算法的思想是：</p>
        <ol>
            <li>将无序数组拆分成一个最小堆和一个最大堆。</li>
            <li>最小堆的最小值必须不小于最大堆的最大值。</li>
            <li>联立最小堆的最小值和最大堆的最大值即可求出中位数。</li>
        </ol>
        <p><img src=/static/image/markdown/data-structure/binary-heap/dynamic-median-idea.png alt=动态中位数算法的思想 loading="lazy" decoding="async"></p>
        <h3 id="43bfc484-3286-478e-bd8d-bb7cfc40ae77">实现</h3>
        <p>如何构造出满足要求的最小堆和最大堆呢？具体实现步骤如下：</p>
        <ol>
            <li>使用无序数组的前半部分数字值来创建一个最小堆。</li>
            <li>遍历无序数组的后半部分数字值：<ol>
                    <li>如果某个数字值大于最小堆的最小值，那么就将这个数字值插入到最小堆中去，然后弹出最小堆的堆顶节点。</li>
                    <li>如果某个数字值小于或等于最小堆的最小值，那么就跳过这个数字值。</li>
                </ol>
            </li>
            <li>使用无序数组的剩余数字值（指未插入到最小堆中的数字值）来创建一个最小堆。</li>
        </ol>
        <p><img src=/static/image/markdown/data-structure/binary-heap/dynamic-median-implementation.png alt=动态中位数算法的实现 loading="lazy" decoding="async"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>该过程的时间复杂度为 <code>O(nlong)</code>，推理如下：已知二叉树的插入操作的时间复杂度是 <code>O(logn)</code>，假设无序数组的长度为 <code>n</code>，那么第一步的时间复杂度就是 <code>O(log1 + log2 + ... + logn/2)</code>，即 <code>O(logn!)</code>，由于 <code>nlong</code> 是 <code>logn!</code> 的同阶函数，所以该步骤的时间复杂度可转换为 <code>O(nlogn)</code>。同理，第二步和第三步的时间复杂度都是 <code>O(nlogn)</code>，因此整个过程的时间复杂度就是 <code>O(nlogn)</code>。</p>
        </blockquote>
        <h3 id="0aeb0dbb-f302-4c3a-b739-65dfd380b3c8">插入</h3>
        <p>如果我们需要向无序数组插入一个新的数字值，并希望求出新的无序数组的中位数的话，那么我们需要这么做：</p>
        <ol>
            <li>将新的数字值插入到最小堆或最大堆中去。</li>
            <li>调整最小堆和最大堆，使它们的节点数的差值不大于 <code>1</code>。</li>
            <li>联立最小堆的最小值和最大堆的最大值即可求出新的中位数。</li>
        </ol>
        <p><img src=/static/image/markdown/data-structure/binary-heap/dynamic-median-insert.png alt=动态中位数算法的插入 loading="lazy" decoding="async"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>该过程的时间复杂度是 <code>O(logn)</code>，推理如下：</p>
            <p>第一步的时间复杂度是 <code>O(logn)</code>。第二步可能会引发到一至多次的插入节点和移除堆顶节点操作，其时间复杂度也是 <code>O(logn)</code>。第三步的时间复杂度是 <code>O(1)</code>。最后，可得整个过程的时间复杂度就是 <code>O(long)</code>。</p>
        </blockquote>
        <h3 id="df7fa387-a0d4-4035-8878-1d5407fb3f42">编码</h3>
        <p>该算法的实现代码如下：</p>
        <pre><code class="language-javascript">class DynamicMedian {

    #data;
    #min_heap;
    #max_heap;

    /**
     * 动态中位数的类，用于计算动态无序数组的中位数，该算法不会改变原始数据。
     * @example
     * const f = new F();
     * f.setData( [ 3, 1, 5 ] ); // retutn f   - O(nlogn)
     * f.getMedian();            // return 3   - O(1)
     * f.insertNumber( 4 );      // return f   - O(logn)
     * f.getMedian();            // return 3.5 - O(1)
     */
    constructor () {}

    /**
     * 设置无序数组。
     * @param { number[] } data - 无序数组，即一组无序的数字值，比如[3, 1, 2]。
     * @returns { Object } - 实例本身。
     */
    setData ( data ) {

        if ( data.length === 0 ) throw new Error( &quot;计算失败：因为入参不合法。&quot; );

        this.#data = [ ... data ];
        this.#min_heap = new MinHeap();
        this.#max_heap = new MaxHeap();

        const data_count = this.#data.length;
        const min_heap_count = Math.ceil( data_count / 2 );
        const max_heap_count = data_count - min_heap_count;

        /* 初始化最小堆 */
        for ( let i = 0; i &lt; min_heap_count; i ++ ) this.#min_heap.insert( this.#data[ i ] );

        for ( let i = min_heap_count; i &lt; data_count; i ++ ) {

            const minimum = this.#min_heap.getMinimum();

            if ( minimum &gt;= this.#data[ i ] ) continue;

            this.#min_heap.shift();
            this.#min_heap.insert( this.#data[ i ] );

        }

        /* 初始化最大堆 */
        for ( let i = 0; i &lt; max_heap_count; i ++ ) this.#max_heap.insert( this.#data[ i ] );

        for ( let i = max_heap_count; i &lt; data_count; i ++ ) {

            const maximum = this.#max_heap.getMaximum();

            if ( maximum &lt;= this.#data[ i ] ) continue;

            this.#max_heap.shift();
            this.#max_heap.insert( this.#data[ i ] );

        }

        return this;

    }

    /**
     * 获取无序数组。
     * @returns { number[] } - 无序数组。
     */
    getData () {

        if ( ! this.#data ) throw new Error( &quot;执行失败：因为没有设置无序数组。&quot; );

        return this.#data;

    }

    /**
     * 获取无序数组的中位数。
     * @returns { number } - 无序数组的中位数。
     */
    getMedian () {

        if ( ! this.#data ) throw new Error( &quot;执行失败：因为没有设置无序数组。&quot; );

        /* 如果无序数组有奇数个数字值 */
        if ( this.#data.length % 2 === 1 ) return this.#min_heap.getMinimum();

        /* 如果无序数字有偶数个数字值 */
        return ( this.#min_heap.getMinimum() + this.#max_heap.getMaximum() ) / 2;

    }

    /**
     * 插入一个数字值。
     * @param { number } number - 一个数字值。
     * @returns { Object } - 实例本身。
     */
    insertNumber ( number ) {

        if ( ! this.#data ) throw new Error( &quot;执行失败：因为没有设置无序数组。&quot; );

        this.#data.push( number );

        /* 如果无序数组有奇数个数字值 */
        if ( this.#data.length % 2 === 1 ) {

            if ( number &gt;= this.#max_heap.getMaximum() ) {

                this.#min_heap.insert( number );

                return this;

            }

            this.#max_heap.insert( number );
            this.#min_heap.insert( this.#max_heap.getMaximum() );
            this.#max_heap.shift();

            return this;

        }

        /* 如果无序数字有偶数个数字值 */
        if ( number &lt;= this.#min_heap.getMinimum() ) {

            this.#max_heap.insert( number );

            return this;

        }

        this.#min_heap.insert( number );
        this.#max_heap.insert( this.#min_heap.getMinimum() );
        this.#min_heap.shift();

        return this;

    }

}
</code></pre>
        <h2 id="e0bc4370-91df-4e75-b095-52ee30e5c09d">源码</h2>
        <p>你可以从 <a href="https://github.com/jynxio/data-structure-and-algorithm/blob/main/data-structure/Heap.js">这里</a> 获取得到 <code>MinHeap</code> 和 <code>MaxHeap</code> 的完整源码。</p>
        <p>你可以从 <a href="https://github.com/jynxio/data-structure-and-algorithm/blob/main/algorithm/heapSort.js">这里</a> 获取得到 <code>heapSort</code> 的完整源码。</p>
        <p>你可以从 <a href="https://github.com/jynxio/data-structure-and-algorithm/blob/main/algorithm/DynamicMedian.js">这里</a> 获取得到 <code>DynamicMedian</code> 的完整源码。</p>
    </article>
</body>

</html>