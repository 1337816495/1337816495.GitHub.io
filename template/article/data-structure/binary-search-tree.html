<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二叉搜索树</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=1a8c93bf-ebb7-488a-8caf-b84d67dd7655>概述</p>
        <p data-target-id=4ca73c19-2382-4bdc-b776-25634965efda>效率</p>
        <p data-target-id=f77da162-379b-4972-9ed3-79dbcfb27954>实现</p>
        <p data-target-id=cdaed685-1d5c-429c-a83e-19bd917c661b>源码</p>
    </aside>
    <article>
        <h1>二叉搜索树</h1>
        <h2 id="1a8c93bf-ebb7-488a-8caf-b84d67dd7655">概述</h2>
        <p>二叉搜索树是一种特殊的二叉树，其遵循下述规则：</p>
        <ul>
            <li>左侧子节点的值必须比父节点的值小。</li>
            <li>右侧子节点的值必须比父节点的值大。</li>
            <li>树中每个节点的值都是唯一的。</li>
        </ul>
        <p>得益于这种特性，我们可以用二叉搜索树来做二分查找。</p>
        <p><img src=/static/image/markdown/data-structure/binary-search-tree/binary-search-tree.png alt=满二叉搜索树 loading="lazy" decoding="async"></p>
        <p>本文会实现二叉搜索树，并且在实现的过程中，会使用使用数字值来作为二叉搜索树的节点的值，这是因为数字值与数字值之间天然就可以比较大小。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>如果你可以定义一个规则，来比较其他类型的值与其他类型的值之间的大小，那么你也可以用其他类型的值来作为二叉搜索树的节点的值。</p>
            <p>比如使用字符串来作为节点的值，之所以可以这么做，是因为在 JavaScript 中，字符串与字符串之间会通过隐式的转换为 ASCII 码来比较大小。</p>
        </blockquote>
        <h2 id="4ca73c19-2382-4bdc-b776-25634965efda">效率</h2>
        <p>在理想情况下（即满二叉搜索树时），二叉搜索树的新增、删除、搜索节点的时间复杂度均为 <code>O(logn)</code>，具体推理可见后文。</p>
        <p>在最坏情况下（即退化成链表时），二叉搜索树的新增、删除、搜索节点的时间复杂度就会变成 <code>O(n)</code>，这是显而易见的。</p>
        <p><img src=/static/image/markdown/data-structure/binary-search-tree/binary-search-tree-time-complexity.png alt=两种情况下的时间复杂度 loading="lazy" decoding="async"></p>
        <p><code>O(logn)</code> 的推导如下：</p>
        <pre><code>1.首先，假设满二叉搜索树的节点数为n、高度为h，则n与h满足以下关系：
  n = 2^0 + 2^1 + 2^2 + ... + 2^h

2.等式两边同时乘以2，进一步可得：
  2n = 2^1 + 2^2 + ... + 2^( h+1 )

3.计算2n-n，可得：
  n = ( 2^1 + 2^2 + ... + 2^( h+1 ) ) - ( 2^0 + 2^1 + 2^2 + ... + 2^h )
    = 2^( h+1 ) - 2^0
    = 2^( h+1 ) - 1
  
4.最终，转化可得：
  h = log2( n + 1 ) - 1;

5.对于一棵满二叉搜索树而言，其在最坏情况下的搜索操作的时间频度就等于h+1，即log2( n + 1 )，因此其搜索操作的时间复杂度就等于O(logn)，而新增与删除操作同理。
</code></pre>
        <h2 id="f77da162-379b-4972-9ed3-79dbcfb27954">实现</h2>
        <p>我们将会实现一个名为 <code>BinarySearchTree</code> 的二叉搜索树的类，它将会拥有下述方法：</p>
        <table>
            <thead>
                <tr>
                    <th>方法名</th>
                    <th>描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>insert( value )</code></td>
                    <td>插入一个值为 <code>value</code> 的节点，然后返回更新后的树。</td>
                </tr>
                <tr>
                    <td><code>remove( value )</code></td>
                    <td>移除一个值为 <code>value</code> 的节点，然后返回更新后的树。</td>
                </tr>
                <tr>
                    <td><code>search( value )</code></td>
                    <td>搜索一个值为 <code>value</code> 的节点，然后返回一个布尔值来代表该节点是否存在。</td>
                </tr>
                <tr>
                    <td><code>inorderTraverse( callback )</code></td>
                    <td>中序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。</td>
                </tr>
                <tr>
                    <td><code>preorderTraverse( callback )</code></td>
                    <td>先序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。</td>
                </tr>
                <tr>
                    <td><code>postorderTraverse( callback )</code></td>
                    <td>后序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。</td>
                </tr>
            </tbody>
        </table>
        <h3 id="959691fd-a680-4d79-acce-aff01a85d0f2">创建节点类</h3>
        <p>首先，让我们来创建一个节点的类 <code>BinarySearchTreeNode</code>。</p>
        <pre><code class="language-js">class BinarySearchTreeNode {

    constructor ( value ) {

        this.value = value;
        this.left = undefined;
        this.right = undefined;

    }

}
</code></pre>
        <h3 id="7793b828-6cf1-4fbf-ba2d-78863e55b57e">创建二叉搜索树类</h3>
        <p>接下来，让我们来创建二叉搜索树的类 <code>BinarySearchTree</code>，它目前只有构造器方法，我们会在后续为其继续补充剩余的方法。</p>
        <pre><code class="language-js">class BinarySearchTree {

    constructor () { this.root = undefined }

}
</code></pre>
        <h3 id="2de7e5d0-1f93-40c8-b5b1-76c344b87e74">创建 insert 方法</h3>
        <p><code>insert</code> 方法的实现思路如下：</p>
        <ol>
            <li>首先易知，向二叉搜索树插入的新节点必然会成为它的叶节点。</li>
            <li>如果根节点为空，那么就直接把新节点作为根节点。</li>
            <li>如果新节点的值小于根节点的值，那么就把新节点插入到根节点的左侧：<ol>
                    <li>如果根节点的左侧子节点为空，那么就直接把新节点作为根节点的左侧子节点。</li>
                    <li>否则，把根节点的左侧子节点当作一棵新的二叉搜索树，然后将新节点插入到这棵新的二叉搜索树中去，即递归调用。</li>
                </ol>
            </li>
            <li>如果新节点的值大于根节点的值，那么就把新节点插入到根节点的右侧：<ol>
                    <li>如果根节点的右侧子节点为空，那么就直接把新节点作为根节点的右侧子节点。</li>
                    <li>否则，把根节点的右侧子节点当作一棵新的二叉搜索树，然后将新节点插入到这棵新的二叉搜索树中去，即递归调用。</li>
                </ol>
            </li>
            <li>如果新节点的值等于根节点的值，那么就抛出错误，因为二叉搜索树中每个节点的值都应该是唯一的。</li>
        </ol>
        <p><img src=/static/image/markdown/data-structure/binary-search-tree/binary-search-tree-insert.png alt=insert方法 loading="lazy" decoding="async"></p>
        <p><code>insert</code> 方法的实现代码如下：</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class BinarySearchTree {

    /**
     * 插入节点。
     * @param { number } value - 节点的值。
     * @returns { Object } - 更新后的BinarySearchTree实例。
     */
    insert ( value ) {

        this.root = core( this.root, value );

        return this;

        function core ( root, value ) {

            /* 基线条件 */
            if ( root === undefined ) return new BinarySearchTreeNode( value );
            if ( root.value === value ) throw new Error( &quot;This value already exists.&quot; );

            /* 递归 */
            if ( root.value &gt; value ) root.left = core( root.left, value );
            if ( root.value &lt; value ) root.right = core( root.right, value );

            return root;

        }

    }

}
</code></pre>
        <h3 id="4a455f49-4baf-4fea-93c2-22b4df4c411e">创建 remove 方法</h3>
        <p><code>remove</code> 方法的实现比 <code>insert</code> 方法更难，其实现思路如下：</p>
        <ol>
            <li>如果根节点为空，那么就直接结束该方法。</li>
            <li>如果待移除节点的值小于根节点的值，那么就把根节点的左侧子节点当作一棵新的二叉搜索树，然后在这棵新的二叉搜索树中去移除这个待移除节点，即递归调用。</li>
            <li>如果待移除节点的值大于根节点的值，那么就把根节点的右侧子节点当作一棵新的二叉搜索树，然后在这棵新的二叉搜索树中去移除这个待移除节点，即递归调用。</li>
            <li>如果待移除节点的值等于根节点的值，且：<ol>
                    <li>如果根节点的左侧子节点和右侧子节点均为空，那么就直接移除根节点。</li>
                    <li>如果根节点的左侧子节点不为空，右侧子节点为空，那么就用左侧子节点来替代根节点。</li>
                    <li>如果根节点的左侧子节点为空，右侧子节点不为空，那么就用右侧子节点来替代根节点。</li>
                    <li>如果根节点的左侧子节点和右侧子节点均不为空，那么就把左侧子节点当作一棵新的二叉搜索树，然后移除这棵二叉搜索树中的最大值节点，并用这个最大值节点来替代根节点。</li>
                </ol>
            </li>
        </ol>
        <p><img src=/static/image/markdown/data-structure/binary-search-tree/binary-search-tree-remove.png alt=remove方法 loading="lazy" decoding="async"></p>
        <p><code>remove</code> 方法的实现代码如下：</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class BinarySearchTree {

    /**
     * 删除节点。
     * @param { number } value - 节点的值。
     * @returns { Object } - 更新后的BinarySearchTree实例。
     */
    remove ( value ) {

        this.root = core( this.root, value );

        return this;

        function core ( root, value ) {

            /* 基线条件 */
            if ( root === undefined ) return;
            if ( root.value === value ) {

                if ( root.left === undefined &amp;&amp; root.right === undefined ) return;
                if ( root.left === undefined ) return root.right;
                if ( root.right === undefined ) return root.left;

                const new_root = new BinarySearchTreeNode( findMaxValue( root.left ) );
                const new_left = core( root.left, new_root.value );
                const new_right = root.right;

                new_root.left = new_left;
                new_root.right = new_right;

                return new_root;

            }

            /* 递归 */
            if ( root.value &gt; value ) root.left = core( root.left, value );
            if ( root.value &lt; value ) root.right = core( root.right, value );

            return root;

        }

        function findMaxValue ( root ) {

            if ( root.right === undefined ) return root.value;

            return findMaxValue( root.right );

        }

    }

}
</code></pre>
        <h3 id="96cce596-edba-4f92-9c65-718b23b72b6a">创建 search 方法</h3>
        <p><code>search</code> 方法是最简单的，其实现思路如下：</p>
        <ol>
            <li>如果搜索节点的值小于根节点的值，那么就把根节点的左侧子节点当作一棵新的二叉搜索树，然后在这棵新的二叉搜索树中去搜索这个搜索节点。</li>
            <li>如果搜索节点的值大于根节点的值，那么就把根节点的右侧子节点当作一棵新的二叉搜索树，然后在这棵新的二叉搜索树中去搜索这个搜索节点。</li>
            <li>如果搜索节点的值等于根节点的值，那么就直接返回 <code>true</code>。</li>
            <li>如果根节点的值为空，那么就直接返回 <code>false</code>，这种情况代表着树中不存在待搜索的值。</li>
        </ol>
        <p><img src=/static/image/markdown/data-structure/binary-search-tree/binary-search-tree-search.png alt=search方法 loading="lazy" decoding="async"></p>
        <p><code>search</code> 方法的实现代码如下：</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class BinarySearchTree {

    /**
     * 搜索节点。
     * @param { number } value - 节点的值。
     * @returns { boolean } - 如果存在值为value的节点，则返回true，否则返回false。
     */
    search ( value ) {

        return core( this.root, value );

        function core ( root, value ) {

            /* 基线条件 */
            if ( root === undefined ) return false;
            if ( root.value === value ) return true;

            /* 递归 */
            if ( root.value &gt; value ) return core( root.left, value );
            if ( root.value &lt; value ) return core( root.right, value );

        }

    }

}
</code></pre>
        <h3 id="912fccaa-bd57-4ab7-abb5-9bf173ae31e1">创建 inorderTraverse 方法</h3>
        <p>中序遍历的遍历顺序如下图所示：</p>
        <p><img src=/static/image/markdown/data-structure/binary-search-tree/binary-search-tree-inorder-traverse.png alt=inorderTraverse方法 loading="lazy" decoding="async"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>显然，中序遍历会按照节点值从小到大的顺序来遍历所有的节点。</p>
        </blockquote>
        <p><code>inorderTraverse</code> 方法的实现代码如下：</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class BinarySearchTree {

    /**
     * 中序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。
     * @param { Function } - 回调函数。
     */
    inorderTraverse ( callback ) {

        core( this.root );

        function core ( root ) {

            if ( root === undefined ) return;

            core( root.left );
            callback( root.value );
            core( root.right );

        }

    }

}
</code></pre>
        <h3 id="a07fd719-dbc4-4e98-a93b-6b1d1be8362d">创建 preorderTraverse</h3>
        <p>先序遍历的遍历顺序如下图所示：</p>
        <p><img src=/static/image/markdown/data-structure/binary-search-tree/binary-search-tree-preorder-traverse.png alt=preorderTraverse方法 loading="lazy" decoding="async"></p>
        <p>只需稍稍修改一下中序遍历，就能实现先序遍历了，其实现代码如下：</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class BinarySearchTree {

    /**
     * 先序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。
     * @param { Function } - 回调函数。
     */
    preorderTraverse ( callback ) {

        core( this.root );

        function core ( root ) {

            if ( root === undefined ) return;

            callback( root.value );
            core( root.left );
            core( root.right );

        }

    }

}
</code></pre>
        <h3 id="4dd9ceed-3361-4a74-8392-c60db83835a8">创建 postorderTraverse</h3>
        <p>后序遍历的遍历顺序如下图所示：</p>
        <p><img src=/static/image/markdown/data-structure/binary-search-tree/binary-search-tree-postorder-traverse.png alt=postorderTraverse方法 loading="lazy" decoding="async"></p>
        <p>同样的，只需稍稍修改一下中序遍历，就能实现后序遍历了，其实现代码如下：</p>
        <pre><code class="language-js">// Note：该实现省略了构造器方法与其他方法。
class BinarySearchTree {

    /**
     * 后序遍历树，并对每个遍历到的节点执行一次回调函数，回调函数会接收节点的值来作为入参。
     * @param { Function } - 回调函数。
     */
    postorderTraverse ( callback ) {

        core( this.root );

        function core ( root ) {

            if ( root === undefined ) return;

            core( root.left );
            core( root.right );
            callback( root.value );

        }

    }

}
</code></pre>
        <h2 id="cdaed685-1d5c-429c-a83e-19bd917c661b">源码</h2>
        <p>你可以通过该 <a href="https://github.com/jynxio/leetcode-everyday">库</a> 的 <a href="https://github.com/jynxio/leetcode-everyday/blob/main/Tree.js">Tree.js</a> 文件，来获取 <code>BinarySearchTree</code> 的完整源码。</p>
    </article>
</body>

</html>