<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>重排、重绘、合成</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p><a href="#">IN THIS ARTICLE</a></p>
        <p data-level="1"><a href="#cab690d9-9088-4a54-972f-303a9993f413">渲染流程</a></p>
        <p data-level="1"><a href="#6c48f61a-2525-4ddf-aa69-4a0e6c094cde">重排</a></p>
        <p data-level="1"><a href="#7ac55122-7b2d-4f0b-9c61-e0acf3a74efa">重绘</a></p>
        <p data-level="1"><a href="#dfff4769-246d-4ba4-aea4-a8a7f0b905ab">合成</a></p>
    </aside>
    <article>
        <h1>重排、重绘、合成</h1>
        <p id="last-updated">Last Updated: 08/05/2022</p>
        <h2 id="cab690d9-9088-4a54-972f-303a9993f413">渲染流程</h2>
        <p>首先，渲染流程是：</p>
        <ol>
            <li>DOM：创建 DOM 树</li>
            <li>Style：计算元素的样式</li>
            <li>Layout：计算可见元素的样式与位置</li>
            <li>Layer：创建页面的图层</li>
            <li>Paint：创建图层的绘制指令列表</li>
            <li>Tiles：将图层分割为图块</li>
            <li>Raster：创建图层的位图</li>
            <li>Display：合并图层位图并渲染页面</li>
        </ol>
        <h2 id="6c48f61a-2525-4ddf-aa69-4a0e6c094cde">重排</h2>
        <p>如果你改变了元素的几何属性或位置属性（比如宽度、高度等），元素在页面中的位置就会发生变化，并且其它元素的位置也可能会受其影响而改变，因此渲染进程就需要重新执行 <code>Layout</code> 步骤来更新页面的布局信息，并且渲染流程中之后的步骤也都需要重新执行。</p>
        <p>可见，重排几乎需要更新完整的渲染流水线（除了 <code>DOM</code> 步骤），故而重排的开销是最大的。</p>
        <h2 id="7ac55122-7b2d-4f0b-9c61-e0acf3a74efa">重绘</h2>
        <p>如果你改变了元素的绘制属性（比如背景颜色），那么渲染进程就需要重新执行 <code>Paint</code> 及其之后的步骤。因为这种改变不会修改页面的布局和分层，因此渲染进程就跳过了 <code>Layout</code> 和 <code>Layer</code> 步骤。</p>
        <p>可见重绘带来的计算负荷比重排的要小。</p>
        <h2 id="dfff4769-246d-4ba4-aea4-a8a7f0b905ab">合成</h2>
        <p>如果你修改的是诸如 <code>translate</code> 之类的 CSS3 动画属性，那么渲染进程就只需要执行 <code>Tiles</code> 及其之后的步骤就好了。</p>
        <p>比如，对于一个启用了 <code>translate</code> 属性的元素而言，它拥有自己的专属图层，改变它的 <code>translate</code> 属性不会影响页面的分层状况。并且，<code>Paint</code> 阶段输出的绘制指令列表是以图层为单位的，由于该元素的外观根本没有发生改变，因此也不需要更新绘制指令列表，自然也可以跳过 <code>Paint</code> 阶段。最后，改变了 <code>translate</code> 属性后，由于元素的位置发生了变化，理应是要更新页面的布局信息的，不过渲染进程似乎是通过在 <code>Display</code> 阶段偏移该元素图层的位置来实现使其位移的，因此也可以跳过 <code>Layout</code> 阶段。</p>
        <p>由于“合成”所需的计算负荷更小，并且其还是在非主线程中完成的，因此“合成”的的计算负荷比起前两者的要小得多。</p>
        <blockquote>
            <p>另外，许多现代浏览器是使用合成线程来处理内容滚动的，这是因为浏览器将滚动的内容做成了一个单独的图层，在发生滚动时只需要在 <code>Display</code> 阶段改变该图层的位置偏移量即可。</p>
        </blockquote>
    </article>
</body>

</html>