<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>网络协议</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=1fe15aa2-4ec3-495c-a26b-2e3fcf2d7e0d>IP</p>
        <p data-target-id=cd3e9fea-055b-4d78-8b20-0ff4ea682940>UDP</p>
        <p data-target-id=7008609c-ed23-4a67-89fc-864e8d214fb8>TCP</p>
        <p data-target-id=409dc586-1956-47ff-9dc1-cf2d4802a951>HTTP</p>
    </aside>
    <article>
        <h1>网络协议</h1>
        <h2 id="1fe15aa2-4ec3-495c-a26b-2e3fcf2d7e0d">IP</h2>
        <p>数据包要在互联网上进行传输，就需要符合网际协议（Internet Protocol，简称 IP）标准，IP 的作用就是将数据包传送至目标主机。互联网上的每台主机都拥有唯一的 IP 地址，这是一个数字地址。</p>
        <p>访问网站实际上是一台主机向另一台主机请求信息，比如，如果主机 A 要把数据包发送给主机 B，那么在发送之前，就要为数据包附加上主机 B 的 IP 地址，这样数据包才知道应当发往何处。另外，数据包还会附加上主机 A 的 IP 地址，这样主机 B 才能回复信息给主机 A。这两种附加信息都会被装进一个名为 IP 头的数据结构里，IP 头就是 IP 数据包开头的信息，它不仅包含 <code>源 IP 地址</code> 和 <code>目标 IP 地址</code>，它还包含 <code>IP 版本</code> 和 <code>生存时间</code> 等信息。</p>
        <p>主机 A 将单个数据包发送给主机 B 的具体流程是：</p>
        <ol>
            <li>主机 A 的上层将原始数据包交给网络层。</li>
            <li>网络层为原始数据包添加 IP 头，组成了新的 IP 数据包，然后交给底层。</li>
            <li>底层通过物理设备将 IP 数据包传输给主机 B的网络层。</li>
            <li>主机 B 的网络层拆除 IP 数据包的 IP 头，获得原始数据包，最后将原始数据包交给上层。</li>
        </ol>
        <h2 id="cd3e9fea-055b-4d78-8b20-0ff4ea682940">UDP</h2>
        <p>IP 只负责将数据包传送至目标主机，但是目标主机并不知道应该将数据包交付给哪个应用程序，因此还缺少一种能和应用程序打交道的协议，用户数据包协议（User Datagram Protocol，简称 UDP）便是其中一种。</p>
        <p>任何想要访问网络的应用程序都需要绑定一个唯一的端口号，UDP 正是通过端口号来确定应该将数据包交付给哪个应用程序的，端口号其实就是一个数字，比如 <code>https://localhost:443</code> 中的 <code>443</code> 就是一个端口号。</p>
        <p>和 IP 的行为一样，UDP 也会为数据包封装一个 UDP 头，其内包含了 <code>源端口号</code> 和 <code>目标端口号</code>。</p>
        <p>那么，主机 A 将单个数据包发送给主机 B 的具体流程就更新为：</p>
        <ol>
            <li>主机 A 的上层将原始数据包交给网络层。</li>
            <li>传输层为原始数据包添加 UDP 头，组成了新的 UDP 数据包，然后交给网络层。</li>
            <li>网络层为 UDP 数据包添加 IP 头，组成了新的 IP 数据包，然后交给底层。</li>
            <li>底层通过物理设备将 IP 数据包传输给主机 B 的网络层。</li>
            <li>主机 B 的网络层拆除 IP 数据包的 IP 头，获得了 UDP 数据包，然后将 UDP 数据包交给传输层。</li>
            <li>主机 B 的传输层拆除 UDP 数据包的 UDP 头，获得了原始数据包，然后根据 UDP 头中的端口号来将原始数据包交给上层的应用程序。</li>
        </ol>
        <p>UDP 具有校验数据包是否正确的能力，但是对于出错的数据包，UDP 却并不提供重发机制，而是直接丢弃它们，另外 UDP 也不能确定数据包是否成功的到达了目的地，因此 UDP 无法保证数据的可靠性，不过 UDP 的传输速度却非常快，所以 UDP 经常会应用在一些关注速度，但不那么严格要求数据完整性的领域，比如在线视频、互动游戏等。</p>
        <h2 id="7008609c-ed23-4a67-89fc-864e8d214fb8">TCP</h2>
        <p>对于浏览器请求或邮件等这类对数据传输可靠性要求高的应用，如果使用 UDP 来传输会存在两个问题：</p>
        <ul>
            <li>数据包在传输过程中容易丢失（比如由于网络波动、网络阻塞、设备故障、恶意程序拦截等）。</li>
            <li>大文件会被拆分成很多的小数据包来传输，小数据包们会在不同的时间到达接收端，然而 UDP 并不知道该如何将这些小数据包组装还原成完整的文件。</li>
        </ul>
        <p>为了解决这两个问题，我们需要引入 传输控制协议（Transmission Control Protocol，简称 TCP），它是一种面向连接的、可靠的、基于字节流的传输层通信协议。相比 UCP，TCP 具有下述三个特点：</p>
        <ul>
            <li>提供重发机制，可用于解决数据包丢失的问题。</li>
            <li>提供数据包排序机制，可以保证把乱序的小数据包们组成还原成完整的文件，这是因为 TCP 头不仅包含源端口号和目标端口号，还有一个用于排序的序号。</li>
            <li>TCP 的传输速度比 UDP 更慢，这是因为“三次握手”和“数据包校验机制”等机制把传输过程中的数据包的数量提高了一倍。</li>
        </ul>
        <p>那么，主机 A 将单个数据包发送给主机 B 的具体流程就更新为：</p>
        <ol>
            <li>主机 A 的上层将原始数据包交给网络层。</li>
            <li>传输层为原始数据包添加 TCP 头，组成了新的 TCP 数据包，然后交给网络层。</li>
            <li>网络层为 TCP 数据包添加 IP 头，组成了新的 IP 数据包，然后交给底层。</li>
            <li>底层通过物理设备将 IP 数据包传输给主机 B 的网络层。</li>
            <li>主机 B 的网络层拆除 IP 数据包的 IP 头，获得了 TCP 数据包，然后将 TCP 数据包交给传输层。</li>
            <li>主机 B 的传输层拆除 TCP 数据包的 TCP 头，获得了原始数据包，然后根据 TCP 头中的端口号来将原始数据包交给上层的应用程序。</li>
        </ol>
        <p>由上述可知，TCP 传输单个数据包的流程和 UDP 的差不多，但是不同之处在于，主机 B 可以通过 TCP 头中的序号来重新排序数据包，以便将小数据包们组装还原为完整的文件。</p>
        <p>传输单个数据包只是 TCP 连接过程中的一小部分，下图展示了完整的 TCP 连接过程，可见一个完整的 TCP 连接包括了建立连接、传输数据、断开连接三个阶段。</p>
        <p><img src="/static/image/markdown/browser/network-protocol/tcp-lifecycle.png" alt="TCP连接的生命周期"></p>
        <ol>
            <li>首先是建立连接阶段，该阶段需要通过“三次握手”来建立客户端和服务器之间的连接，“三次握手”是指在建立一个 TCP 连接时，两端总共需要发送 3 个数据包来确认连接的建立，这是 TCP 被称为面向连接的原因。</li>
            <li>其次是传输数据阶段，在该阶段中，客户端在接收到每一个数据包后，都需要向服务器发送“确认数据包”，服务器在发送了一个数据包之后，如果没能在规定时间内接受到相应的“确认数据包”，就会判断为数据包丢失，并处罚重发机制。另外，一个大的文件在传输过程中会被拆分成很多的小数据包，客户端会按照 TCP 头中的序号为其排序，从而保证组成完整的文件。</li>
            <li>最后是断开连接阶段，该阶段通过“四次挥手”保证双方都能断开连接。</li>
        </ol>
        <h2 id="409dc586-1956-47ff-9dc1-cf2d4802a951">HTTP</h2>
        <p>超文本传输协议（Hypertext Transfer Protocol，简称 HTTP）是一种允许浏览器向服务器获取资源的协议，它的具体做法是：使用 HTTP（应用层协议）来封装请求信息，然后使用 TCP（传输层协议）和 IP（网络层协议）来向目标主机的应用程序（服务器）发送这个请求。</p>
        <p>由于 HTTP 请求是在 TCP 的传输阶段中发送的，因此在 HTTP 正式工作之前，浏览器需要通过 TCP 与服务器建立连接，TCP 和 HTTP 的关系如下图所示：</p>
        <p><img src="/static/image/markdown/browser/network-protocol/tcp-http.png" alt="TCP和HTTP的关系"></p>
        <h3 id="0114a63c-0c38-4415-80b3-a924f6790101">CURL</h3>
        <p><a href="https://curl.se/">CURL</a> 是一个使用命令行来获取 URL 资源的工具，本文使用该工具来查看服务器返回的数据。</p>
        <h3 id="4a705c1f-39aa-4307-9ba6-f5a92983adae">请求的流程</h3>
        <p>如果你在浏览器的地址栏中键入了 <code>https://www.jynxio.com/index.html</code>，浏览器会做哪些事情呢？本节会讲述浏览器发起 HTTP 请求的具体流程。</p>
        <h4 id="6647a6a0-d3dd-4a69-b371-a723c6865bbb">第一步 - 构建请求</h4>
        <p>首先，浏览器会基于 URL 来构建请求行信息，然后准备发起网络请求，请求行的内容如下所示：</p>
        <pre><code>GET /index.html HTTP1.1
</code></pre>
        <h4 id="2151a6b8-518a-45ca-bd27-add9cda14efb">第二步 - 查找缓存</h4>
        <p>浏览器在真正发起网络请求之前，会先查询浏览器缓存中是否存在要请求的文件，若存在则拦截请求、返回缓存资源、结束请求，若不存在或缓存资源已过期，才会进行网络请求。其中，浏览器缓存是一种在本地保存资源副本的技术。</p>
        <h4 id="17b3bb86-af6a-4980-a30e-efb166be919d">第三步 - 获取地址与端口号</h4>
        <p>在浏览器向服务器发起 HTTP 请求之前，浏览器首先需要与服务器建立 TCP 连接，这是因为 HTTP 请求是发生在 TCP 连接的数据传输阶段的行为。为了与服务器建立 TCP 连接，浏览器就需要知晓服务器的 IP 地址和端口号。</p>
        <p>浏览器通过 DNS 服务来获取 IP 地址，其中 DNS 是指域名系统，它是 Domain Name System 的简写，它是一个将域名与 IP 地址进行一一映射的服务，产生 DNS 的原因是：IP 地址实在是太难记忆了，因为 IP 地址是诸如 <code>76.76.21.21</code> 这样的数字标识，人们更喜欢用英文字符来表示地址，但是浏览器又不认识域名，因此就需要一套能将域名映射为 IP 地址的服务。另外，浏览器本身也有 DNS 数据缓存服务，它的作用是缓存解析过的域名，以供下次查询时直接使用，从而减少一次网络请求。</p>
        <p>最后浏览器会通过解析 URL 来获取端口号，这个解析行为非常简单，若端口号被明确书写在 URL 中，则直接提取，否则取用默认的端口号，对于 HTTP 而言，默认的端口号是 <code>80</code>，对于 HTTPS 而言，默认的端口号是 <code>443</code>。</p>
        <h4 id="f7b490c0-b443-4e2c-97f2-8da39244833c">第四步 - 等待 TCP 队列</h4>
        <p>对于 <code>http/1.1</code>，浏览器会为每个域名维护至多 6 个 TCP 连接，此时每个 TCP 同一时刻只能处理一个请求，因此同一域名同一时刻只能接受至多 6 个请求。如果请求的数量超过了 6 个，那么超出的请求就需要排队等待前面的请求处理完成，当前面的请求处理完成后，原来的 TCP 连接不会断开，而是继续用来处理后续的请求。如果请求的数量不超过 6 个，则直接创建新的 TCP 请求来处理。</p>
        <p>对于 <code>http2</code>，由于 TCP 是可以并行处理多个请求的，因此此时的浏览器只会为每个域名维护一个 TCP 连接。</p>
        <h4 id="25c8f4fe-d443-433e-8821-483e844c8604">第五步 - 建立 TCP 连接</h4>
        <p>略，详见 TCP 小节。</p>
        <h4 id="31302c93-0449-477d-8706-fe9d944912d8">第六步 - 发送 HTTP 请求</h4>
        <p>首先，浏览器会向服务器发送请求行，请求行包括了请求方法、请求 URI 和 HTTP 版本协议。发送请求行的目的是告诉服务器浏览器所需的资源。</p>
        <p>最常用的请求方法是 GET，如果直接在浏览器的地址栏中键入 <code>www.jynxio.com</code>，就是告诉服务器要获取它的首页资源。另一个常用的请求方法是 POST，它用于向服务器发送数据，比如登录一个网站时，就需要通过 POST 方法向服务器发送用户信息，如果使用了 POST 方法，那么浏览器还要准备数据给服务器，这些数据是通过请求体来发送的。</p>
        <p>在浏览器发送了请求行后，还需要发送请求头，请求头中包含了关于浏览器的基础信息，比如浏览器所使用的操作系统、浏览器内核、当前请求者的域名、浏览器的 Cookie 等。</p>
        <h4 id="695a4162-c151-4af6-a95c-d6bcb61ff579">第七步 - 重定向</h4>
        <p>如果你打开 <code>https://jynxio.com</code>，你就会发现浏览器最终打开的页面地址是 <code>https://www.jynxio.com</code>，之所以会产生这种现象，是因为发生了重定向。在 Terminal 中执行 <code>curl -I https://jynxio.com</code> 命令，服务器将返回下述内容：</p>
        <p><img src="/static/image/markdown/browser/network-protocol/permanent-redirect.png" alt="永久重定向"></p>
        <p>如果你打开 <code>https&quot;//www.jynxio.com</code>，则直接进入到第八步。</p>
        <h4 id="7c6d96d5-d5bf-47cb-a07b-e5fe92194188">第八步 - 返回请求</h4>
        <p>HTTP 请求送达服务器，待服务器处理结束后，便会返回数据。首先返回的是响应行，它包括协议版本和状态码。然后返回的是响应头，响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。最后返回的是响应体，它通常包含了 HTML 的实际内容。</p>
        <p>在 Terminal 中执行 <code>curl -i https://www.jynxio.com</code> 命令，服务器将返回下述内容：</p>
        <p><img src="/static/image/markdown/browser/network-protocol/response-content-format.png" alt="响应内容的格式"></p>
        <h4 id="8e3b6599-3172-4f6d-be3f-4a6e1c24d4d8">第九步 - 断开连接</h4>
        <p>通常情况下，一旦服务器向客户端返回了数据，TCP 连接就会断开，不过如果浏览器或者服务器在其头信息中加入了 <code>Connection:Keep-Alive</code>，那么 TCP 连接则不会断开，这样浏览器就可以继续通过同一个 TCP 连接来发送请求，保持 TCP 连接的好处是可以省去下次请求时需要建立连接的时间，从而提升资源加载速度。</p>
        <h3 id="3bb81ba2-ffe3-41b7-9414-259f51419c0b">数据缓存</h3>
        <h4 id="9df5aa06-f275-44b2-bf62-6febe8f30cd6">DNS 缓存</h4>
        <p>DNS 缓存就是浏览器在本地把域名和对应的 IP 地址关联起来。</p>
        <h4 id="b9a09fd4-82ed-46f8-a7c1-6785da9d1e3c">页面资源缓存</h4>
        <p>浏览器创建并使用页面缓存的流程如下所示：</p>
        <p><img src="/static/image/markdown/browser/network-protocol/page-cache.png" alt="页面缓存"></p>
        <p>当服务器返回 HTTP 响应头给浏览器的时候，浏览器通过响应头中的 <code>Cache-Control</code> 字段来设置是否缓存该资源，通过我们还需要为这个资源设置一个缓存保质期，该保质期是通过 <code>Max-age</code> 参数来设置的，比如上图中设置的缓存保质期是 2000 秒，相应的 <code>Cache-Control</code> 字段内容如下：</p>
        <pre><code>Cache-Control:Max-age=2000
</code></pre>
        <p>如果浏览器在缓存中找到了要请求的资源，且该缓存资源还未过期，则浏览器会直接使用该缓存资源，并中止网络请求。如果缓存资源过期了，浏览器就会继续发起网络请求，并在 HTTP 请求头中带上：</p>
        <pre><code>If-None-Match:&quot;4f80f-13c-3a1xb12a&quot;
</code></pre>
        <p>服务器接收到请求后，会根据 <code>If-None-Match</code> 的值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码来告诉浏览器可以继续使用这个资源副本。如果有更新，服务器就直接返回最新的资源给浏览器。</p>
        <h3 id="bdd76933-ce71-4065-b287-f2b1de5360b9">如何保持登录状态</h3>
        <ol>
            <li>用户在登录页面中填入账号与密码，该页面的脚本会根据账号密码来生成用户信息，并调用 POST 方法将用户信息发送给服务器。</li>
            <li>服务器接收到用户信息，若用户信息正确，则会生成一段表示用户身份的字符串，并将该字符串写入响应头的 <code>Set-Cookit</code> 字段中，然后将响应头发送给浏览器，比如 <code>Set-Cookie:UID=123456</code>。</li>
            <li>浏览器接收到响应头，若响应头中含有 <code>Set-Cookie</code> 字段，则会将该字段的信息缓存至本地。</li>
            <li>用户再次访问页面时，浏览器会读取缓存 Cookie 数据，比那个将该数据写入请求头的 Cookie 字段中，然后将该请求头发送给服务器。</li>
            <li>服务器接收到请求头，会验证 Cookie 字段的信息，然后根据浏览器的地址与过往的登录记录来判断登录状态，最后决定向浏览器发送何种登录状态的页面数据。</li>
            <li>最后，浏览器接收到登陆状态或未登录状态的页面数据。</li>
        </ol>
    </article>
</body>

</html>