<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>响应式设计</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=b01cb36f-060b-497d-ba25-a3911ee14fe8>布局类型</p>
        <p data-target-id=4e8d829d-729a-4674-82a3-7046bf227777>媒体查询</p>
        <p data-target-id=66a6ec27-96ba-46e1-b037-b456aeec0059>国际化</p>
        <p data-target-id=f36145be-9c6d-44b9-ba34-de63b8b1fc93>宏布局</p>
        <p data-target-id=ac2311cb-760b-4c88-a3bc-cd57878b0d6c>微布局</p>
        <p data-target-id=4bec7b73-8f2d-4e52-8d2c-ec793179d0f7>文字</p>
        <p data-target-id=adb7c8a2-10e1-48d8-a8fd-39a2d7f4cea5>图像</p>
        <p data-target-id=9d4635da-674d-40c9-8b2a-627b3089aaed>主题</p>
        <p data-target-id=a87b9747-16d2-4178-bc84-b1563befdddb>色觉缺陷</p>
        <p data-target-id=2d43f5bc-9fef-492d-90b8-d29e681d29d4>虚拟键盘</p>
        <p data-target-id=164ef8af-cce8-4693-aa87-74a5ebfed15c>参考</p>
    </aside>
    <article>
        <h1>响应式设计</h1>
        <h2 id="b01cb36f-060b-497d-ba25-a3911ee14fe8">布局类型</h2>
        <h3 id="7dacb173-050f-42a1-9ba9-94c0336ab43a">固定宽度布局</h3>
        <p>固定宽度布局是指使用固定的宽度来设计网页的布局。固定宽度布局的通用性很差，因为现代设备的尺寸的多样性太丰富了。</p>
        <p>比如这就是一个固定宽度布局：</p>
        <pre><code class="language-css">body {
    width: 1980ox;
}
</code></pre>
        <h3 id="ce61c785-20f4-4c43-8e91-a2d14db74c21">流体布局</h3>
        <p>流体布局又称为液体布局、灵活布局，它是指使用列宽的百分比来设计网页的布局。流体布局在极端尺寸下的表现并不好，比如在宽屏上会显得拉伸，在窄屏上会显得压扁。</p>
        <p>比如这就是一个流体布局：</p>
        <pre><code class="language-css">body {
    width: 50%;
}
</code></pre>
        <h3 id="d8f09891-6d1c-4ea7-b595-6bfbeea9df09">自适应布局</h3>
        <p>自适应布局是固定宽度布局和 CSS 媒体查询的混合体，自适应布局会拥有多套固定宽度布局方案，然后根据 CSS 媒体查询的结果，来为不同尺寸的设备应用不同的方案。自适应布局还不够完美，因为现代设备的尺寸的多样性太丰富了，而自适应布局的方案数是有限的。</p>
        <h3 id="67076123-6f38-4fbd-b20f-42a96cf194b6">响应式布局</h3>
        <p>响应式布局是流体布局和 CSS 媒体查询的混合体。</p>
        <h2 id="4e8d829d-729a-4674-82a3-7046bf227777">媒体查询</h2>
        <p>媒体查询用于帮助我们将样式应用至特定的设备。</p>
        <h3 id="8657c512-a0e9-42da-adff-b42d714a2477">查询媒体类型</h3>
        <p>我们可以通过指定媒体的类型，来为特定类型的媒体应用特定的样式，我们有 2 种编写方法：</p>
        <ol>
            <li>
                <p>在样式表内编写：</p>
                <p>我们先将网页在所有类型的媒体上的背景色设置为黑色，然后再将网页被打印时的背景色设置为透明色，这样可以节省打印机的墨水。</p>
                <pre><code class="language-css">body {
    background-color: black;
}

@media print {
    body {
        background-color: transparent;
    }
}
</code></pre>
            </li>
            <li>
                <p>在 <code>&lt;link&gt;</code> 标签内编写：</p>
                <p>我们先设置网页在所有类型的媒体上使用 <code>global.css</code>，然后再设置网页在被打印时使用 <code>print.css</code>。</p>
                <pre><code class="language-css">&lt;link rel=&quot;stylesheet&quot; href=&quot;global.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot;&gt;
</code></pre>
            </li>
        </ol>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>如果我们没有为 CSS 块和 <code>&lt;link&gt;</code> 标签指定任何媒体类型，那么它们就会使用默认的媒体类型，这个默认的媒体类型是 <code>all</code>。</p>
        </blockquote>
        <h3 id="7b31d852-f8da-4ad3-8c24-9d03f5f41bac">查询条件</h3>
        <p>我们可以通过指定特殊的条件，来为满足特殊条件的所有类型的媒体应用特定的样式。比如，我们可以根据浏览器窗口是处于横向模式（视口宽度大于视口高度）还是纵向模式（视口高度大于视口宽度），来为其应用不同的样式。</p>
        <p>我们有 2 种编写方法：</p>
        <ol>
            <li>
                <p>在样式表内编写：</p>
                <pre><code class="language-css">@media ( orientation: landscape ) {
    /* 横向模式的样式 */
}
@media ( orientation: portrait ) {
    /* 纵向模式的样式 */
}
</code></pre>
            </li>
            <li>
                <p>在 <code>&lt;link&gt;</code> 标签内编写：</p>
                <pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;landscape.css&quot; media=&quot;(orientation: landscape)&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;portrait.css&quot; media=&quot;(orientation: portrait)&quot;&gt;
</code></pre>
            </li>
        </ol>
        <h3 id="fbc1fa86-a29f-4bfc-b4c4-98125b2f6cc3">响应尺寸</h3>
        <p>对于响应式布局，最有用的查询条件之一就是浏览器视口的尺寸，比如：</p>
        <pre><code class="language-css">@media ( min-width: 100vh ) {
    /* 该样式仅在视口宽度大于或等于视口高度时生效 */
}
@media ( max-width: 100vh ) {
    /* 该样式仅在视口宽度小于或等于视口高度时生效 */
}
</code></pre>
        <h3 id="5b1db628-1565-40fe-a631-80c3041d127b">组合使用</h3>
        <p>我们可以把查询媒体类型和查询条件结合在一起来使用，比如：</p>
        <pre><code class="language-css">@media all and ( orientation: landscape ) {
   /* 横向模式的样式 */
}
@media all and ( orientation: portrait ) {
   /* 纵向模式的样式 */
}
</code></pre>
        <pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;landscape.css&quot; media=&quot;all and (orientation: landscape)&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;portrait.css&quot; media=&quot;all and (orientation: portrait)&quot;&gt;
</code></pre>
        <p>也可以把多个查询条件结合在一起来说用，比如：</p>
        <pre><code class="language-css">@media ( min-width: 100vh ) and ( max-width: 200vh ) {
  /* 该样式仅在视口宽度大于一倍视口高度、小于两倍视口高度时生效 */
}
</code></pre>
        <h3 id="ef1bf0ea-c8f0-4c44-a395-b844b85d74fa">媒体特性手册</h3>
        <p>请参考这两篇文章，但它们都没有包含所有的媒体特性。</p>
        <ul>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries">https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media">https://developer.mozilla.org/en-US/docs/Web/CSS/@media</a></li>
        </ul>
        <h2 id="66a6ec27-96ba-46e1-b037-b456aeec0059">国际化</h2>
        <p>汉语、英语的阅读习惯是从左到右，而阿拉伯语、希伯来语的阅读习惯是从右到左，为了使你的站点可以在不同阅读习惯的语种国家中正常的显示，请使用逻辑属性来替代方向属性，比如：</p>
        <pre><code class="language-css">/* 禁用 */
label {
    margin-top: 1em;
    margin-right: 1em;
}
/* 请用 */
label {
    margin-block-start: 1em;
    margin-inline-end: 1em;
}
</code></pre>
        <p>详见 <a href="https://web.dev/learn/design/internationalization/">Learn Responsive Design - Internationalization</a>。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>请注意，目前媒体查询中的查询条件还不支持逻辑属性，即 <code>@media ( min-inline-size: 100vh ) {}</code> 是不起作用的。</p>
        </blockquote>
        <h2 id="f36145be-9c6d-44b9-ba34-de63b8b1fc93">宏布局</h2>
        <p>宏布局是指可以响应多种不同尺寸的媒体的布局。</p>
        <p>详见 <a href="https://web.dev/learn/design/macro-layouts/">Learn Responsive Design - Macro layouts</a>。</p>
        <h2 id="ac2311cb-760b-4c88-a3bc-cd57878b0d6c">微布局</h2>
        <p>微布局是指组件层面的布局，即为组件设计样式，而非为页面设计样式。另外，Chrome 推出了一个 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries">容器查询</a> 特性，这是一个和媒体查询平级的有趣特性，不过目前它仅支持最新的 Chromium (PC) 和 Safari (PC &amp; iOS)。</p>
        <p>另外，关于微布局，有一个“容器查询”新特性</p>
        <p>详见 <a href="https://web.dev/learn/design/micro-layouts/">Learn Responsive Design - Micro layouts</a>。</p>
        <h2 id="4bec7b73-8f2d-4e52-8d2c-ec793179d0f7">文字</h2>
        <h3 id="a7623bf9-4097-4bbf-bee9-1d8a939b2d08">固定字号</h3>
        <p>如果网页被显示在小屏幕上，那么我们就应该使用更小的字号，如果网页被显示在大屏幕上，那么我们就应该使用更大的字号。之所以要这么做，是因为用户的眼睛往往距离小屏幕更近，距离大屏幕更远，想象一下我们使用智能手机和投影仪时的场景。</p>
        <p>下例是一个固定字号的例子：</p>
        <pre><code class="language-css">@media ( min-width: 30em ) {
    html { font-size: 125%; }
}

@media ( min-width: 40em ) {
    html { font-size: 150%; }
}

@media ( min-width: 50em ) {
    html { font-size: 175%; }
}

@media ( min-width: 60em ) {
    html { font-size: 200%; }
}
</code></pre>
        <p>不过，固定字号方案有一个明显的缺陷，那就是字号会在断点（查询条件变为真的点）处发生突变。比如在上例中，当页面宽度为 <code>39em</code> 时，字号大小是 <code>1.25</code> 倍，当页面宽度稍微增长到 <code>40em</code> 时，字号就会猛增至 <code>1.5</code> 倍。</p>
        <p>为了解决固定字号方案的这个缺陷，于是便有了弹性字号方案。</p>
        <h3 id="d1180b7a-dc78-432e-8434-0d75316bc660">弹性字号</h3>
        <p>弹性字号方案可以解决固定字号方案的缺陷，它的做法就是让字号与页宽挂钩，请看下面的例子：</p>
        <pre><code class="language-css">html {
    font-size: clamp( 1rem, 0.75rem + 1vw, 2rem );
}
</code></pre>
        <p>上例中，字号会随着页宽的变化而变化，这可以让字号的过渡显得更加自然，并且我们限制了字号的极限大小，这样就不用担心字号在窄屏幕上变得太小，在宽屏幕上变得太大了。如果你不熟悉 <code>clamp</code>，那么请见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clamp">MDN - clamp</a>。</p>
        <h4 id="f8a24467-cf12-4902-9211-c165167ec992">陷阱 1</h4>
        <p>请不要像下面这样编写弹性字号方案，因为这会导致无论用户如何缩放网页，网页字体的大小都不会变化。</p>
        <pre><code class="language-css">html {
    font-size: clamp( 1rem, 1vw, 2rem );
}
</code></pre>
        <h4 id="9d5d4c3e-ecb9-4977-a6c5-fa5a51ff2309">陷阱 2</h4>
        <p>请不要像下面这样编写弹性字号方案，因为这会导致字号在窄屏幕下变得太小，在宽屏幕下变得太大。</p>
        <pre><code class="language-css">html {
    font-size: clacl( 0.75rem + 1vw );
}
</code></pre>
        <h3 id="aabe297d-45dc-4c25-9b46-48791ba1b373">断行 &amp; 分段</h3>
        <p>如果文本行的行长太长了，那么就会破坏阅读的体验，因此我们需要在合适的位置断行。如果页面宽度有充分的余量，那么我们还可以进行分列。</p>
        <pre><code class="language-css">/* 分段 */
@media { min-width: 110ch } {
    article { column-count: 2; }
}

/* 断行 */
article {
    max-inline-size: 50ch;
}
</code></pre>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>请使用 <code>ch</code> 和 <code>ic</code> 来作为断行的长度单位，<code>ch</code> 代表阿拉伯数字 <code>0</code> 的宽度，<code>ic</code> 代表 CJK 表意文字 <code>水</code> 的宽度。</p>
        </blockquote>
        <p>断行与分段的关键之一是合适的断点，<a href="http://webtypography.net/2.1.2">《The Elements of Typographic Style Applied to the Web》</a> 中提到 “对于单列文章而言，45～75个字符（包括空格）都是较好的行长，尤其是66个字符。对于多列文章而言，40～50个字符则更加合适”。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>其原文为：Anything from 45 to 75 characters is widely regarded as a satisfactory length of line for a single-column page set in a serifed text face in a text size. The 66-character line (counting both letters and spaces) is widely regarded as ideal. For multiple column work, a better average is 40 to 50 characters.</p>
        </blockquote>
        <h3 id="58775b70-ea76-47cb-aab2-0b6d12edab13">行高</h3>
        <p>行高越大，越不利于读者的眼睛从上一行的末尾移动到下一行的开头，因此较短的文本行可以拥有较大的行高，但是较长的文本行则不应使用较大的行高。</p>
        <p>另外，你应该使用 <code>line-height: 1.5</code>，而不要使用 <code>line-height: 24px</code>，因为这样可以确保文本行的行高可以自动适应 <code>font-size</code> 的大小。</p>
        <h3 id="2b20bdc5-275b-4008-b0c7-f7e6dfed3f7e">字体族</h3>
        <h4 id="900582fc-308c-4277-a908-d4d209d164bc">加载 &amp; 使用</h4>
        <p>我们可以通过 <code>@font-face</code> 来为网页添加外部的字体族资源。</p>
        <pre><code class="language-css">@font-face {
    font-family: &quot;Fira Code&quot;;
    src: url( &quot;/font/fira-code.woff2&quot; ) format( &quot;woff2&quot; );
}
</code></pre>
        <p>因为我们在 <code>@font-face</code> 中将外部的字体族资源命名为了 <code>Fira Code</code>，所以我们可以通过 <code>font-family: &quot;Fira Code&quot;</code> 来直接使用这个字体族。</p>
        <pre><code class="language-css">html {
    font-family: &quot;Fira Code&quot;;
}
</code></pre>
        <h4 id="c9e5c94f-c213-4371-b464-573ea015d22f">字形 &amp; 字重</h4>
        <p>因为 <code>Fira Code</code> 字体不支持细体、粗体、斜体，所以我们需要在 <code>@font-face</code> 中补充 <code>font-style: normal</code> 和 <code>font-weight: normal</code>。</p>
        <p>这样做的用处是，仅当元素的 <code>font-style</code> 和 <code>font-weight</code> 均为 <code>normal</code> 时，<code>Fira Code</code> 字体族才会生效，否则就不会生效（回退到使用默认字体族）。</p>
        <pre><code class="language-css">@font-face {
    font-family: &quot;Fira Code&quot;;
    font-style: normal;
    font-weight: normal;
    src: url( &quot;/font/fira-code.woff2&quot; ) format( &quot;woff2&quot; );
}

/* Fira Code生效 */
p.italic {
    font-familg: &quot;Fira Code&quot;;
    font-style: italic;
}

/* Fira Code不生效 */
p.normal {
    font-familg: &quot;Fira Code&quot;;
    font-style: normal;
}
</code></pre>
        <p>如果我们不增加这两条规则，那么浏览器就会通过强行加粗和拉斜来使 <code>Fira Code</code> 适应粗体和斜体文本。不过强行加粗和拉斜的效果并不美观，而我们使用字体的目的不就是为了美观吗？</p>
        <h4 id="46376247-ca48-4cd1-9885-7943eb2fdbbd">可变字体</h4>
        <p>另外，有些字体族可以自适应斜体和不同的字重，这是因为这些字体族文件的内部包含了多套字形，我们把这些字体族称为“可变字体”。可变字体的好处是更加易用，坏处是体积更大，因为它们包含了更多的字形数据。</p>
        <p>不过，现在越来越多的系统字体已经变成了可变字体，比如 <code>system-ui</code>。</p>
        <h4 id="6e8344b8-d573-43c1-a4e2-044c067ea7c9">短路加载</h4>
        <p>我们可以通过 <code>@font-face</code> 中的 <code>src</code> 属性来让浏览器短路加载字体族资源，这可以加速字体族资源的加载，具体做法是：</p>
        <pre><code class="language-css">@font-face {
    font-family: &quot;Fira Code&quot;;
    src: local( &quot;Fira Code&quot; ),
         url( &quot;/font/fira-code.woff2&quot; ) format( &quot;woff2&quot; ),
         url( &quot;/font/fira-code.woff&quot; ) format( &quot;woff&quot; ),
         url( &quot;/font/fira-code.ttf&quot; ) format( &quot;ttf&quot; );
}
</code></pre>
        <p>其工作原理如下：</p>
        <ol>
            <li>浏览器检查本地机器中是否存在名为 <code>Fira Code</code> 的字体族资源：<ol>
                    <li>如果不存在，则跳转到 2。</li>
                    <li>如果存在，则直接使用该字体族资源，然后结束。</li>
                </ol>
            </li>
            <li>浏览器检查自身是否支持 <code>woff2</code>：<ol>
                    <li>如果不支持，则跳转到 3。</li>
                    <li>如果支持，则尝试下载 <code>/font/fira-code.woff2</code> 的字体族资源：<ol>
                            <li>如果下载失败，则跳转到 3。</li>
                            <li>如果下载成功，则直接使用该字体族资源，然后结束。</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>浏览器检查自身是否支持 <code>woff</code>：<ol>
                    <li>如果不支持，则跳转到 4。</li>
                    <li>如果支持，则尝试下载 <code>/font/fira-code.woff</code> 的字体族资源：<ol>
                            <li>如果下载失败，则跳转到 4。</li>
                            <li>如果下载成功，则直接使用该字体族资源，然后结束。</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>浏览器检查自身是否支持 <code>tff</code>：<ol>
                    <li>如果不支持，则跳转到 5。</li>
                    <li>如果支持，则尝试下载 <code>/font/fira-code.ttf</code> 的字体族资源：<ol>
                            <li>如果下载失败，则跳转到 5。</li>
                            <li>如果下载成功，则直接使用该字体族资源，然后结束。</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>浏览器使用默认字体来替代 <code>Fira Code</code>。</li>
        </ol>
        <h4 id="bd363ef9-4959-4cb1-b9aa-704bc90ae58b">优先加载</h4>
        <p>我们可以通过 <code>&lt;link&gt;</code> 标签来让浏览器优先下载我们的字体族资源，具体做法是：</p>
        <pre><code class="language-html">&lt;head&gt;
    &lt;link href=&quot;/font/fira-code.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; rel=&quot;preload&quot; crossorigin&gt;
&lt;/head&gt;
</code></pre>
        <p><code>rel=&quot;preload&quot;</code> 属性用于告知浏览器优先下载该资源。<code>as=&quot;font&quot;</code> 用于告知浏览器该资源的类型。<code>type=&quot;font/woff2&quot;</code> 用于进一步告知浏览器该资源的类型。<code>crossorigin</code> 用于告知浏览器使用 CORS 来获取资源，并且无论你的字体族资源是否被托管在别的域，你都必须设置该属性，否则浏览器就会不加载。</p>
        <h4 id="92e72e38-02f5-4da3-a26f-cf35115c1660">切换字体族</h4>
        <p>下载外部的字体族资源需要时间，因此网页需要等待一段时间才能使用上外部的字体族，那么我们的网页在这个等待的期间会怎样渲染字体呢？</p>
        <p>我们可以通过在 <code>@font-face</code> 中定义 <code>font-display</code> 属性来控制等待期间的字体渲染，它有 5 种取值：<code>auto</code>、<code>block</code>、<code>swap</code>、<code>fallback</code>、<code>optional</code>。</p>
        <p>我认为下例是大多数情况下的最佳选择。</p>
        <pre><code class="language-css">@font-face {
    font-family: &quot;Fira Code&quot;;
    font-display: swap;
    src: url( &quot;/font/fira-code.woff2&quot; ) format( &quot;woff2&quot; );
}
</code></pre>
        <ul>
            <li>网页会先经历一个极短的无字时间：<ul>
                    <li>如果在此期间，网页还没有加载好外部的字体族资源，那么任何使用该字体族资源的元素都会渲染不可见的后备字体，这看起来就像是没有渲染字体。</li>
                    <li>如果在此期间，网页加载好了外部的字体族资源，那么就立即使用该字体族组件。</li>
                </ul>
            </li>
            <li>网页会进入到无限长的有字时间：<ul>
                    <li>如果在此期间，网页还没有加载好外部的字体资源，那么任何使用该字体族资源的元素都会渲染后备字体。</li>
                    <li>如果在此期间，网页加载好了外部的字体族资源，那么就立即使用该字体族组件。</li>
                </ul>
            </li>
        </ul>
        <p>你可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-display#Browser_compatibility">MDN - font-display</a> 来了解其他用法。</p>
        <h4 id="768f81a4-43f2-4110-a17c-711e364aea52">切换时闪烁</h4>
        <p>切换字体族时，网页通常发生闪烁，这个闪烁其实是一种布局偏移。触发该闪烁的原因是，切换前后的两种字体族的间距等属性是不一样的。你可以通过 <a href="https://web.dev/css-size-adjust/">这篇文章</a> 来详细了解这个闪烁。</p>
        <p>我们可以通过 <code>@font-face</code> 中的 <code>size-adjust</code> 属性来解决这个闪烁，请通过 <a href="https://web.dev/css-size-adjust/">这篇文章</a> 来学习具体的处理方法，不过我可以提前告诉你，这个处理很麻烦，因为它的思路是通过反复的手工校准切换前后的字体，来使切换前后的字体可以尽可能的拥有相似的布局。</p>
        <h2 id="adb7c8a2-10e1-48d8-a8fd-39a2d7f4cea5">图像</h2>
        <h3 id="1b7c71de-a24a-4a35-a55c-7d82166a1590">尺寸</h3>
        <p>如果我们不主动设置图像的尺寸，那么网页就会使用图像的自然尺寸，如果图像的自然尺寸超出了视口的大小，那么网页就会在水平或垂直方向上生成滚动条，这是一种糟糕的体验，因此我们需要主动设置图像的尺寸。</p>
        <p>下例方案可以让图像在铺满屏幕某一轴的同时，又保持原来的横纵比。</p>
        <pre><code class="language-css">img {
    max-inline-size: 100%;
    block-size: auto;
}
</code></pre>
        <h3 id="65e5685a-020c-4e5e-8ffb-7a33da76426f">横纵比</h3>
        <p>请使用 <code>aspect-ratio</code> 属性来一次性的设置图像的横纵比，而不要通过手写宽高属性来设置图像的横纵比，这不仅仅是因为前者更加简洁，还因为前者遵循方向逻辑。</p>
        <p>比如，当 <code>writing-mode: horizontal-tb</code> 时，<code>aspect-ratio: 2/1</code> 代表横是纵的两倍。</p>
        <pre><code class="language-css">img {
    max-inline-size: 100%;
    block-size: auto;
    aspect-ratio: 2/1;
}
</code></pre>
        <h3 id="9706992c-3a29-4b55-841a-be116666ad50">框内布局</h3>
        <p><code>max-inline-size</code>、<code>block-size</code>、<code>aspect-ratio</code> 等属性用于设置图像元素的内容框的尺寸，而我们还可以进步一设置图像元素的内容相对于内容框的布局，这就需要用到 <code>object</code> 系列的属性。</p>
        <p>其中，图像元素的内容是指图像本身，图像元素的内容框是指盒子的内容框。</p>
        <h4 id="b2a1a9d6-2999-4588-8964-67510debbe9c">object-fit</h4>
        <p><code>object-fit</code> 属性用于设置图像元素的内容在其内容框中的布局，它有一点点像 <code>background-size</code> 属性，它有 5 种取值，分别是：<code>contain</code>、<code>cover</code>、<code>fill</code>、<code>none</code>、<code>scale-down</code>。</p>
        <p>其中 <code>contain</code> 属性最有趣，它可以在保持图像横纵比的前提下，缩放图像以使其至少铺满内容框的某一轴，如果图像没有铺满另一轴，那么图像就会在该轴方向上居中，并在两侧留下透明的空余空间。</p>
        <pre><code class="language-css">img {
    max-inline-size: 100%;
    block-size: auto;
    object-fit: contain;
}
</code></pre>
        <h4 id="cfca503a-cf51-48c8-9eb0-c675975be7a4">object-position</h4>
        <p><code>object-position</code> 属性用于设置图像元素的内容在其内容框中的偏移，它很像 <code>background-position</code> 属性，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-position">MDN - object-position</a>。</p>
        <h3 id="9acf26db-69f9-4580-bb6c-57f1ae4607f9">尺寸提示</h3>
        <p>如果你预先就知道图像的尺寸，那么请务必为 <code>&lt;img&gt;</code> 标签设置 <code>width</code> 和 <code>height</code> 属性，浏览器可以通过这两个属性来提前获知图像的尺寸，然后为图像预留相应的空间来“占位”。</p>
        <pre><code class="language-html">&lt;img width=&quot;100&quot; height=&quot;100&quot;&gt;
</code></pre>
        <p>想象一下，如果浏览器没有为图像预留占位的空间，那么当图像还未加载完成时，图像元素的高度就是 <code>0</code>，此时图像元素的上文和下文会紧紧的挨在一起，而当图像加载完成后，由于图像元素拥有了高度，此时图像元素的上文和下文就会一下子被挤开，这在视觉上表现为闪烁和跳转，这会破坏用户的阅读体验，因为用户的视觉锚点一下子就消失了。</p>
        <p>如果浏览器为图像预留了占位的空间，那么无论图像是否加载完成，图像元素都会占据相同的空间，当图像还未加载完成时，占位空间表现为透明色，当图像加载完成后，占位空间就会渲染出图像，这样就可以解决上述问题了。</p>
        <p><a href="https://web.dev/learn/design/responsive-images/#sizing-hints">这个视频</a> 直观的演示了有无占位空间时的区别。</p>
        <h3 id="64d0bceb-4066-4085-bf84-bca48f235366">惰性加载</h3>
        <p><code>&lt;img&gt;</code> 标签的 <code>loading</code> 属性可以启用惰性加载，如下所示。启用惰性下载后，浏览器会延迟加载图像，直至图像接近视口时，浏览器才会加载图像，建议总是为首屏以下的图像启用惰性加载。</p>
        <pre><code class="language-html">&lt;img loading=&quot;lazy&quot;&gt;
</code></pre>
        <p><code>loading</code> 属性的默认值时 <code>eager</code>，此时无论图像是否出现在视口之内，浏览器都会立即加载图像。</p>
        <h3 id="2e826ecb-0fd8-45e5-b070-f915b1d383d4">惰性解码</h3>
        <p><code>&lt;img&gt;</code> 标签的 <code>decoding</code> 属性可以启用惰性解码，如下所示。图像解码会阻塞其他的操作，如果我们设置了异步解码，那么浏览器就可以优先处理网页的其他内容，我通常会为博客中的图像添加惰性解码。</p>
        <pre><code class="language-html">&lt;img decoding=&quot;async&quot;&gt;
</code></pre>
        <p>如果图像对你很重要，那么请使用同步解码。</p>
        <pre><code class="language-html">&lt;img decoding=&quot;sync&quot;&gt;
</code></pre>
        <blockquote>
            <p><strong>Note</strong></p>
            <p><code>decoding</code> 的默认值是 <code>auto</code>，此时将由浏览器来决定到底使用 <code>async</code> 还是 <code>sync</code>。</p>
        </blockquote>
        <h3 id="287f4243-3c23-4006-aecb-2bbe50a8d386">响应尺寸</h3>
        <p>如果你为同一幅图像制作了多个不同分辨率的版本，那么你就可以通过 <code>&lt;img&gt;</code> 标签的 <code>srcset</code> 属性来让浏览器智能的下载合适版本的图像，这可以节省流量和加速图像资源的加载速度。</p>
        <p>详请参阅 <a href="https://web.dev/learn/design/responsive-images/#responsive-images-with-srcset">Responsive images with <code>srcset</code></a> 和 <a href="https://web.dev/learn/design/picture-element/">The picture element</a>。</p>
        <h2 id="9d4635da-674d-40c9-8b2a-627b3089aaed">主题</h2>
        <h3 id="0d26e5d1-983e-4401-a8eb-d0a35ef7c8c6">嗅探系统主题</h3>
        <p>许多操作系统都支持浅色模式和深色模式，比如 Windows 和 MacOS，<code>prefers-color-scheme</code> 媒体特性可以检测出操作系统正在使用哪种模式，然后我们就可以使用不同的主题色。</p>
        <pre><code class="language-css">/* 操作系统正在使用浅色模式 */
@media ( prefers-color-scheme: light ) {
    html { background-color: white; }
}

/* 操作系统正在使用深色模式 */
@media ( prefers-color-scheme: dark ) {
    html { background-color: black; }
}
</code></pre>
        <p>如果操作系统不支持主题色，或未设置主题色，或禁止获取主题色，那么就需要使用：</p>
        <pre><code class="language-css">@media ( prefers-color-scheme: no-preference ) {
    html { background-color: white; }
}
</code></pre>
        <h3 id="54082aa4-7372-4b41-892d-f98cc5298846">accent-color</h3>
        <p>CSS 的 <code>accent-color</code> 属性可以设置单选框、复选框、进度条的颜色。</p>
        <pre><code class="language-css">input {
    accent-color: black;
}
</code></pre>
        <h2 id="a87b9747-16d2-4178-bc84-b1563befdddb">色觉缺陷</h2>
        <p>FireFox 和 Chrome 的开发者工具都可以模拟色觉缺陷的视觉效果，在 FireFox 中，<code>开发者工具 -&gt; 无障碍环境 -&gt; 模拟</code>，在 Chrome 中，<code>开发者工具 -&gt; 渲染选项卡 -&gt; 模拟视觉缺陷</code>。</p>
        <p>Chrome 的色觉缺陷模拟功能比较难找，如果你找不到，那么你可以查看 <a href="https://developer.chrome.com/blog/new-in-devtools-83/#vision-deficiencies">这篇文章</a>。</p>
        <h2 id="2d43f5bc-9fef-492d-90b8-d29e681d29d4">虚拟键盘</h2>
        <p>智能手机使用虚拟键盘来代替实体键盘，你可以通过参阅 <a href="https://web.dev/learn/design/interaction/#virtual-keyboards">这篇文章</a> 来学习如何优化虚拟键盘，这些优化是指：</p>
        <ul>
            <li>如何唤醒整数数字键盘；</li>
            <li>如何唤醒浮点数数字键盘；</li>
            <li>如何让虚拟键盘自动联想出相关内容，比如电话号码、邮箱、国家。</li>
        </ul>
        <h2 id="164ef8af-cce8-4693-aa87-74a5ebfed15c">参考</h2>
        <p><a href="https://web.dev/learn/design/">Learn Responsive Design</a></p>
    </article>
</body>

</html>