<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>响应式设计</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=e7abc348-bc55-4e5d-b106-e846a8dc0ba0>布局类型</p>
        <p data-target-id=05e4544d-3aa0-45cf-8eae-40d3482be7ba>媒体查询</p>
        <p data-target-id=c2292a4b-7663-4570-968c-94347260ea74>国际化</p>
        <p data-target-id=c1caefaa-6031-4d67-b889-194030bc79b3>宏布局</p>
        <p data-target-id=236cca15-fd23-445c-9eb5-844c075a3992>微布局</p>
        <p data-target-id=6ff5d3ed-24cf-48e8-9adb-10471d9c0c58>文字</p>
        <p data-target-id=d9c26065-837d-4dd2-9e89-7ba377c6b85e>图像</p>
        <p data-target-id=bc6d3703-de6e-48d5-a21b-25d215ba5ca6>主题</p>
        <p data-target-id=66a2e56f-36e0-46be-9643-c7870717b0c7>色觉缺陷</p>
        <p data-target-id=b4e76104-5c12-4ae7-9e76-ca9ea995b10d>虚拟键盘</p>
        <p data-target-id=1db884a8-f0f3-4f83-8eb7-ab93266d6cd1>参考</p>
    </aside>
    <article>
        <h1>响应式设计</h1>
        <h2 id="e7abc348-bc55-4e5d-b106-e846a8dc0ba0">布局类型</h2>
        <h3 id="42ef9a53-ca98-48b4-bd08-51cb06f1bec1">固定宽度布局</h3>
        <p>固定宽度布局是指使用固定的宽度来设计网页的布局。固定宽度布局的通用性很差，因为现代设备的尺寸的多样性太丰富了。</p>
        <p>比如这就是一个固定宽度布局：</p>
        <pre><code class="language-css">body {
    width: 1980ox;
}
</code></pre>
        <h3 id="53b901f9-3254-4e57-8a7d-a91f9fc82530">流体布局</h3>
        <p>流体布局又称为液体布局、灵活布局，它是指使用列宽的百分比来设计网页的布局。流体布局在极端尺寸下的表现并不好，比如在宽屏上会显得拉伸，在窄屏上会显得压扁。</p>
        <p>比如这就是一个流体布局：</p>
        <pre><code class="language-css">body {
    width: 50%;
}
</code></pre>
        <h3 id="0c020137-8fe0-4d10-b441-07febe9fd534">自适应布局</h3>
        <p>自适应布局是固定宽度布局和 CSS 媒体查询的混合体，自适应布局会拥有多套固定宽度布局方案，然后根据 CSS 媒体查询的结果，来为不同尺寸的设备应用不同的方案。自适应布局还不够完美，因为现代设备的尺寸的多样性太丰富了，而自适应布局的方案数是有限的。</p>
        <h3 id="d077ab3d-fc44-4b29-9d97-ef7b29fefc6e">响应式布局</h3>
        <p>响应式布局是流体布局和 CSS 媒体查询的混合体。</p>
        <h2 id="05e4544d-3aa0-45cf-8eae-40d3482be7ba">媒体查询</h2>
        <p>媒体查询用于帮助我们将样式应用至特定的设备。</p>
        <h3 id="470804b4-dc5c-4051-95b3-c93b004ef40f">查询媒体类型</h3>
        <p>我们可以通过指定媒体的类型，来为特定类型的媒体应用特定的样式，我们有 2 种编写方法：</p>
        <ol>
            <li>
                <p>在样式表内编写：</p>
                <p>我们先将网页在所有类型的媒体上的背景色设置为黑色，然后再将网页被打印时的背景色设置为透明色，这样可以节省打印机的墨水。</p>
                <pre><code class="language-css">body {
    background-color: black;
}

@media print {
    body {
        background-color: transparent;
    }
}
</code></pre>
            </li>
            <li>
                <p>在 <code>&lt;link&gt;</code> 标签内编写：</p>
                <p>我们先设置网页在所有类型的媒体上使用 <code>global.css</code>，然后再设置网页在被打印时使用 <code>print.css</code>。</p>
                <pre><code class="language-css">&lt;link rel=&quot;stylesheet&quot; href=&quot;global.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot;&gt;
</code></pre>
            </li>
        </ol>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>如果我们没有为 CSS 块和 <code>&lt;link&gt;</code> 标签指定任何媒体类型，那么它们就会使用默认的媒体类型，这个默认的媒体类型是 <code>all</code>。</p>
        </blockquote>
        <h3 id="a8815621-895d-42a2-a39c-5ce1aeab0d81">查询条件</h3>
        <p>我们可以通过指定特殊的条件，来为满足特殊条件的所有类型的媒体应用特定的样式。比如，我们可以根据浏览器窗口是处于横向模式（视口宽度大于视口高度）还是纵向模式（视口高度大于视口宽度），来为其应用不同的样式。</p>
        <p>我们有 2 种编写方法：</p>
        <ol>
            <li>
                <p>在样式表内编写：</p>
                <pre><code class="language-css">@media ( orientation: landscape ) {
    /* 横向模式的样式 */
}
@media ( orientation: portrait ) {
    /* 纵向模式的样式 */
}
</code></pre>
            </li>
            <li>
                <p>在 <code>&lt;link&gt;</code> 标签内编写：</p>
                <pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;landscape.css&quot; media=&quot;(orientation: landscape)&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;portrait.css&quot; media=&quot;(orientation: portrait)&quot;&gt;
</code></pre>
            </li>
        </ol>
        <h3 id="a5c64931-4b86-4e93-95ec-164077b2b2b2">响应尺寸</h3>
        <p>对于响应式布局，最有用的查询条件之一就是浏览器视口的尺寸，比如：</p>
        <pre><code class="language-css">@media ( min-width: 100vh ) {
    /* 该样式仅在视口宽度大于或等于视口高度时生效 */
}
@media ( max-width: 100vh ) {
    /* 该样式仅在视口宽度小于或等于视口高度时生效 */
}
</code></pre>
        <h3 id="ada518e3-ea88-493c-a18b-2c5cc334feda">组合使用</h3>
        <p>我们可以把查询媒体类型和查询条件结合在一起来使用，比如：</p>
        <pre><code class="language-css">@media all and ( orientation: landscape ) {
   /* 横向模式的样式 */
}
@media all and ( orientation: portrait ) {
   /* 纵向模式的样式 */
}
</code></pre>
        <pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;landscape.css&quot; media=&quot;all and (orientation: landscape)&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;portrait.css&quot; media=&quot;all and (orientation: portrait)&quot;&gt;
</code></pre>
        <p>也可以把多个查询条件结合在一起来说用，比如：</p>
        <pre><code class="language-css">@media ( min-width: 100vh ) and ( max-width: 200vh ) {
  /* 该样式仅在视口宽度大于一倍视口高度、小于两倍视口高度时生效 */
}
</code></pre>
        <h3 id="bea4386b-d4ac-425e-b32b-43ea448c2d6b">媒体特性手册</h3>
        <p>请参考这两篇文章，但它们都没有包含所有的媒体特性。</p>
        <ul>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries">https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media">https://developer.mozilla.org/en-US/docs/Web/CSS/@media</a></li>
        </ul>
        <h2 id="c2292a4b-7663-4570-968c-94347260ea74">国际化</h2>
        <p>汉语、英语的阅读习惯是从左到右，而阿拉伯语、希伯来语的阅读习惯是从右到左，为了使你的站点可以在不同阅读习惯的语种国家中正常的显示，请使用逻辑属性来替代方向属性，比如：</p>
        <pre><code class="language-css">/* 禁用 */
label {
    margin-top: 1em;
    margin-right: 1em;
}
/* 请用 */
label {
    margin-block-start: 1em;
    margin-inline-end: 1em;
}
</code></pre>
        <p>详见 <a href="https://web.dev/learn/design/internationalization/">Learn Responsive Design - Internationalization</a>。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>请注意，目前媒体查询中的查询条件还不支持逻辑属性，即 <code>@media ( min-inline-size: 100vh ) {}</code> 是不起作用的。</p>
        </blockquote>
        <h2 id="c1caefaa-6031-4d67-b889-194030bc79b3">宏布局</h2>
        <p>宏布局是指可以响应多种不同尺寸的媒体的布局。</p>
        <p>详见 <a href="https://web.dev/learn/design/macro-layouts/">Learn Responsive Design - Macro layouts</a>。</p>
        <h2 id="236cca15-fd23-445c-9eb5-844c075a3992">微布局</h2>
        <p>微布局是指组件层面的布局，即为组件设计样式，而非为页面设计样式。另外，Chrome 推出了一个 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries">容器查询</a> 特性，这是一个和媒体查询平级的有趣特性，不过目前它仅支持最新的 Chromium (PC) 和 Safari (PC &amp; iOS)。</p>
        <p>另外，关于微布局，有一个“容器查询”新特性</p>
        <p>详见 <a href="https://web.dev/learn/design/micro-layouts/">Learn Responsive Design - Micro layouts</a>。</p>
        <h2 id="6ff5d3ed-24cf-48e8-9adb-10471d9c0c58">文字</h2>
        <h3 id="d52a89f5-3e43-4544-b716-a34bd57c421a">固定字号</h3>
        <p>如果网页被显示在小屏幕上，那么我们就应该使用更小的字号，如果网页被显示在大屏幕上，那么我们就应该使用更大的字号。之所以要这么做，是因为用户的眼睛往往距离小屏幕更近，距离大屏幕更远，想象一下我们使用智能手机和投影仪时的场景。</p>
        <p>下例是一个固定字号的例子：</p>
        <pre><code class="language-css">@media ( min-width: 30em ) {
    html { font-size: 125%; }
}

@media ( min-width: 40em ) {
    html { font-size: 150%; }
}

@media ( min-width: 50em ) {
    html { font-size: 175%; }
}

@media ( min-width: 60em ) {
    html { font-size: 200%; }
}
</code></pre>
        <p>不过，固定字号方案有一个明显的缺陷，那就是字号会在断点（查询条件变为真的点）处发生突变。比如在上例中，当页面宽度为 <code>39em</code> 时，字号大小是 <code>1.25</code> 倍，当页面宽度稍微增长到 <code>40em</code> 时，字号就会猛增至 <code>1.5</code> 倍。</p>
        <p>为了解决固定字号方案的这个缺陷，于是便有了弹性字号方案。</p>
        <h3 id="05428c20-c115-4959-b58a-9eab5b97a9d2">弹性字号</h3>
        <p>弹性字号方案可以解决固定字号方案的缺陷，它的做法就是让字号与页宽挂钩，请看下面的例子：</p>
        <pre><code class="language-css">html {
    font-size: clamp( 1rem, 0.75rem + 1vw, 2rem );
}
</code></pre>
        <p>上例中，字号会随着页宽的变化而变化，这可以让字号的过渡显得更加自然，并且我们限制了字号的极限大小，这样就不用担心字号在窄屏幕上变得太小，在宽屏幕上变得太大了。如果你不熟悉 <code>clamp</code>，那么请见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clamp">MDN - clamp</a>。</p>
        <h4 id="2b320d20-3015-4daf-81d9-1cd360ca46cc">陷阱 1</h4>
        <p>请不要像下面这样编写弹性字号方案，因为这会导致无论用户如何缩放网页，网页字体的大小都不会变化。</p>
        <pre><code class="language-css">html {
    font-size: clamp( 1rem, 1vw, 2rem );
}
</code></pre>
        <h4 id="c0f89a69-595b-43cd-b795-bb20bffb5940">陷阱 2</h4>
        <p>请不要像下面这样编写弹性字号方案，因为这会导致字号在窄屏幕下变得太小，在宽屏幕下变得太大。</p>
        <pre><code class="language-css">html {
    font-size: clacl( 0.75rem + 1vw );
}
</code></pre>
        <h3 id="68dd65d8-28db-416b-82a7-1ea8199e4817">断行 &amp; 分段</h3>
        <p>如果文本行的行长太长了，那么就会破坏阅读的体验，因此我们需要在合适的位置断行。如果页面宽度有充分的余量，那么我们还可以进行分列。</p>
        <pre><code class="language-css">/* 分段 */
@media { min-width: 110ch } {
    article { column-count: 2; }
}

/* 断行 */
article {
    max-inline-size: 50ch;
}
</code></pre>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>请使用 <code>ch</code> 和 <code>ic</code> 来作为断行的长度单位，<code>ch</code> 代表阿拉伯数字 <code>0</code> 的宽度，<code>ic</code> 代表 CJK 表意文字 <code>水</code> 的宽度。</p>
        </blockquote>
        <p>断行与分段的关键之一是合适的断点，<a href="http://webtypography.net/2.1.2">《The Elements of Typographic Style Applied to the Web》</a> 中提到 “对于单列文章而言，45～75个字符（包括空格）都是较好的行长，尤其是66个字符。对于多列文章而言，40～50个字符则更加合适”。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>其原文为：Anything from 45 to 75 characters is widely regarded as a satisfactory length of line for a single-column page set in a serifed text face in a text size. The 66-character line (counting both letters and spaces) is widely regarded as ideal. For multiple column work, a better average is 40 to 50 characters.</p>
        </blockquote>
        <h3 id="26a7ccf7-e1ab-4361-b215-efdbf51b41bd">行高</h3>
        <p>行高越大，越不利于读者的眼睛从上一行的末尾移动到下一行的开头，因此较短的文本行可以拥有较大的行高，但是较长的文本行则不应使用较大的行高。</p>
        <p>另外，你应该使用 <code>line-height: 1.5</code>，而不要使用 <code>line-height: 24px</code>，因为这样可以确保文本行的行高可以自动适应 <code>font-size</code> 的大小。</p>
        <h3 id="ea87be29-066d-4e18-a3aa-5936ff735419">字体族</h3>
        <h4 id="9620d8e3-a812-4f9a-9f9a-cb4c19eadf90">加载 &amp; 使用</h4>
        <p>我们可以通过 <code>@font-face</code> 来为网页添加外部的字体族资源。</p>
        <pre><code class="language-css">@font-face {
    font-family: &quot;Fira Code&quot;;
    src: url( &quot;/font/fira-code.woff2&quot; ) format( &quot;woff2&quot; );
}
</code></pre>
        <p>因为我们在 <code>@font-face</code> 中将外部的字体族资源命名为了 <code>Fira Code</code>，所以我们可以通过 <code>font-family: &quot;Fira Code&quot;</code> 来直接使用这个字体族。</p>
        <pre><code class="language-css">html {
    font-family: &quot;Fira Code&quot;;
}
</code></pre>
        <h4 id="e6703779-95d6-4cca-bc89-86e274485eea">字形 &amp; 字重</h4>
        <p>因为 <code>Fira Code</code> 字体不支持细体、粗体、斜体，所以我们需要在 <code>@font-face</code> 中补充 <code>font-style: normal</code> 和 <code>font-weight: normal</code>。</p>
        <p>这样做的用处是，仅当元素的 <code>font-style</code> 和 <code>font-weight</code> 均为 <code>normal</code> 时，<code>Fira Code</code> 字体族才会生效，否则就不会生效（回退到使用默认字体族）。</p>
        <pre><code class="language-css">@font-face {
    font-family: &quot;Fira Code&quot;;
    font-style: normal;
    font-weight: normal;
    src: url( &quot;/font/fira-code.woff2&quot; ) format( &quot;woff2&quot; );
}

/* Fira Code生效 */
p.italic {
    font-familg: &quot;Fira Code&quot;;
    font-style: italic;
}

/* Fira Code不生效 */
p.normal {
    font-familg: &quot;Fira Code&quot;;
    font-style: normal;
}
</code></pre>
        <p>如果我们不增加这两条规则，那么浏览器就会通过强行加粗和拉斜来使 <code>Fira Code</code> 适应粗体和斜体文本。不过强行加粗和拉斜的效果并不美观，而我们使用字体的目的不就是为了美观吗？</p>
        <h4 id="54f26162-3b75-46c8-b0e8-e2d1a7d80a0e">可变字体</h4>
        <p>另外，有些字体族可以自适应斜体和不同的字重，这是因为这些字体族文件的内部包含了多套字形，我们把这些字体族称为“可变字体”。可变字体的好处是更加易用，坏处是体积更大，因为它们包含了更多的字形数据。</p>
        <p>不过，现在越来越多的系统字体已经变成了可变字体，比如 <code>system-ui</code>。</p>
        <h4 id="6f34a17f-b114-4994-95fd-18830743f87b">短路加载</h4>
        <p>我们可以通过 <code>@font-face</code> 中的 <code>src</code> 属性来让浏览器短路加载字体族资源，这可以加速字体族资源的加载，具体做法是：</p>
        <pre><code class="language-css">@font-face {
    font-family: &quot;Fira Code&quot;;
    src: local( &quot;Fira Code&quot; ),
         url( &quot;/font/fira-code.woff2&quot; ) format( &quot;woff2&quot; ),
         url( &quot;/font/fira-code.woff&quot; ) format( &quot;woff&quot; ),
         url( &quot;/font/fira-code.ttf&quot; ) format( &quot;ttf&quot; );
}
</code></pre>
        <p>其工作原理如下：</p>
        <ol>
            <li>浏览器检查本地机器中是否存在名为 <code>Fira Code</code> 的字体族资源：<ol>
                    <li>如果不存在，则跳转到 2。</li>
                    <li>如果存在，则直接使用该字体族资源，然后结束。</li>
                </ol>
            </li>
            <li>浏览器检查自身是否支持 <code>woff2</code>：<ol>
                    <li>如果不支持，则跳转到 3。</li>
                    <li>如果支持，则尝试下载 <code>/font/fira-code.woff2</code> 的字体族资源：<ol>
                            <li>如果下载失败，则跳转到 3。</li>
                            <li>如果下载成功，则直接使用该字体族资源，然后结束。</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>浏览器检查自身是否支持 <code>woff</code>：<ol>
                    <li>如果不支持，则跳转到 4。</li>
                    <li>如果支持，则尝试下载 <code>/font/fira-code.woff</code> 的字体族资源：<ol>
                            <li>如果下载失败，则跳转到 4。</li>
                            <li>如果下载成功，则直接使用该字体族资源，然后结束。</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>浏览器检查自身是否支持 <code>tff</code>：<ol>
                    <li>如果不支持，则跳转到 5。</li>
                    <li>如果支持，则尝试下载 <code>/font/fira-code.ttf</code> 的字体族资源：<ol>
                            <li>如果下载失败，则跳转到 5。</li>
                            <li>如果下载成功，则直接使用该字体族资源，然后结束。</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>浏览器使用默认字体来替代 <code>Fira Code</code>。</li>
        </ol>
        <h4 id="27b6df0a-d3e1-4af3-b4bc-3514e01f8d06">优先加载</h4>
        <p>我们可以通过 <code>&lt;link&gt;</code> 标签来让浏览器优先下载我们的字体族资源，具体做法是：</p>
        <pre><code class="language-html">&lt;head&gt;
    &lt;link href=&quot;/font/fira-code.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; rel=&quot;preload&quot; crossorigin&gt;
&lt;/head&gt;
</code></pre>
        <p><code>rel=&quot;preload&quot;</code> 属性用于告知浏览器优先下载该资源。<code>as=&quot;font&quot;</code> 用于告知浏览器该资源的类型。<code>type=&quot;font/woff2&quot;</code> 用于进一步告知浏览器该资源的类型。<code>crossorigin</code> 用于告知浏览器使用 CORS 来获取资源，并且无论你的字体族资源是否被托管在别的域，你都必须设置该属性，否则浏览器就会不加载。</p>
        <h4 id="ab014191-0717-48ab-b29e-4a9ab7068d58">切换字体族</h4>
        <p>下载外部的字体族资源需要时间，因此网页需要等待一段时间才能使用上外部的字体族，那么我们的网页在这个等待的期间会怎样渲染字体呢？</p>
        <p>我们可以通过在 <code>@font-face</code> 中定义 <code>font-display</code> 属性来控制等待期间的字体渲染，它有 5 种取值：<code>auto</code>、<code>block</code>、<code>swap</code>、<code>fallback</code>、<code>optional</code>。</p>
        <p>我认为下例是大多数情况下的最佳选择。</p>
        <pre><code class="language-css">@font-face {
    font-family: &quot;Fira Code&quot;;
    font-display: swap;
    src: url( &quot;/font/fira-code.woff2&quot; ) format( &quot;woff2&quot; );
}
</code></pre>
        <ul>
            <li>网页会先经历一个极短的无字时间：<ul>
                    <li>如果在此期间，网页还没有加载好外部的字体族资源，那么任何使用该字体族资源的元素都会渲染不可见的后备字体，这看起来就像是没有渲染字体。</li>
                    <li>如果在此期间，网页加载好了外部的字体族资源，那么就立即使用该字体族组件。</li>
                </ul>
            </li>
            <li>网页会进入到无限长的有字时间：<ul>
                    <li>如果在此期间，网页还没有加载好外部的字体资源，那么任何使用该字体族资源的元素都会渲染后备字体。</li>
                    <li>如果在此期间，网页加载好了外部的字体族资源，那么就立即使用该字体族组件。</li>
                </ul>
            </li>
        </ul>
        <p>你可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-display#Browser_compatibility">MDN - font-display</a> 来了解其他用法。</p>
        <h4 id="777d4551-8753-4477-bacf-59348ad97c9a">切换时闪烁</h4>
        <p>切换字体族时，网页通常发生闪烁，这个闪烁其实是一种布局偏移。触发该闪烁的原因是，切换前后的两种字体族的间距等属性是不一样的。你可以通过 <a href="https://web.dev/css-size-adjust/">这篇文章</a> 来详细了解这个闪烁。</p>
        <p>我们可以通过 <code>@font-face</code> 中的 <code>size-adjust</code> 属性来解决这个闪烁，请通过 <a href="https://web.dev/css-size-adjust/">这篇文章</a> 来学习具体的处理方法，不过我可以提前告诉你，这个处理很麻烦，因为它的思路是通过反复的手工校准切换前后的字体，来使切换前后的字体可以尽可能的拥有相似的布局。</p>
        <h2 id="d9c26065-837d-4dd2-9e89-7ba377c6b85e">图像</h2>
        <h3 id="d16ac308-e77d-4aeb-8827-6652e9550428">尺寸</h3>
        <p>如果我们不主动设置图像的尺寸，那么网页就会使用图像的自然尺寸，如果图像的自然尺寸超出了视口的大小，那么网页就会在水平或垂直方向上生成滚动条，这是一种糟糕的体验，因此我们需要主动设置图像的尺寸。</p>
        <p>下例方案可以让图像在铺满屏幕某一轴的同时，又保持原来的横纵比。</p>
        <pre><code class="language-css">img {
    max-inline-size: 100%;
    block-size: auto;
}
</code></pre>
        <h3 id="126edf2c-5d45-4f18-9193-bb7bbdc28618">横纵比</h3>
        <p>请使用 <code>aspect-ratio</code> 属性来一次性的设置图像的横纵比，而不要通过手写宽高属性来设置图像的横纵比，这不仅仅是因为前者更加简洁，还因为前者遵循方向逻辑。</p>
        <p>比如，当 <code>writing-mode: horizontal-tb</code> 时，<code>aspect-ratio: 2/1</code> 代表横是纵的两倍。</p>
        <pre><code class="language-css">img {
    max-inline-size: 100%;
    block-size: auto;
    aspect-ratio: 2/1;
}
</code></pre>
        <h3 id="335e2042-e801-4f37-b606-3207e0183175">框内布局</h3>
        <p><code>max-inline-size</code>、<code>block-size</code>、<code>aspect-ratio</code> 等属性用于设置图像元素的内容框的尺寸，而我们还可以进步一设置图像元素的内容相对于内容框的布局，这就需要用到 <code>object</code> 系列的属性。</p>
        <p>其中，图像元素的内容是指图像本身，图像元素的内容框是指盒子的内容框。</p>
        <h4 id="8a627e14-e245-4514-bbd5-7710d0aeac4d">object-fit</h4>
        <p><code>object-fit</code> 属性用于设置图像元素的内容在其内容框中的布局，它有一点点像 <code>background-size</code> 属性，它有 5 种取值，分别是：<code>contain</code>、<code>cover</code>、<code>fill</code>、<code>none</code>、<code>scale-down</code>。</p>
        <p>其中 <code>contain</code> 属性最有趣，它可以在保持图像横纵比的前提下，缩放图像以使其至少铺满内容框的某一轴，如果图像没有铺满另一轴，那么图像就会在该轴方向上居中，并在两侧留下透明的空余空间。</p>
        <pre><code class="language-css">img {
    max-inline-size: 100%;
    block-size: auto;
    object-fit: contain;
}
</code></pre>
        <h4 id="f3171d8d-e536-42b2-b364-2d99c797d4f6">object-position</h4>
        <p><code>object-position</code> 属性用于设置图像元素的内容在其内容框中的偏移，它很像 <code>background-position</code> 属性，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-position">MDN - object-position</a>。</p>
        <h3 id="15f1a77a-4bad-49f6-9fdc-7d0f1f583ffd">尺寸提示</h3>
        <p>如果你预先就知道图像的尺寸，那么请务必为 <code>&lt;img&gt;</code> 标签设置 <code>width</code> 和 <code>height</code> 属性，浏览器可以通过这两个属性来提前获知图像的尺寸，然后为图像预留相应的空间来“占位”。</p>
        <pre><code class="language-html">&lt;img width=&quot;100&quot; height=&quot;100&quot;&gt;
</code></pre>
        <p>想象一下，如果浏览器没有为图像预留占位的空间，那么当图像还未加载完成时，图像元素的高度就是 <code>0</code>，此时图像元素的上文和下文会紧紧的挨在一起，而当图像加载完成后，由于图像元素拥有了高度，此时图像元素的上文和下文就会一下子被挤开，这在视觉上表现为闪烁和跳转，这会破坏用户的阅读体验，因为用户的视觉锚点一下子就消失了。</p>
        <p>如果浏览器为图像预留了占位的空间，那么无论图像是否加载完成，图像元素都会占据相同的空间，当图像还未加载完成时，占位空间表现为透明色，当图像加载完成后，占位空间就会渲染出图像，这样就可以解决上述问题了。</p>
        <p><a href="https://web.dev/learn/design/responsive-images/#sizing-hints">这个视频</a> 直观的演示了有无占位空间时的区别。</p>
        <h3 id="e5a898a5-2308-4ce6-b914-c555560c1bd3">惰性加载</h3>
        <p><code>&lt;img&gt;</code> 标签的 <code>loading</code> 属性可以启用惰性加载，如下所示。启用惰性下载后，浏览器会延迟加载图像，直至图像接近视口时，浏览器才会加载图像，建议总是为首屏以下的图像启用惰性加载。</p>
        <pre><code class="language-html">&lt;img loading=&quot;lazy&quot;&gt;
</code></pre>
        <p><code>loading</code> 属性的默认值时 <code>eager</code>，此时无论图像是否出现在视口之内，浏览器都会立即加载图像。</p>
        <h3 id="227fbc13-0775-4347-9e2d-a65414f1e80b">惰性解码</h3>
        <p><code>&lt;img&gt;</code> 标签的 <code>decoding</code> 属性可以启用惰性解码，如下所示。图像解码会阻塞其他的操作，如果我们设置了异步解码，那么浏览器就可以优先处理网页的其他内容，我通常会为博客中的图像添加惰性解码。</p>
        <pre><code class="language-html">&lt;img decoding=&quot;async&quot;&gt;
</code></pre>
        <p>如果图像对你很重要，那么请使用同步解码。</p>
        <pre><code class="language-html">&lt;img decoding=&quot;sync&quot;&gt;
</code></pre>
        <blockquote>
            <p><strong>Note</strong></p>
            <p><code>decoding</code> 的默认值是 <code>auto</code>，此时将由浏览器来决定到底使用 <code>async</code> 还是 <code>sync</code>。</p>
        </blockquote>
        <h3 id="745de521-760a-49cf-a8c2-c56b9b929671">响应尺寸</h3>
        <p>如果你为同一幅图像制作了多个不同分辨率的版本，那么你就可以通过 <code>&lt;img&gt;</code> 标签的 <code>srcset</code> 属性来让浏览器智能的下载合适版本的图像，这可以节省流量和加速图像资源的加载速度。</p>
        <p>详请参阅 <a href="https://web.dev/learn/design/responsive-images/#responsive-images-with-srcset">Responsive images with <code>srcset</code></a> 和 <a href="https://web.dev/learn/design/picture-element/">The picture element</a>。</p>
        <h2 id="bc6d3703-de6e-48d5-a21b-25d215ba5ca6">主题</h2>
        <h3 id="96843150-85c7-4b19-a630-189aa5fc1d96">嗅探系统主题</h3>
        <p>许多操作系统都支持浅色模式和深色模式，比如 Windows 和 MacOS，<code>prefers-color-scheme</code> 媒体特性可以检测出操作系统正在使用哪种模式，然后我们就可以使用不同的主题色。</p>
        <pre><code class="language-css">/* 操作系统正在使用浅色模式 */
@media ( prefers-color-scheme: light ) {
    html { background-color: white; }
}

/* 操作系统正在使用深色模式 */
@media ( prefers-color-scheme: dark ) {
    html { background-color: black; }
}
</code></pre>
        <p>如果操作系统不支持主题色，或未设置主题色，或禁止获取主题色，那么就需要使用：</p>
        <pre><code class="language-css">@media ( prefers-color-scheme: no-preference ) {
    html { background-color: white; }
}
</code></pre>
        <h3 id="4415d688-02dd-4924-8382-4a76e233b803">accent-color</h3>
        <p>CSS 的 <code>accent-color</code> 属性可以设置单选框、复选框、进度条的颜色。</p>
        <pre><code class="language-css">input {
    accent-color: black;
}
</code></pre>
        <h2 id="66a2e56f-36e0-46be-9643-c7870717b0c7">色觉缺陷</h2>
        <p>FireFox 和 Chrome 的开发者工具都可以模拟色觉缺陷的视觉效果，在 FireFox 中，<code>开发者工具 -&gt; 无障碍环境 -&gt; 模拟</code>，在 Chrome 中，<code>开发者工具 -&gt; 渲染选项卡 -&gt; 模拟视觉缺陷</code>。</p>
        <p>Chrome 的色觉缺陷模拟功能比较难找，如果你找不到，那么你可以查看 <a href="https://developer.chrome.com/blog/new-in-devtools-83/#vision-deficiencies">这篇文章</a>。</p>
        <h2 id="b4e76104-5c12-4ae7-9e76-ca9ea995b10d">虚拟键盘</h2>
        <p>智能手机使用虚拟键盘来代替实体键盘，你可以通过参阅 <a href="https://web.dev/learn/design/interaction/#virtual-keyboards">这篇文章</a> 来学习如何优化虚拟键盘，这些优化是指：</p>
        <ul>
            <li>如何唤醒整数数字键盘；</li>
            <li>如何唤醒浮点数数字键盘；</li>
            <li>如何让虚拟键盘自动联想出相关内容，比如电话号码、邮箱、国家。</li>
        </ul>
        <h2 id="1db884a8-f0f3-4f83-8eb7-ab93266d6cd1">参考</h2>
        <p><a href="https://web.dev/learn/design/">Learn Responsive Design</a></p>
    </article>
</body>

</html>