<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Margin</title>
</head>

<body>
    <header>
        <button><a href="/catalogue.html"><strong>CATALOGUE</strong></a></button>
    </header>
    <aside>
        <p>In this article</p>
        <p data-target-id=0154dbb6-6957-4cc5-bd50-50e0f9379f4f>概述</p>
        <p data-target-id=770ee0e3-d337-4422-9af5-8c8290db7119>元素间隙</p>
        <p data-target-id=4996653d-a0f2-4554-8066-8141c70e9018>行内尺寸</p>
        <p data-target-id=8acb34f5-b39d-4ab3-8746-28433271517d>行内居中</p>
        <p data-target-id=b4cbdfd7-838f-4df2-aaaf-251ddeb7d319>边距折叠</p>
    </aside>
    <article>
        <h1>Margin</h1>
        <h2 id="0154dbb6-6957-4cc5-bd50-50e0f9379f4f">概述</h2>
        <p><code>margin</code> 是盒子模型的外边距，它真正的作用是<strong>调整元素的行内尺寸</strong>和<strong>调整元素之间的间隙</strong>。并且它还有很多怪异的行为和花哨的技巧。</p>
        <h2 id="770ee0e3-d337-4422-9af5-8c8290db7119">元素间隙</h2>
        <p>对于一个拥有固定宽高的元素，<code>margin</code> 可以调整它与相邻元素之间的间隙，有时是通过移动它自己来实现的，有时则是通过移动相邻元素来实现的，具体来说：</p>
        <ul>
            <li><code>margin-inline-start</code> 和 <code>margin-block-start</code> 会移动当前元素；</li>
            <li><code>margin-inline-end</code> 和 <code>margin-block-end</code> 会移动相邻元素；</li>
        </ul>
        <p><img src=/static/image/markdown/css/margin/adjust-block-gap.png alt=调整元素间隙（block） loading="lazy" decoding="async"></p>
        <p><img src=/static/image/markdown/css/margin/adjust-inline-gap.png alt=调整元素间隙（inline） loading="lazy" decoding="async"></p>
        <h2 id="4996653d-a0f2-4554-8066-8141c70e9018">行内尺寸</h2>
        <p>对于一个 <code>width: auto</code> 的块元素，<code>margin-inline</code> 可以调整它的行内尺寸。</p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>这也适用于 <code>width: 100%</code> 的 <code>flex</code> 子元素。</p>
        </blockquote>
        <p><img src=/static/image/markdown/css/margin/adjust-inline-size.png alt=调整行内尺寸 loading="lazy" decoding="async"></p>
        <h2 id="8acb34f5-b39d-4ab3-8746-28433271517d">行内居中</h2>
        <p>对于一个拥有固定 <code>inline-size</code> 的元素，<code>margin-inline: auto</code> 可以令元素在 <code>inline</code> 方向上居中。</p>
        <p><img src=/static/image/markdown/css/margin/inline-center.png alt=行内居中 loading="lazy" decoding="async"></p>
        <h2 id="b4cbdfd7-838f-4df2-aaaf-251ddeb7d319">边距折叠</h2>
        <p>在流动布局中，如果处于同一块格式上下文中的两个块元素的 <code>block</code> 方向上的外边距相接触了，那么这两个外边距就会发生融合，我们把这种现象称为「边距折叠」。边距折叠又分为「相邻折叠」和「内嵌折叠」两种。</p>
        <p>行内元素、行内块元素、浮动元素、绝对定位元素、根元素、<code>overflow</code> 值为非 <code>visibility</code> 的元素都不会产生这种现象。</p>
        <p>相邻折叠的规律：</p>
        <ul>
            <li>如果两个外边距都不小于零，那么最终的外边距就等于两者中的最大值；</li>
            <li>如果两个外边距都不大于零，那么最终的外边距就等于两者中的最小值；</li>
            <li>如果一个外边距不大于零，另一个外边距不小于零，那么最终的外边距就等于两者的代数和；</li>
        </ul>
        <p><img src=/static/image/markdown/css/margin/neighbor-collapsing.png alt=相邻折叠 loading="lazy" decoding="async"></p>
        <blockquote>
            <p><strong>Note</strong></p>
            <p>兄弟元素之间可以发生相邻折叠，非兄弟元素之间也可以发生相邻折叠。</p>
        </blockquote>
        <p>父子折叠的规律：</p>
        <ul>
            <li>如果父元素和子元素的外边距都不小于零，那么父元素的外边距就会等于两者中的最大值，子元素的外边距总是会等于零；</li>
            <li>如果父元素和子元素的外边距都不大于零，那么父元素的外边距就会等于两者中的最小值，子元素的外边距总是会等于零；</li>
            <li>如果一个外边距不大于零，另一个外边距不小于零，那么父元素的外边距就会等于两者的代数和，子元素的外边距总是会等于零；</li>
        </ul>
        <p><img src=/static/image/markdown/css/margin/parent-child-collapsing.png alt=父子折叠 loading="lazy" decoding="async"></p>
    </article>
</body>

</html>