# 数据类型

JavaScript 是一门动态的弱类型语言。

静态类型语言的变量的数据类型在代码的编译阶段就被确定了，动态类型语言的变量的数据类型在代码的执行阶段才被确定。

弱类型语言的变量的数据类型可以隐式转换，强类型语言的变量的数据类型不可以隐式转换。

ECMAScript 规定了 8 种数据类型，其中 7 种是原始类型， 1 种是引用类型。

## 原始类型

原始类型又称为基本数据类型，原始类型的值称为原始值。

### Number 类型

`number` 是基于 IEEE 754 标准的双精度 64 位二进制格式的值，可以安全的存储 `[ -2^53-1, 2^53-1 ]` 范围的值，显然 ECMAScript 中没有整数的数字类型，只有浮点数。

除了常规的数字， ECMAScript 还包括一些特殊数值，具体是： `Infinity` 、 `-Infinity` 、 `NaN` 。

#### 极值

浮点数的最大值是 `Number.MAX_VALUE` ，约为 `1.798e+308` ，最小值是 `Number.MIN_VALUE` ， 约为 `5e-324` ，注意最小浮点数并不等于 `0` ，而是无限接近于 `0` 。

整数的最大值是 `Number.MAX_SAFE_INTEGER` ，即为 `2^53-1` ，即 `9007199254740991` ，最小值是 `Number.MIN_SAFE_INTEGER` ，即 `-2^53-1` ，即 `-9007199254740991` 。

#### 特殊数值

ECMAScript 中还包括一些特殊的数值，分别是： `Infinity` 、 `-Infinity` 、 `NaN` 。

##### NaN

`NaN` 是英文“not a number”的缩写，它代表计算错误，当数学操作不正确时，表达式便会返回该值，如果数学表达式中有一个 `NaN` ，则该表达式的运算结果必然也是 `NaN` ，只有一个例外： `NaN ** 0` 的结果为 `1` 。

> 数学运算是安全的：在 JavaScript 程序中，我们做的任何离谱的数学运算都不会引发错误（比如 `1 / 0` 、 `"string" + 1` 等等），程序也不会因此被杀死，最坏的情况下我们也只是得到 `NaN` 的结果而已。

此外， `NaN` 是 ECMAScript 中唯一一个自己不等于自己的值：

```js
NaN ==  NaN; // 返回false
NaN === NaN; // 返回false
```

虽然浏览器运行时提供了 `window.isNaN( v )` 来鉴定 `NaN` ，但是实际上这个 API 并不可靠，因为输入 `NaN` 或 `undefined` 或 `非空非数字字符串` 或 `函数` 或 `对象` 时，它都会返回 `true` ：

如果想要鉴定 `NaN` ，请使用 `Number.isNaN( v )` 方法，或者它的 `Polyfill` ：

```js
if ( !Number.isNaN ) { 

    Number.isNaN = function( n ) { return n !== n };

}
```

##### Infinity 和 -Infinity

`Infinity` 代表数学中的无穷大 ∞ 。

JavaScript 无法存储和表示超出数值极限的值，当数值超出极限后，数值会被"就近"的舍入到 `Number.MAX_VALUE` 或 `Infinity` ，比如：

```js
Number.MAX_VALUE + Math.pow( 2, 969 ); // 返回Number.MAX_VALUE
Number.MAX_VALUE + Math.pow( 2, 970 ); // 返回Infinity
```

#### 解析数字字符串



### BigInt 类型

### String 类型

#### Boolean 类型

### Null 类型

### Undefined 类型

### Symbol 类型

## 引用类型

引用类型又称为复杂数据类型，引用类型的值称为引用值。

## 待定-原始类型和引用类型的区别

首先，在存储方式上，原始值存储在栈空间中，引用值存储在堆空间中。

 JavaScript 引擎可以直接获取存储在栈空间中的值，对于存储在堆空间中的值， JavaScript 引擎必须先从栈空间中获得指向引用值的指针（地址字符串），然后再根据指针从堆空间中获取引用值。

之所以要这么设计，是为了加快查找值的速度，因为所有原始值所占的存储空间大小是固定不变的，如果栈空间中只存储原始值，那么每个原始值的地址都相差 N 个偏移量